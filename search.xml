<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AST</title>
    <url>/2020/07/03/AST/</url>
    <content><![CDATA[<p>AST 一种语法树<span id="more"></span></p>
<div class="tip">
   tip文案
</div>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS准备</title>
    <url>/2020/04/08/CSS_review/</url>
    <content><![CDATA[<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="1-介绍下BFC及其应用"><a href="#1-介绍下BFC及其应用" class="headerlink" title="1. 介绍下BFC及其应用"></a>1. 介绍下BFC及其应用</h4><ul>
<li><p>BFC 是什么: ( Block Formatting Context ) 块级格式上下文<br>它是 css 盒模型的渲染模式，独立渲染区域，内部元素的渲染不会影响边界以外的元素。<br>有着盒子对齐，解决外边距重叠（ margin 塌陷问题），清除浮动，防止文字环绕，多列最后列宽度自定义（不挤掉）</p>
</li>
<li><p>怎么新建一个 BFC :<br>一个新的 BFC 可以通过给容器添加任何一个触发 BFC 的 CSS 样式，如 overflow : scroll, overflow : hidden, display : flex / inline-block, float: left, position 为 absolute / fixed 或者 display: table来创建。<br>display: table 可能会产生一些问题<br>overflow: scroll 可能会显示不必要的滚动条<br>float: left 将会把元素置于容器的左边，其他元素环绕着它<br>overflow: hidden 将会剪切掉溢出的元素</p>
</li>
</ul>
<p>参考链接：<br><a class="link"   href="https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html" >w3cPlus<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" >MDN<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="2-float-布局的应用（双飞翼-圣杯）"><a href="#2-float-布局的应用（双飞翼-圣杯）" class="headerlink" title="2. float 布局的应用（双飞翼 圣杯）"></a>2. float 布局的应用（双飞翼 圣杯）</h4><p>圣杯和双飞翼布局的特点：<br>（1）三栏布局，中间一栏最先加载和渲染（网络慢的时候优先加载 dom 有优势）<br>（2）两侧内容固定，中间内容随着宽度自适应<br>（3）常用于 PC 网页</p>
<p>技术特点：<br>（1）使用 float 布局<br>（2）两侧使用margin负值，以便和中间内容<strong>横向重叠</strong><br>（3）防止中间内容被两侧覆盖，一个用 padding ， 一个用 margin</p>
<p>圣杯布局代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Right</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>:<span class="number">190px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#E79F6D</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#D6D6D6</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#77BBDD</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">190px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>双飞翼布局：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center-wrap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#D6D6D6</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-class">.center-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center-wrap</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#E79F6D</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#77BBDD</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-flex-布局"><a href="#3-flex-布局" class="headerlink" title="3. flex 布局"></a>3. flex 布局</h4><p>如何用 flex 实现一个三点的🎲</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-盒子模型理解以及相关CSS属性"><a href="#4-盒子模型理解以及相关CSS属性" class="headerlink" title="4. 盒子模型理解以及相关CSS属性"></a>4. 盒子模型理解以及相关CSS属性</h4><ul>
<li>什么是盒子模型？<br>网页的 dom 具有盒子的属性，一层一层的装载。故把 dom 称为盒子模型。<br>盒子模型范围包括：content 、padding 、border 、margin</li>
</ul>
<p>存在两种盒子模型：标准 w3c 盒子模型（主流）、IE盒子模型（以页面头顶的 Doctype 声明来区分）<br>它们区别在于：标准 w3c 盒子模型，content 是仅仅包括自身宽高，而 IE盒子模型的 content 宽高是（自身宽高+ padding + border）</p>
<ul>
<li><strong>offset</strong>系列：</li>
</ul>
<p>(offset 单词自身就有偏移量的意思) 表示元素在屏幕上占用的可见空间，都以像素为单位。<br>属性为 只读不可写<br>可见大小由：高度、宽度、内边距、滚动条、边框。 （<strong>！！！不包括外边距</strong>）<br>    - offsetHeight : 元素在垂直方向占用的空间大小<br>    - offsetWidth : 元素在水平方向占用的空间大小<br>    - offsetLeft : 元素的左边框 至 <strong>包含元素</strong>的左内边框 的像素距离<br>    - offsetTop : 元素的上边框 至 <strong>包含元素</strong>的上内边框 的像素距离<br>    - offsetParent : 包含元素的引用</p>
<ul>
<li><strong>client</strong>系列：</li>
</ul>
<p>属性为 只读不可写<br>(表示客户区大小的含义) 元素内容以及内边距占用的空间大小<br>    - clientWidth : 内容宽度 + 左右内边距<br>    - clientHeight : 内容高度 + 上下内边距<br>应用场景：<br>浏览器视口大小：document.documentElement.clientWidth / clientHeight<br>适配ie7:      document.body.clientWidth / clientHeight<br>(document.compatMode == ‘BackCompat’ // 确保浏览器在混杂模式 此时是适配ie系列)</p>
<ul>
<li><strong>scroll</strong>系列：</li>
</ul>
<p>表示包含滚动内容的元素的大小。<br>    - scrollHeight : 在没有滚动条的情况下，元素内容的总高度。<br>    - scrollWidth : 在没有滚动条的情况下，元素内容的总宽度。<br>    - scrollLeft : 页面左边滚动隐藏的像素。（<strong>可改</strong>）<br>    - scrollTop : 页面上边滚动隐藏的像素。（<strong>可改</strong>）</p>
<ul>
<li><strong>getBoundingClientrect</strong></li>
</ul>
<p>返回矩形对象，包括4个属性：left 、top 、right 、bottom。表示<strong>元素</strong>相对<strong>视口</strong>的位置。</p>
<h4 id="5-margin"><a href="#5-margin" class="headerlink" title="5. margin"></a>5. margin</h4><ul>
<li><p>margin 塌陷问题<br>margin塌陷表现为 元素在垂直距离上的合并，a元素和b元素是垂直的，a设置 margin-bottom 100px b设置 margin-top 150px<br>a 和 b 在塌陷的情况下，表现为垂直外边距相差的最大值 ，即 150px。<br>创建 <strong>BFC</strong> 可以解决此问题</p>
</li>
<li><p>margin负值问题<br>在另一篇margin负值博文有详细介绍，链接：<a target="blank" href="/2020/04/08/CSS/margin负值/">点此</a></p>
</li>
</ul>
<h4 id="6-A-display-none-B-visibility-hidden-C-opacity-0的区别"><a href="#6-A-display-none-B-visibility-hidden-C-opacity-0的区别" class="headerlink" title="6. A: display:none; B: visibility:hidden; C: opacity: 0的区别"></a>6. A: display:none; B: visibility:hidden; C: opacity: 0的区别</h4><ul>
<li>展示程度上<br>都不显示</li>
<li>dom可操作上<br>A不可操作，B不可操作，C可操作</li>
<li>继承性<br>A和C的父盒子设置了对应的属性A和C，则他们的子代也是不可见，不可操作。B的子代是可以设置显示的</li>
<li>性能<br>A改变了结构，引起文档回流，性能消耗最大<br>B引起元素重绘，消耗中等<br>C消耗最低</li>
</ul>
<h4 id="7-css-定位"><a href="#7-css-定位" class="headerlink" title="7. css 定位"></a>7. css 定位</h4><ul>
<li><p>absoulte 和 relative 分别依据什么定位？<br>relative 依据自身定位（圣杯布局时有用自身定位 位移左侧）<br>absolute 依据最近一层的定位元素定位</p>
</li>
<li><p>居中对齐有哪些实现方式？<br>水平居中 ：<br>inline 元素：text-align ：center<br>block 元素：margin ：0 auto<br>absolute 元素： left 50% + margin-left 负值（需要知道宽度）</p>
</li>
</ul>
<p>垂直居中 ：<br>inline 元素： line-height = height<br>absolute 元素： top 50% + margin-top 负值 （需要知道高度）<br>absolute 元素：transform（-50%， -50%）<br>absolute 元素：top、left、bottom、right = 0 + margin：auto</p>
<h4 id="8-图文样式"><a href="#8-图文样式" class="headerlink" title="8 图文样式"></a>8 图文样式</h4><p>line-height 如何继承？<br>line-height 具有继承属性，如果是具体数值或比例，则直接继承；如果是百分比，需 line-height 乘 font-size，再继承</p>
<h4 id="9-响应式原理"><a href="#9-响应式原理" class="headerlink" title="9 响应式原理"></a>9 响应式原理</h4><p>在另一篇博文有详细介绍，链接：<a target="blank" href="/2020/04/09/CSS/响应式/">点此</a></p>
<h4 id="10-重绘-amp-amp-重排"><a href="#10-重绘-amp-amp-重排" class="headerlink" title="10 重绘 &amp;&amp; 重排"></a>10 重绘 &amp;&amp; 重排</h4><p>在另一篇博文有详细介绍，链接：<a target="blank" href="/2020/07/20/重绘&&重排/">点此</a></p>
<hr>
<p>参考链接：<br><a class="link"   href="https://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/" >张鑫旭BLOG<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2019新变化</title>
    <url>/2020/07/20/ES2019%E6%96%B0%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>1 数组：<br>数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]];</span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>flat还会移除数组空项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat(); <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>2 字符串<br>去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="string">&quot; hello &quot;</span>;</span><br><span class="line"></span><br><span class="line">test.trim(); <span class="comment">// &quot;hello&quot;;</span></span><br><span class="line">test.trimStart(); <span class="comment">// &quot;hello &quot;;</span></span><br><span class="line">test.trimEnd(); <span class="comment">// &quot; hello&quot;;</span></span><br></pre></td></tr></table></figure>


<p>3 对象<br>Object.fromEntries() 数组转对象<br>与之相对应的是Object.entries() 对象转数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">prop1</span>: <span class="number">2</span>, <span class="attr">prop2</span>: <span class="number">10</span>, <span class="attr">prop3</span>: <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为键值对数组：</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Object</span>.entries(obj); </span><br><span class="line"><span class="comment">// [[&quot;prop1&quot;, 2], [&quot;prop2&quot;, 10], [&quot;prop3&quot;, 15]]</span></span><br><span class="line"></span><br><span class="line">array = array.map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> [key, <span class="built_in">Math</span>.pow(value, <span class="number">2</span>)]); </span><br><span class="line"><span class="comment">// [[&quot;prop1&quot;, 4], [&quot;prop2&quot;, 100], [&quot;prop3&quot;, 225]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">Object</span>.fromEntries(array); </span><br><span class="line"><span class="comment">// &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<br><a class="link"   href="https://github.com/sisterAn/blog/issues/47" >瓶子君的blog<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>H5-insertAdjacentElement</title>
    <url>/2019/03/11/H5-insertAdjacentElement/</url>
    <content><![CDATA[<h6 id="insertAdjacentElement作用是？"><a href="#insertAdjacentElement作用是？" class="headerlink" title="insertAdjacentElement作用是？"></a>insertAdjacentElement作用是？</h6><p>该方法将一个给定的元素节点<code>插入到</code><em>相对于被调用的元素</em>的给定的<code>一个位置</code>。</p>
<h6 id="如何用呢？"><a href="#如何用呢？" class="headerlink" title="如何用呢？"></a>如何用呢？</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element1.insertAdjacentElement(position, element2);</span><br></pre></td></tr></table></figure>
<p>参数positon:</p>
<ul>
<li><code>beforebegin</code>: 在该元素本身的前面.</li>
<li><code>afterbegin</code>:只在该元素当中, 在该元素第一个子孩子前面.</li>
<li><code>beforeend</code>:只在该元素当中, 在该元素最后一个子孩子后面.</li>
<li><code>afterend</code>: 在该元素本身的后面.</li>
</ul>
<p>element1：不动的元素<br>element2：被插入的元素</p>
<h6 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fileWrap = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;<span class="built_in">this</span>.fileWrapId&#125;</span>`</span>);</span><br><span class="line">fileWrap.insertAdjacentElement(<span class="string">&#x27;afterbegin&#x27;</span>, elem); <span class="comment">// elem为插入的元素</span></span><br></pre></td></tr></table></figure>

<h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentElement" >mdn<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML面试准备</title>
    <url>/2020/04/12/HTML_review/</url>
    <content><![CDATA[<h4 id="1-如何理解HTML语义化"><a href="#1-如何理解HTML语义化" class="headerlink" title="1. 如何理解HTML语义化"></a>1. 如何理解HTML语义化</h4><p>之所以尽可能用<strong>贴近应用场景</strong>的标签</p>
<ul>
<li>能让<strong>开发者</strong>一目了然层级关系，增加代码可读性。</li>
<li>能让<strong>搜索引擎🔍</strong>更好的识别（<strong>SEO</strong>）。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/%E8%AF%AD%E4%B9%89%E5%8C%96.jpeg"
                      alt="语义化"
                ></p>
<h4 id="2-块级元素和内联元素"><a href="#2-块级元素和内联元素" class="headerlink" title="2. 块级元素和内联元素"></a>2. 块级元素和内联元素</h4><pre><code>块级：display: block / table ； 有 div h1 h2 table ul ol p等；
内联：display: inline / inline-block; 有 span img input button等；
</code></pre>
<h4 id="3-meta-标签设置"><a href="#3-meta-标签设置" class="headerlink" title="3. meta 标签设置"></a>3. meta 标签设置</h4><ul>
<li><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code><br>含义是： 如果渲染浏览器为 <code>IE</code> 时，希望渲染版本的引擎以 标签设置为准，此处为 <code>edge</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/2020/01/04/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>模块化的简单包装</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 利用了自执行函数的封闭性</span></span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(_count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(_count + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">m1</span>: m1,</span><br><span class="line">        <span class="attr">m2</span>: m2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>


<h3 id="1-JS模块化发展历史"><a href="#1-JS模块化发展历史" class="headerlink" title="1 JS模块化发展历史"></a>1 JS模块化发展历史</h3><ul>
<li>CommonJS 和 AMD CMD 鼎足之势 （前） ES6 （后）<br>（知名框架 Node.js、RequireJS前置加载 和 Seajs就近加载 分别对应前三个）</li>
<li>谈谈现阶段：<ul>
<li>ES6标准发布后，module成为标准，标准使用是以<code>export</code>指令导出接口，以<code>import</code>引入模块。</li>
<li>在我们一贯的node模块中，我们依然采用的是<code>CommonJS</code>规范，使用<code>require</code>引入模块，使用<code>module.exports</code>导出接口。是<code>同步</code>加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范<code>无法直接在浏览器</code>中使用。</li>
</ul>
</li>
</ul>
<h3 id="2-对于es6模块的看法（参考阮一峰老师）"><a href="#2-对于es6模块的看法（参考阮一峰老师）" class="headerlink" title="2 对于es6模块的看法（参考阮一峰老师）"></a>2 对于es6模块的看法（参考阮一峰老师）</h3><ul>
<li><p><code>es6标准</code>将成为服务器和浏览器端模块化的<code>通用解决方法</code> </p>
</li>
<li><p><code>运行时加载</code>：代码运行到这个语句的时候才会加载 </p>
</li>
<li><p><code>编译时加载</code>：打包工具编译js时，就会去分析模块之间的依赖关系，所以不能放在任何条件代码块里。层级最优先</p>
</li>
<li><p>es6模块中的this指向是undefined，不要轻易用this, CommonJs中的this指向当前模块</p>
</li>
<li><p>export的使用，如果需导出的模块前面没有export，那在export的时候就要加上{}</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;fn&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>export导出语句是动态绑定的，如果导出的值发生变化，那import进的值也会随之变化</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// exportJs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; () =&gt; foo = <span class="string">&#x27;baz&#x27;</span>; &#125;,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">那么foo变量值将在500ms后变成baz字符串，这点与<span class="string">`commonJS`</span>不一样，commonJs是会缓存值。</span><br></pre></td></tr></table></figure></li>
<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部并首先执行，但还是建议放在头部写比较好。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>; <span class="comment">// right </span></span><br></pre></td></tr></table></figure></li>
<li><p>*号指定整体输出的一个对象</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> funciton <span class="function"><span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 需要引入cilcle.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">circle.fn1();</span><br><span class="line">circle.fn2();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>export 的default输出，默认输出</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exportJs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// importJs</span></span><br><span class="line"><span class="keyword">import</span> customFn <span class="keyword">from</span> <span class="string">&#x27;./exportJS&#x27;</span></span><br><span class="line">customFn();</span><br></pre></td></tr></table></figure></li>
<li><p>import函数大括号的写法时机<br>export后面接着default的时候，不用大括号，没接着的时候是要大括号的。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无 default</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; fn1&#125; <span class="keyword">from</span> <span class="string">&#x27;exportJs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有default</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> fn2 <span class="keyword">from</span> <span class="string">&#x27;exportJs&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为静态分析没有运行时加载那么“动态化”，所以，import有个提案，目前可以在webpack使用，可以动态输入一个较为狭窄的路径，然后返回一个promise对象<br>这个情况下的import是支持<code>按需加载</code>，<code>条件加载</code>，和<code>动态的模块路径</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./someModule/$&#123;someVariable&#125;.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">module</span>.loadPageInfo(main)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        mian.textContent = err.message;                                                 </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>script标签的defer和async属性差异，两者都是取消了js的同步属性。<br>但是defer是<code>渲染完再执行</code>，而async是<code>下载完就执行</code>。</p>
</li>
<li><p>待验证：es6模块在网页上的加载</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;./util.js&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>es6模块，导出的变量不可以重新赋值，但可以添加或修改属性，就是内存地址不能改，里面存的内容随你改，待验证。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">&#x27;lib&#x27;</span></span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// right</span></span><br><span class="line">obj = &#123;&#125;        <span class="comment">// typeError</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>import</code>命令加载<code>commonJS</code>模块，Node会自动将<code>module.exports</code>当成模块的默认输出，即等同于<code>export default</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#123;default: null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; somethimg &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span> <span class="comment">// error！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = express.default() <span class="comment">// right</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>commonJs</code>的加载原理<br>commonJs每个模块都是一个脚本文件，Node内部用require命令第一次加载就会执行这个脚本，然生成一个对象，这个会缓存，即是多次require，不清缓存下，都取第一次。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,         <span class="comment">// 模块名</span></span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;,    <span class="comment">// 导出模块, </span></span><br><span class="line">    <span class="attr">loaded</span>: <span class="literal">true</span>    <span class="comment">// 是否加载过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>循环加载：模块之间相互引用<br>CommonJs会出现，输出已执行的部分，未执行的部分不会输出<br>es6模块则不会报错</p>
</li>
</ul>
<p>参考文章：<br><a class="link"   href="https://juejin.im/post/58882a42128fe100684ad9de" >掘金<i class="fas fa-external-link-alt"></i></a><br>阮一峰es6 模块篇章</p>
]]></content>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA</title>
    <url>/2020/02/06/PWA/</url>
    <content><![CDATA[<h3 id="1-PWA是什么？（Progressive-Web-App）"><a href="#1-PWA是什么？（Progressive-Web-App）" class="headerlink" title="1.PWA是什么？（Progressive Web App）"></a>1.PWA是什么？（<code>Progressive Web App</code>）</h3><p>书面上意思：渐进式网络应用<br>特点：</p>
<ul>
<li>稳定：不好的网络环境下也有好的展现数据能力（<code>service worker</code>）</li>
<li>过渡自然的动画交互，良好的滚动，响应快</li>
<li>像原生一般丝滑，可以推送，可安装</li>
<li>android支持度好，apple支持度差</li>
</ul>
<h3 id="1-1-关键技术"><a href="#1-1-关键技术" class="headerlink" title="1.1 关键技术"></a>1.1 关键技术</h3><ul>
<li>service worker : 一个存在于客户端和服务器之间的代理，可以控制缓存和应对资源请求,预缓存关键资源。所以它对安全的要求也很高，需要在Https环境下运行。</li>
<li>manifest: （可以理解为一个可设置的入口文件）<br>​              能够将你浏览的网页添加到你的手机屏幕上<br>​              在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）<br>​              控制屏幕 横屏 / 竖屏 展示<br>​              定义启动画面<br>​              可以设置你的应用启动是从主屏幕启动还是从 URL 启动<br>​              可以设置你添加屏幕上的应用程序图标、名字、图标大小</li>
</ul>
<h3 id="2-可以用来干嘛呢"><a href="#2-可以用来干嘛呢" class="headerlink" title="2.可以用来干嘛呢"></a>2.可以用来干嘛呢</h3><ul>
<li>推送，这点需要安卓去验证，目前PWA的支持度仅是安卓比较好。ios的google浏览器也不支持</li>
<li>离线缓存。 可以设置缓存的资源，即使离线也可以访问</li>
</ul>
<h3 id="3-DEMO"><a href="#3-DEMO" class="headerlink" title="3. DEMO"></a>3. DEMO</h3><p>demo已放在mineScript文件夹下<br>github地址是：<a class="link"   href="https://github.com/jonnzer/good_snippet/tree/master/PWA" >demo<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>代码结构：</li>
</ul>
<ul>
<li>sw.js: 引入serviceWorker.js，定义缓存资源，部署整个sw的生命周期代码</li>
<li>manifest.json: 一个定义好背景颜色，展示图片，icon，的入口文件。</li>
<li>建议部署在https环境下的cdn。</li>
</ul>
<p>参考链接：<br><a class="link"   href="https://developers.google.com/web/progressive-web-apps/" >官网<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/5ae2f82f6fb9a07acd4d761e" >掘金1<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6" >serviceWorker的调试<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM实现（Object.defineProperty &amp;&amp; 观察订阅）</title>
    <url>/2020/07/23/MVVM/</url>
    <content><![CDATA[<h3 id="1-MVVM特点图解"><a href="#1-MVVM特点图解" class="headerlink" title="1. MVVM特点图解"></a>1. MVVM特点图解</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/MVVM/MVVM1.png"
                      alt="MVVM注解图1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/MVVM/MVVM2.png"
                      alt="MVVM注解图2"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/MVVM/MVVM3.png"
                      alt="MVVM注解图3"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/MVVM/MVVM4.png"
                      alt="MVVM注解图4"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/MVVM/MVVM5.png"
                      alt="MVVM注解图5"
                ></p>
<h3 id="2-MVVM的功能："><a href="#2-MVVM的功能：" class="headerlink" title="2. MVVM的功能："></a>2. MVVM的功能：</h3><ul>
<li>给所有data属性值都设置数据劫持，绑定好属性观察。（<em>也是深度响应原理</em>）</li>
<li>结合观察订阅者模式</li>
</ul>
<h3 id="3-代码实现：-MVVM-包含双向数据绑定、v-model、computed"><a href="#3-代码实现：-MVVM-包含双向数据绑定、v-model、computed" class="headerlink" title="3.代码实现：(MVVM 包含双向数据绑定、v-model、computed)"></a>3.代码实现：(<code>MVVM </code>包含双向数据绑定、<code>v-model</code>、<code>computed</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * let zs = new Vue(&#123;</span></span><br><span class="line"><span class="comment"> *     el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="comment"> *     data: &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment"> * &#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>options 参考vue实例化时传进的对象,代表我们存储的所有对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoVue</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options;  <span class="comment">// 当前实例，存储存进的对象</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">this</span>._data = <span class="built_in">this</span>.$options.data;  <span class="comment">// 当前实例，存储options.data 准备像vue一样观察数据</span></span><br><span class="line">    observe(data);</span><br><span class="line">    <span class="comment">// 为了代理_data属性。可以直接在实例的时候取到data，再用define一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,key,&#123;</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>._data[key]; <span class="comment">// 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>._data[key] = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> computed = <span class="built_in">this</span>.$options.computed;</span><br><span class="line">    operatedComputed.call(<span class="built_in">this</span>)  <span class="comment">// computedde 的操作需放在数据都已被观察完，并挂载到_data里</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">new</span> Compile(options.el, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operatedComputed</span>(<span class="params"></span>) </span>&#123; <span class="comment">// computed 处理函数</span></span><br><span class="line">    <span class="keyword">let</span> vm = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> computedFn = <span class="built_in">this</span>.$options.computed</span><br><span class="line">    <span class="built_in">Object</span>.keys(computedFn).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// computed挂载到vm上</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(vm,key,&#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">typeof</span> computedFn[key] === <span class="string">&#x27;function&#x27;</span> ?  computedFn[key] : computedFn[key].get,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 数据劫持，增加Object.defineProperty</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Observe(data); <span class="comment">// 方便递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把数据编译到dom上，实现数据绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>el 替换的dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>vm 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * note:</span></span><br><span class="line"><span class="comment"> * (1) 文档碎片</span></span><br><span class="line"><span class="comment"> * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]</span></span><br><span class="line"><span class="comment"> * (3)正则图形化 https://regexper.com/</span></span><br><span class="line"><span class="comment"> * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">    vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment(); <span class="comment">// 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低</span></span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="comment">// 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方</span></span><br><span class="line">    <span class="comment">// 因此vm.$el.firstChild才会不停地切换成下一个子节点。</span></span><br><span class="line">    <span class="comment">// --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (child = vm.$el.firstChild) &#123;</span><br><span class="line">        fragment.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    replace(fragment);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Array.from 将伪数组对象转为数组实例</span></span><br><span class="line"><span class="comment">      textContext: 节点内容</span></span><br><span class="line"><span class="comment">      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字</span></span><br><span class="line"><span class="comment">      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Array</span>.from(fragment.childNodes).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> text = node.textContent;</span><br><span class="line">            <span class="keyword">let</span> exp;</span><br><span class="line">            <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">               exp = text.replace(reg, <span class="string">&#x27;$1&#x27;</span>); <span class="comment">// 正则匹配中第一个括号所代表的内容</span></span><br><span class="line">                <span class="keyword">let</span> pointArr = exp.split(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// a.a b</span></span><br><span class="line">                <span class="keyword">let</span> existVal = vm;</span><br><span class="line">                pointArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">// vm.a.a  vm.b</span></span><br><span class="line">                    existVal = existVal[key];</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 添加一个watcher事件 监听了值的变化</span></span><br><span class="line">                <span class="keyword">new</span> Watcher(vm,exp,<span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                    node.textContent = text.replace(reg, newVal);</span><br><span class="line">                &#125;);</span><br><span class="line">                 <span class="comment">// @todo此处parser有待完善，只能兼容纯&#123;&#123;&#125;&#125;，带上其他字符会让existVal失效</span></span><br><span class="line">                node.textContent = text.replace(reg, existVal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">1</span> ) &#123; <span class="comment">// v-model实现</span></span><br><span class="line">                <span class="keyword">let</span> attr = <span class="built_in">Array</span>.from(node.attributes)</span><br><span class="line">                <span class="keyword">let</span> attr_value;</span><br><span class="line">                attr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (item.name === <span class="string">&#x27;v-model&#x27;</span>) &#123;</span><br><span class="line">                        attr_value = item.value</span><br><span class="line">                        <span class="keyword">new</span> Watcher(vm,attr_value, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                            node.value = newVal</span><br><span class="line">                        &#125;)</span><br><span class="line">                        node.addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                            vm[attr_value] = e.target.value</span><br><span class="line">                        &#125;)  </span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.childNodes) &#123;</span><br><span class="line">                replace(node);</span><br><span class="line">            &#125;</span><br><span class="line">            vm.$el.appendChild(fragment); <span class="comment">// 文档碎片的内容重新添加到原来挂载的元素里</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 实际观察方法,设置 Object.defineProperty</span></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = data[key];</span><br><span class="line">        observe(val); <span class="comment">// 这里就已经可以递归了</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data,key, &#123;</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 此时Dep.target是this</span></span><br><span class="line">                <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                    dep.addSub(Dep.target); <span class="comment">// 添加事件订阅（watcher 的 push）</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (newVal ===  val) &#123; <span class="comment">// 值没发生变化</span></span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    val = newVal; <span class="comment">// 更新值。get获取值时，也可以得到最新的值。</span></span><br><span class="line">                    observe(newVal); <span class="comment">// 这里是为了给新值也添上观察者</span></span><br><span class="line">                    dep.notify(); <span class="comment">// 添加事件的通知更新（watcher的update）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Dep</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []; <span class="comment">// 事件池</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">sub</span>) </span>&#123; <span class="comment">// 订阅</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 通知</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">        sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件池其中的一个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>vm: 实例环境（总的数据来源）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>正则表达式的遍历对象exp (要更改的对象)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn（处理的回调函数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm,exp,fn</span>) </span>&#123; <span class="comment">// fn是回调函数 new的时候传进来</span></span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.exp = exp;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到订阅中</span></span><br><span class="line">    <span class="comment">// Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> val = vm;</span><br><span class="line">    <span class="keyword">let</span> arr = exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123; <span class="comment">// 这里获取 this.a.a时还是会触发到默认的getter</span></span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// watcher的更新方法</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">this</span>.vm;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">this</span>.exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123;</span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.fn(val); <span class="comment">// 把最新值传进callback</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;a.a&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;b&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;cacultate_c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;script src=&quot;../dist/my_bundle.js&quot;&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./compile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 调用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> little = <span class="keyword">new</span> demoVue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">a</span>: &#123;<span class="attr">a</span>:<span class="string">&quot;是a&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">b</span>: <span class="string">&quot;是b&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">cacultate_c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.a.a + <span class="built_in">this</span>.b;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">cacultate_d</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.a.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.b</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.a = val</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>1、 <code>Object.defineProperty</code> 给对象设置某属性，并且可以设置setter，用于绑定属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;school&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 让 delete 更新属性值 生效</span></span><br><span class="line">    <span class="attr">enumberable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123; <span class="comment">// 设置值时触发</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setting &#x27;</span>)</span><br><span class="line">        obj.school = val <span class="comment">// 超出内存 mag size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a class="link"   href="https://juejin.im/post/5e7410ed51882549087dc365#heading-0" >掘金 - MVVM<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/hf872914334/article/details/88899326" >发布订阅模式 &amp;&amp; 观察者模式<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/51357583" >发布订阅模式 &amp;&amp; 观察者模式<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://segmentfault.com/a/1190000019700618" >Vue2.0响应原理<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>MVVM 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见技巧</title>
    <url>/2020/05/26/array/</url>
    <content><![CDATA[<h3 id="1-数组降维"><a href="#1-数组降维" class="headerlink" title="1. 数组降维"></a>1. 数组降维</h3><p>二维数组降维成一维数组（引自vue源码）</p>
<blockquote>
<p>利用原理：<br>(1) <code>concat</code>的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；<br>(2) <code>apply</code>的优化：<code>Array.prototype.concat.apply</code>([], children) 等同于 [].concat(demoArr)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demoArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">22</span>,<span class="number">23</span>,<span class="number">43</span>]]</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">simpleNormalizeChildren(demoArr)  </span><br><span class="line"><span class="comment">// result =&gt;  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>多维数组递归降维(借助了<code>递归</code>的能力)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> children = [<span class="number">1</span>, [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]], [<span class="number">9</span>, <span class="number">10</span>]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      children = <span class="built_in">Array</span>.prototype.concat.apply([], children);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j&lt;children.length; j++) &#123;</span><br><span class="line">        simpleNormalizeChildren(children)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line">simpleNormalizeChildren(children); </span><br><span class="line"><span class="comment">// result =&gt;  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2. 数组去重"></a>2. 数组去重</h3><p>（1） ES6 <code>set</code>方法 (Set 对象允许你存储任何类型的唯一值)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line"> <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"> <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;] </span></span><br></pre></td></tr></table></figure>
<div class="tip">
  set方法无法识别重复的{}空对象
</div> 

<p>（2）双重for循环，splice去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//前者等于后者的时候，splice方法删除后者</span></span><br><span class="line">                    arr.splice(j,<span class="number">1</span>);</span><br><span class="line">                    j--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">     <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="tip">
NaN和{}没有去重，两个null直接消失了
</div>


<p>(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">           <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">   <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  </span></span><br></pre></td></tr></table></figure>
<div class="tip">
NaN、{}没有去重</div>

<p>(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> seen; <span class="comment">// 动态指针</span></span><br><span class="line">  <span class="comment">// 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数</span></span><br><span class="line">  <span class="keyword">var</span> targetArr = <span class="built_in">Array</span>.prototype.concat.call(arr).sort() </span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="comment">// 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;targetArr.length; i++) &#123; </span><br><span class="line">     <span class="comment">// 这里 0转为boolean是false，!0即true</span></span><br><span class="line">    <span class="comment">// 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素</span></span><br><span class="line">    <span class="keyword">if</span> (!i || seen !== targetArr[i]) &#123;</span><br><span class="line">      result.push(targetArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    seen = targetArr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">         <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure>

<div class="tip">
  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。
</div>

<p>(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法<br> <code>array</code>： 必填参数，去重目标数组<br><code>isSorted</code>: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf<br><code>iteratee</code>: 自定义对目标数组的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array, isSorted, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> seen = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = array[i];</span><br><span class="line">        <span class="keyword">var</span> computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || seen !== computed) &#123;</span><br><span class="line">                res.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">            seen = computed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.indexOf(computed) === -<span class="number">1</span>) &#123;</span><br><span class="line">                seen.push(computed);</span><br><span class="line">                res.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res.indexOf(value) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(value);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array3, <span class="literal">false</span>, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> item == <span class="string">&#x27;string&#x27;</span> ? item.toLowerCase() : item</span><br><span class="line">&#125;)); <span class="comment">// [1, &quot;a&quot;, 2]</span></span><br></pre></td></tr></table></figure>

<p>(6) 利用Object的key是唯一的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) </span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是叹为观止，妙！妙在哪？</p>
<ul>
<li><code>array.filter</code>本身就兼职<code>遍历，过滤，返回新数组</code>于一身，干净利落</li>
<li>Object的<code>key确实是唯一</code>的，如果重复时候，只能是覆盖value的</li>
<li>filter过滤条件需要的<code>true和false</code>就由 Obj是否包含这个<code>type+value</code>为key  来决定，<br>如果之前没存进obj，可以任意设置一个value，就是三元运算符里的<code>obj[typeof item + item] = true</code></li>
</ul>
<hr>
<h3 id="API补充："><a href="#API补充：" class="headerlink" title="API补充："></a>API补充：</h3><ol>
<li><code>reduce</code></li>
</ol>
<p>升序让数组每一项都调用传入函数，可以设置初始值。<br>四个参数<br><code>Accumulator</code> (acc) (累计器)<br><code>Current Value</code> (cur) (当前值)<br><code>Current Index</code> (idx) (当前索引)<br><code>Source Array </code>(src) (源数组)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 统计出现次数</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tiff&#x27;</span>, <span class="string">&#x27;Bruce&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>];</span><br><span class="line"><span class="comment">// allNames为Accumulator累积器，name为当前值</span></span><br><span class="line"><span class="keyword">var</span> countedNames = names.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">allNames, name</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (name <span class="keyword">in</span> allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    allNames[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// countedNames is:</span></span><br><span class="line"><span class="comment">// &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// proxy结合reduce实现 链式调用函数封装 需是get结尾</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">// value是参数 闭包缓存funcStack数组</span></span><br><span class="line">          <span class="keyword">var</span> funcStack = [];</span><br><span class="line">          <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">              <span class="attr">get</span> : <span class="function"><span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) </span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">&#x27;fnName is:&#x27;</span> + fnName)</span><br><span class="line">                  <span class="keyword">if</span> (fnName === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">                      <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> fn(val);</span><br><span class="line">                      &#125;,value);</span><br><span class="line">                  &#125;</span><br><span class="line">                  funcStack.push(<span class="built_in">window</span>[fnName]);</span><br><span class="line">                  <span class="built_in">console</span>.log(funcStack)</span><br><span class="line">                  <span class="keyword">return</span> oproxy;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> oproxy;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line">  <span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(pipe(<span class="number">3</span>)[<span class="string">&#x27;double&#x27;</span>].pow.get);</span><br><span class="line">  <span class="comment">// pipe(3).double.pow.reverseInt.get; // 63 </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>slice</code><br>类数组 =&gt; 真数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以写成 [].slice.call(arguments) </span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.from</code><br>从一个类似数组或可迭代对象创建一个新的，<code>浅拷贝</code>的数组实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure>
<p><code>arrayLike</code>：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。<br><code>mapFn</code> 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。<br><code>thisArg</code> 可选：可选参数，执行回调函数 mapFn 时 this 对象。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someNumbers = &#123; <span class="string">&#x27;0&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">15</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(someNumbers, <span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>); <span class="comment">// =&gt; [20, 30] 这里利用了mapFn的能力</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">sum, num</span>) =&gt;</span> sum + num);</span><br><span class="line">&#125;</span><br><span class="line">sumArguments(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// =&gt; 6 //这里利用了转化伪数组成真数组的能力</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><code>Array.concat()</code> 不传参数的时候，是一种浅拷贝的行为</p>
</li>
<li><p><code>Array.filter(function()&#123;&#125;)</code>  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure>
<p><code>callback</code>: 用来测试数组元素的函数 return true时 保留元素 否则不保留。<br><code>index</code>: 当前处理索引<br><code>array</code>: 调用了filter的数组本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</span><br></pre></td></tr></table></figure>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" >MDN - slice<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" >MDN - reduce<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" >MDN - typeof<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" >MDN - Array.from<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/5b4d35406fb9a04fd55ac064" >掘金 reduce<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/5d66b019f265da03a715e5d7" >掘金 Array.from<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.lagou.com/lgeduarticle/86449.html" >拉钩博文<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/mqyqingfeng/Blog/issues/27" >冴羽 Array去重 issue<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html" >阮一峰 reduce transduce 关于 函数编程<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2018/06/17/nginx%E7%A7%91%E6%99%AE%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="nginx-是什么？"><a href="#nginx-是什么？" class="headerlink" title="nginx 是什么？"></a>nginx 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态资源HTTP 服务器。通过http协议将静态资源路径暴露给客户端。</span><br><span class="line">反向代理服务器。介乎客户端和服务器的中间层，可以做虚拟主机，和负载均衡</span><br></pre></td></tr></table></figure>

<h4 id="虚拟主机-是什么？（网站访问量小的情况）"><a href="#虚拟主机-是什么？（网站访问量小的情况）" class="headerlink" title="虚拟主机 是什么？（网站访问量小的情况）"></a>虚拟主机 是什么？（网站访问量小的情况）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多域名对应同一服务器，对应同一ip，却可以打开不同网站。仿佛就像两个服务器，所以称为虚拟主机，也可以称为多开。</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡-是什么-（网站访问量大的情况）"><a href="#负载均衡-是什么-（网站访问量大的情况）" class="headerlink" title="负载均衡 是什么? （网站访问量大的情况）"></a>负载均衡 是什么? （网站访问量大的情况）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过反向代理的身份，把自己写的应用部署在多个服务器上。其实说白了，就是一份nginx配置，上面很多ip地址，会自动轮询ip地址，并根据weight的值来判断分配给指定ip的服务器的权重。</span><br></pre></td></tr></table></figure>

<h4 id="nginx-怎么配置？"><a href="#nginx-怎么配置？" class="headerlink" title="nginx 怎么配置？"></a>nginx 怎么配置？</h4><p>centos 如何安装 nginx:<br>(cemtps7): <a class="link"   href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7" >https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.cn/post/7049692191110725645#heading-13" >https://juejin.cn/post/7049692191110725645#heading-13<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/lihang_1994/article/details/72598955" >具体参考链接<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>proxy</title>
    <url>/2020/06/14/proxy/</url>
    <content><![CDATA[<p><code>vue</code>源码的render部分，曾用到<code>proxy</code>来代理vue的实例。</p>
<h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1 概念："></a>1 概念：</h3><p><code>proxy</code> 原意就有代理的意思。它是外界访问对象的一层<code>代理控制</code>，也是对访问的一种<code>改写和过滤</code>。属于一种<code>元编程</code>。</p>
<h3 id="2-作用："><a href="#2-作用：" class="headerlink" title="2 作用："></a>2 作用：</h3><p>可以从获取和设置两种时机去代理指定对象</p>
<h3 id="3-代码结构："><a href="#3-代码结构：" class="headerlink" title="3 代码结构："></a>3 代码结构：</h3><p>标准结构：</p>
<blockquote>
<p>var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// 默认是&#123;&#125;    </span></span><br><span class="line">obj.a = <span class="number">1</span> <span class="comment">// setting a</span></span><br><span class="line">obj.a = <span class="number">2</span> <span class="comment">// setting a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// getting a</span></span><br></pre></td></tr></table></figure>

<h3 id="4-要注意的点："><a href="#4-要注意的点：" class="headerlink" title="4. 要注意的点："></a>4. 要注意的点：</h3><ul>
<li><p>要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。</p>
</li>
<li><p>与原型的应用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> _obj = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line">_obj.time <span class="comment">// 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-proxy还支持get、set之外的api补充"><a href="#5-proxy还支持get、set之外的api补充" class="headerlink" title="5. proxy还支持get、set之外的api补充"></a>5. proxy还支持get、set之外的api补充</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123; <span class="comment">// proxy实例作为函数调用时触发</span></span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123; <span class="comment">// proxy作为构造函数时触发</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">&quot;Hello, foo&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 拦截 负数索引</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">     <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, receiver</span>) </span>&#123; </span><br><span class="line">         <span class="keyword">let</span> index = <span class="built_in">Number</span>(property) <span class="comment">// -1 会作为属性传进来</span></span><br><span class="line">         <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             property = <span class="built_in">String</span>(target.length + index) <span class="comment">// property\target 是可以修改的 奇怪...</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver) <span class="comment">// Reflect is what</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> target = []</span><br><span class="line"> target.push(...elements)</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">&#125;</span><br><span class="line">arr = createArray(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子"><a href="#6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子" class="headerlink" title="6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)"></a>6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, propKey</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;foo&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;123&#x27; but got &#x27;abc&#x27;)</span></span><br></pre></td></tr></table></figure>

<hr>
<p>引申了解：</p>
<ul>
<li>元编程的概念</li>
<li>proxy的get和set，与 Object.defineProperty 相比，有什么区别<ul>
<li>答：<a class="link"   href="https://juejin.im/post/5be4f7cfe51d453339084530" >jueim<i class="fas fa-external-link-alt"></i></a> proxy的应用场景更多，但是define的兼容性更好</li>
<li>答：<a class="link"   href="https://github.com/YvetteLau/Blog/issues/25" >issue<i class="fas fa-external-link-alt"></i></a></li>
<li>答：<a class="link"   href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" >两者实现双向绑定差异<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<hr>
<p>参考文章：<br><a class="link"   href="https://es6.ruanyifeng.com/#docs/proxy" >阮一峰es6 proxy章节<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect" >深入浅出es6系列<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect" >segmentFault<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming" >元编程<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas</title>
    <url>/2022/01/22/canvas/</url>
    <content><![CDATA[<h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>可以使用<code>Javascript</code>来绘制图形。<br>是一个 <code>HTML</code> 元素。<br>浏览器支持度也不错。</p>
<h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">“canvasId”</span> <span class="attr">width</span>=<span class="string">“150”</span> <span class="attr">height</span>=<span class="string">“150”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认初始值：<br>width 300px ； height：150px</p>
</li>
<li><p>css 的设置：<br>（1）width 属性和 height 属性，比 css 设置更有效果。<br>（2）margin border background 等属性不会影响 canvas 的实际效果。</p>
</li>
<li><p>渲染上下文：<br>（1） 含义：固定大小的 2D 画布。<br>（2）API： <code>getContext()</code> ：获取渲染上下文和绘画功能。接受一个参数 - 上下文的类型。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(‘canvasId’)</span><br><span class="line">canvas.getContext(‘2d’)</span><br></pre></td></tr></table></figure>

<ul>
<li>检查 canvas 支持性：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext)&#123;</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="comment">// drawing code here</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// canvas-unsupported code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见-API"><a href="#常见-API" class="headerlink" title="常见 API"></a>常见 API</h5><ul>
<li>可以绘制的基本形状 : 矩形、三角形、直线、圆弧和曲线。<br>（1）栅格 ：起点为左上角，单位为像素。<br>（2）绘制矩形和路径：<br>矩形 API：<br>x y 指定了在 canvas 画布上绘制的左上角（相对于原点）的坐标。<br>width heighgt 设置矩形的尺寸。<br>（1）fillRect (x, y, width, height)：绘制一个填空的矩形<br>（2）storkeRect (x, y, width, height) 绘制一个矩形的边框<br>（3）clearRect (x, y, width, height) 清除指定矩形区域，让清除部分完全透明<br>（4）rect (x, y, width, height) 绘制一个左上角坐标为（x,y），宽高为 width以及 height 的矩形。<br>路径 API：<br>x y 指定了在 canvas 画布上绘制的左上角（相对于原点）的坐标。<br>（1）beginPath : 开始绘制一个新的形状路径<br>（2）moveTo (x , y)：将笔触移动到指定的 坐标 x 以及 y<br>（3）lineTo (x, y)：绘制一条从当前位置到指定x 以及 y 的直线<br>（4）closePath：结束路径。使用 fill 时就不需要调用它，如果是描边 stroke时，则需要用。<br>（5）stroke：描边。<br>（6）fill：填充。</li>
</ul>
<p>圆弧：<br>API：<br>arc (x, y, radius, startAngle, endAngle, anticlockwise)<br>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</p>
<p>详细参数介绍：<br>x,y 为绘制圆弧所在圆上的圆心坐标。radius 为半径。startAngle 以及 endAngle 参数用弧度定义了开始以及结束的弧度。这些都是以 x 轴为基准。参数 anticlockwise 为一个布尔值。为 true 时，是逆时针方向，否则顺时针方向。</p>
<p>二次贝赛尔曲线 和 三次贝赛尔曲线：<br>用来绘制复杂有规律的曲线。<br>（1）quadraticCurveTo (cp1x, cp1y, x, y)<br>绘制二次贝塞尔曲线，cp1x , cp1y 为一个控制点，x,y 为结束点。</p>
<p>（2）bezierCurveTo (cp1x, cp1y, cp2x, cp2y, x, y)<br>绘制三次贝塞尔曲线，cp1x, cp1y 为控制点一，cp2x, cp2y 为控制点二，x,y 为结束点。</p>
<h5 id="绘画历史记录-path2D"><a href="#绘画历史记录-path2D" class="headerlink" title="绘画历史记录 path2D"></a>绘画历史记录 path2D</h5><p>path2D 对象，可用来缓存或记录绘画命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Path2D();     <span class="comment">// 空的Path对象</span></span><br><span class="line"><span class="keyword">new</span> Path2D(path); <span class="comment">// 克隆Path对象</span></span><br><span class="line"><span class="keyword">new</span> Path2D(d);    <span class="comment">// 从SVG建立Path对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>API :<br>path2D.addPath(path)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.getContext)&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rectangle = <span class="keyword">new</span> Path2D();</span><br><span class="line">    rectangle.rect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> circle = <span class="keyword">new</span> Path2D();</span><br><span class="line">    circle.moveTo(<span class="number">125</span>, <span class="number">35</span>);</span><br><span class="line">    circle.arc(<span class="number">100</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"></span><br><span class="line">    ctx.stroke(rectangle);</span><br><span class="line">    ctx.fill(circle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用样式和颜色"><a href="#使用样式和颜色" class="headerlink" title="使用样式和颜色"></a>使用样式和颜色</h5><ul>
<li>添加色彩：<code>fillStyle</code> 和 <code>strokeStyle</code></li>
</ul>
<p>API:<br>ctx.fillStyle = color色值<br>ctx.strokeStyle = color色值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些 fillStyle 的值均为 &#x27;橙色&#x27;</span></span><br><span class="line">ctx.fillStyle = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;#FFA500&quot;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;rgb(255,165,0)&quot;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;rgba(255,165,0,1)&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>透明度 Transparentcy、rgba<br>属性 <code>globalAlpha</code><br>用法：<br>ctx.globalAlpha = transparentcyValue （0 - 1）<br>ctx.fillStyle = rgba(255,255,255, transparentcyValue （0 - 1）)</li>
</ul>
<h5 id="线-style"><a href="#线-style" class="headerlink" title="线 style"></a>线 style</h5><ul>
<li>lineWidth ： 线条宽度（线条粗细）</li>
<li>lineCap：决定线段 端点 显示的样子（butt round square）butt 默认</li>
<li>lineJoin：图形中两线段连接处所显示的样子（round bevel miter）miter 默认</li>
<li>虚线：<br><code>setLineDash</code>: 用一个数组，指定线段与间隙的交替<br><code>lineDashOffset</code>：设置起始偏移量</li>
</ul>
<p>demo：实现虚线背景选区边框</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  ctx.setLineDash([<span class="number">4</span>, <span class="number">2</span>]);</span><br><span class="line">  ctx.lineDashOffset = -offset;</span><br><span class="line">  ctx.strokeRect(<span class="number">10</span>,<span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">march</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  offset++;</span><br><span class="line">  <span class="keyword">if</span> (offset &gt; <span class="number">16</span>) &#123;</span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  draw();</span><br><span class="line">  <span class="built_in">setTimeout</span>(march, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">march();</span><br></pre></td></tr></table></figure>
<ul>
<li>剪切<br>API： ctx.clip() 利用创建的路径，生成可裁剪区域，并把当前工作区域与裁剪区域绑定。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 橡皮擦功能</span></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.save()</span><br><span class="line">ctx.clip()</span><br><span class="line">ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">ctx.restore()</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="填充或描边的渐变"><a href="#填充或描边的渐变" class="headerlink" title="填充或描边的渐变"></a>填充或描边的渐变</h5><p><code>createLinearGradient</code> 和 <code>createRadialGradient</code> 赋给图形的 fillStyle 或 strokeStyle 属性。 </p>
<ul>
<li><p>createLinearGradient(x1, y1, x2, y2)<br>createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</p>
</li>
<li><p>createRadialGradient(x1, y1, r1, x2, y2, r2)<br>createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</p>
</li>
<li><p>gradient.addColorStop(position, color)<br>addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性黑白渐变</span></span><br><span class="line"><span class="keyword">var</span> lineargradient = ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">lineargradient.addColorStop(<span class="number">0</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">lineargradient.addColorStop(<span class="number">1</span>,<span class="string">&#x27;black&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h5><ul>
<li>createPattern(image, type) ： 循环实现图案的效果。<br>该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onload 确保图案加载好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新 image 对象，用作图案</span></span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.src = <span class="string">&#x27;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&#x27;</span>;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图案</span></span><br><span class="line">    <span class="keyword">var</span> ptrn = ctx.createPattern(img, <span class="string">&#x27;repeat&#x27;</span>);</span><br><span class="line">    ctx.fillStyle = ptrn;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h5><ul>
<li>shadowOffsetX = float<br>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li>
<li>shadowOffsetY = float<br>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li>
<li>shadowBlur = float<br>shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li>
<li>shadowColor = color<br>shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  ctx.shadowOffsetX = <span class="number">2</span>;</span><br><span class="line">  ctx.shadowOffsetY = <span class="number">2</span>;</span><br><span class="line">  ctx.shadowBlur = <span class="number">2</span>;</span><br><span class="line">  ctx.shadowColor = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.font = <span class="string">&quot;20px Times New Roman&quot;</span>;</span><br><span class="line">  ctx.fillStyle = <span class="string">&quot;Black&quot;</span>;</span><br><span class="line">  ctx.fillText(<span class="string">&quot;Sample String&quot;</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h5><ul>
<li>fillText(text, x, y [, maxWidth])<br>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.</li>
<li>strokeText(text, x, y [, maxWidth])<br>在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.font = <span class="string">&quot;48px serif&quot;</span>;</span><br><span class="line">  ctx.fillText(<span class="string">&quot;Hello world&quot;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>canvas 改变 文本样式：</p>
<ul>
<li><p>font = value<br>当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。</p>
</li>
<li><p>textAlign = value<br>文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。</p>
</li>
<li><p>textBaseline = value<br>基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</p>
</li>
<li><p>direction = value<br>文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.font = <span class="string">&quot;48px serif&quot;</span>;</span><br><span class="line">ctx.textBaseline = <span class="string">&quot;hanging&quot;</span>;</span><br><span class="line">ctx.strokeText(<span class="string">&quot;Hello world&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>canvas 获取文本的属性对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> text = ctx.measureText(<span class="string">&quot;foo&quot;</span>); <span class="comment">// TextMetrics object</span></span><br><span class="line">  text.width; <span class="comment">// 16;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h5><p>图片源 可使用 PNG、GIF 或者 JPEG ，甚至是 canvas 生成的图片</p>
<ul>
<li>HTMLImageElement<br>这些图片是由Image()函数构造出来的，或者任何的<img>元素<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();   <span class="comment">// 创建img元素</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 执行drawImage语句</span></span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">&#x27;myImage.png&#x27;</span>; <span class="comment">// 设置图片源地址</span></span><br><span class="line"><span class="comment">// img.src = &#x27;data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==&#x27;;</span></span><br></pre></td></tr></table></figure></li>
<li>HTMLVideoElement<br>用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyVideo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myvideo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>HTMLCanvasElement<br>可以使用另一个 <canvas> 元素作为你的图片源。</li>
<li>ImageBitmap<br>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。</li>
<li>crossOrigin 属性，可请求加载其他域名的图片，而不会污染 canvas</li>
<li>drawImage(image, x, y)： 其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。</li>
<li>缩放 Scaling<br>drawImage(image, x, y, width, height)<br>这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        ctx.drawImage(img,j*<span class="number">50</span>,i*<span class="number">38</span>,<span class="number">50</span>,<span class="number">38</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  img.src = <span class="string">&#x27;https://mdn.mozillademos.org/files/5397/rhino.jpg&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>切片: 类似雪碧图</li>
<li>imageSmoothingEnabled: 制是否在缩放图像时使用平滑算法<br>过度缩放图像可能会导致图像模糊或像素化。开启可能会让合成的图片更清晰。</li>
</ul>
<h5 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h5><ul>
<li>canvas.toDataURL(’image/png‘)<br>默认设定。创建一个PNG图片。<br>Default setting. Creates a PNG image.</li>
<li>canvas.toDataURL(’image/jpeg‘, quality)<br>创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。</li>
<li>canvas.toBlob(callback, type, encoderOptions)<br>这个创建了一个在画布中的代表图片的Blob对像。</li>
</ul>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images" >mdn<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>sql</title>
    <url>/2018/05/02/sql/</url>
    <content><![CDATA[<h4 id="为了新项目的sql存储，我觉得还是很有必要学下sql"><a href="#为了新项目的sql存储，我觉得还是很有必要学下sql" class="headerlink" title="为了新项目的sql存储，我觉得还是很有必要学下sql"></a>为了新项目的sql存储，我觉得还是很有必要学下sql</h4><pre><code>so～～ 开始！

刚开始就报了错，Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO)
用这个命令(登录MYSQL的意思)，mysql -uroot -p
然后重新输一遍密码
</code></pre>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>(1) sql命令必须带;分号，否则提示sql语句错误。
(2) 退出mysql： exit;
(3) MYSQL删除表 语法：drop table &#39;table_name&#39;;
(4) 创建数据库： create database databaseNname;
(5) show databases;  是用来看登陆后的用户有多少关联的数据库
(6) use database&#39;s name; 进入该数据库
(7) show tables; 查看该数据库的表格
(8) desc table&#39;s name; 查看该表的结构
</code></pre>
<h4 id="调试方案（基于mac-os）"><a href="#调试方案（基于mac-os）" class="headerlink" title="调试方案（基于mac os）"></a>调试方案（基于mac os）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="keyword">create</span> database name;</span><br><span class="line">use name;</span><br></pre></td></tr></table></figure>
<pre><code>    之后，可以在命令行 source (将sql文件拖拽进来，去掉file://)
    所以你可以本地写好sql文件，在命令行执行并检验
</code></pre>
<p>(2) 用sequel pro工具来查看sql图形化表格，对照看在命令行写的sql是否起效</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><img src='./package.png' style="width:50%;height:60%;">
参考链接 http://www.runoob.com/mysql/mysql-data-types.html

<h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `movie` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>  AUTO_INCREMENT,</span><br><span class="line">    `movie_name` <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `high_image` <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `content` <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>下面是增删改查，最重要的部分：</p>
<h3 id="增加，批量"><a href="#增加，批量" class="headerlink" title="增加，批量"></a>增加，批量</h3><figure class="highlight sql"><figcaption><span>(结构：INSERT INTO 表名 （要增加的列名）VALUES （对应的值）)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> movie (movie_name,high_image,content) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;头号玩家&#x27;</span>,<span class="string">&#x27;www.baidu.com/a.jpg&#x27;</span>,<span class="string">&#x27;VR高级模拟现实游戏&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;斗破苍穹&#x27;</span>,<span class="string">&#x27;www.baidu.com/b.jpg&#x27;</span>,<span class="string">&#x27;热血国漫&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;仙剑奇侠传&#x27;</span>,<span class="string">&#x27;www.baidu.com/c.jpg&#x27;</span>,<span class="string">&#x27;良心国产仙侠&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件"><a href="#改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件" class="headerlink" title="改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )"></a>改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE movie <span class="keyword">SET</span> high_image<span class="operator">=</span><span class="string">&#x27;www.touhaowanjia.com/1.jpg&#x27;</span> <span class="keyword">WHERE</span> movie_name<span class="operator">=</span><span class="string">&#x27;头号玩家&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删-结构：DELETE-FROM-表名-WHERE-匹配条件"><a href="#删-结构：DELETE-FROM-表名-WHERE-匹配条件" class="headerlink" title="删 (结构：DELETE FROM 表名 WHERE 匹配条件  )"></a>删 (结构：DELETE FROM 表名 WHERE 匹配条件  )</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> movie <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">9</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查-结构：SELECT-列-FROM-表名-WHERE-匹配条件"><a href="#查-结构：SELECT-列-FROM-表名-WHERE-匹配条件" class="headerlink" title="查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )"></a>查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )</h3><p>（1）查询所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> movie;</span><br></pre></td></tr></table></figure>
<p>（2）查询指定列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> content <span class="keyword">FROM</span> movie;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="报错处理："><a href="#报错处理：" class="headerlink" title="报错处理："></a>报错处理：</h3><pre><code>具体就看报错语句，提示在哪里附近报错，第几行，near 什么
</code></pre>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>upload之初探</title>
    <url>/2018/01/04/upload/</url>
    <content><![CDATA[<h4 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h4><blockquote>
<p>产品有做能多选的上传这个功能，开始倒腾。事实也踩了不少坑。现就开始梳理今天的思路。</p>
</blockquote>
<h4 id="框架选取"><a href="#框架选取" class="headerlink" title="框架选取"></a>框架选取</h4><ul>
<li>微信上传接口:<br>先上图 : 我们可以看到的是，它的接口 chooseImage 确是有这番作用。直接把朋友圈发照片的流程给调出来。可以预览，可以原图，很全面了。然而，它需要传到微信服务器走一遭，这是最让人难受的</li>
</ul>
<blockquote>
<p>弃用原因：本身我项目的图片存储是放在阿里云oss里，如今还得再经过微信服务器上传下载，就把这事搞麻烦了…</p>
</blockquote>
<p><img src='/upload/1.png' style="width:50%;height:60%;"><img src='/upload/2.png' style="width:50%;height:60%;"></p>
<ul>
<li>eleme-UI<br>还是先上图：它也是极好的，从UI美观角度看，或是它的功能性，都很接近理想了。可惜，它的上传只有一次，就是它的请求服务器Url只有一个，而且是在vue的html里渲染，这就更不好改了<blockquote>
<p> 弃用原因: 还是因为oss里的判断，有引进了两次请求，第一次是请求 下次请求要用上的地址和id 第二次则是真正和oss请求上传图。</p>
<img src='/upload/3.png' style="width:50%;height:60%;"></blockquote>
</li>
<li>plupload<br>还在研究中…是后台同事推荐的一个插件，据说oss就是官方支持这个，大喜之余就看看它文档。<h4 id="嗯。加油，明天继续倒腾！"><a href="#嗯。加油，明天继续倒腾！" class="headerlink" title="嗯。加油，明天继续倒腾！^_^"></a>嗯。加油，明天继续倒腾！^_^</h4></li>
</ul>
]]></content>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的后花园</title>
    <url>/2019/12/11/webpack/</url>
    <content><![CDATA[<h3 id="1-webpack底层"><a href="#1-webpack底层" class="headerlink" title="1.webpack底层"></a>1.webpack底层</h3><pre><code>它是一个打包工具。
webpack本身，在不借助loader的情况下，只会打包js。

（引用）webpack处理应用程序时，会递归的构建一个依赖关系图，其中包括应用程序需要的每个模块，然后把所有模块打包成一个或多个bundle。
</code></pre>
<h3 id="2-几个核心概念"><a href="#2-几个核心概念" class="headerlink" title="2.几个核心概念"></a>2.几个核心概念</h3><ul>
<li>入口</li>
<li>出口<ul>
<li>入口和出口很好理解，入口就是打包谁，出口就是要输出的文件。<br>entry:<br>output:{ path, filename }</li>
</ul>
</li>
<li>loader<ul>
<li>帮助webpack识别非js文件，包括css，图片等。</li>
<li>示例：<br>  test: 作用等同于正则里面的匹配<br>  use: 使用loader<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">emitWarning</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">emitError</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">failOnError</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [<span class="string">&quot;style-loader&quot;</span>,<span class="string">&quot;css-loader&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">            loader: <span class="string">&#x27;url-loader?limit=8192&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">cssSourceMap</span>:<span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">transformToRequire</span>:&#123;&#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">emitWarning</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">emitError</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">failOnError</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>plugins<br>我还没认真弄懂plugins，它好像有很多好用的功能。比如压缩js或者生成好的静态资源增加版本号。待研究 <em><strong>@todo</strong></em></li>
</ul>
<hr>
<p>常见问题：<br>1、webpack打包原理？<br>2、loader，plugins分别是？<br>3、热更新原理是？<br>4、webpack性能优化的方法？</p>
<hr>
<ul>
<li><p>webpack的打包原理：(树状依赖)</p>
<ul>
<li>利用babel完成代码转换,并生成单个文件的依赖.</li>
<li>从入口开始递归分析，并生成依赖图谱</li>
<li>将各个引用模块打包为一个<code>立即执行</code>函数</li>
<li>将最终的bundle文件写入bundle.js中</li>
</ul>
</li>
<li><p>loader其实就是一个<code>Node.js</code> 模块，这个模块需要导出一个函数</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码分析</title>
    <url>/2020/04/27/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>网址：<br><a class="link"   href="https://jiongks.name/blog/vue-code-review/" >勾三股四<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/HcySunYang/vue-design" >授之以渔<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93" >vue大概讲解<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/answershuto/learnVue" >染陌电子书<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/QH-Jimmy/p/7210363.html" >patch原理<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/aooy/blog/issues/2" >victual dom diff<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.bookstack.cn/books/5865c0921b69e6006b3145a1" >书栈网<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html" >vue中的AST<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>偏函数</title>
    <url>/2020/07/02/%E5%81%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>我的理解是，传入并缓存固定的参数，返回指定的函数。<br>而且是一种特别的柯里化。<br>柯里化是一参变多参。<br>偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。</p>
<p>参考：<br><a class="link"   href="https://blog.csdn.net/qq_15241071/article/details/80036346" >blog<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆对象&amp;&amp;数组（一）</title>
    <url>/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="1-从数据类型说起"><a href="#1-从数据类型说起" class="headerlink" title="1 从数据类型说起"></a>1 从数据类型说起</h4><p><code>JavaScript</code>的数据类型：</p>
<ul>
<li>基本类型： <code>Null，undefined，number，string，Boolean</code> 存放在<code>栈内存</code>的简单数据，可以直接访问</li>
<li>引用类型：<code>Array，Object，Function</code> 存放在<code>堆内存</code>，存放的是该对象的<code>地址指针</code></li>
</ul>
<h4 id="2-深浅拷贝由来"><a href="#2-深浅拷贝由来" class="headerlink" title="2 深浅拷贝由来"></a>2 深浅拷贝由来</h4><p>引用类型的数据，因为指向指针的问题，<code>浅拷贝</code>就会导致指向同一处，那么修改拷贝的任一者，都会<code>导致全部都改</code>了。<br>这时候，就需要<code>深拷贝</code>，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就<code>不会互相影响</code>了。</p>
<h4 id="3-浅拷贝"><a href="#3-浅拷贝" class="headerlink" title="3 浅拷贝"></a>3 浅拷贝</h4><p><code>浅拷贝</code>就是拷贝<code>第一层的基本类型值</code>，以及<code>第一层的引用类型地址</code>。<br>（1）for…in…遍历属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">copyObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> copyObj) &#123;</span><br><span class="line">    obj[i] = copyObj[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">c</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = shallowClone(x);</span><br><span class="line"><span class="built_in">console</span>.log(y.b.f === x.b.f);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>（2）Object.assign()<br>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层<br>基础用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<p>复制对象（浅）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>(3) <code>Array</code>的<code>slice &amp; concat</code>方法<br>它们虽然在 demo 里看起来像深，其实也是浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">var</span> array_shallow = array; </span><br><span class="line"><span class="keyword">var</span> array_concat = array.concat(); </span><br><span class="line"><span class="keyword">var</span> array_slice = array.slice(<span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(array === array_shallow); <span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(array === array_slice); <span class="comment">//false，“看起来”像深拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(array === array_concat); <span class="comment">//false，“看起来”像深拷贝</span></span><br></pre></td></tr></table></figure>

<p>(4) 展开语法<code>...</code><br>对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1 = [...arr2, ...arr1]; <span class="comment">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS 拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆对象&amp;&amp;数组（二）</title>
    <url>/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h4 id="4-深拷贝"><a href="#4-深拷贝" class="headerlink" title="4. 深拷贝"></a>4. 深拷贝</h4><p><code>深拷贝 = 浅拷贝 + 遇到对象时递归拷贝</code><br>（1）最简单莫过于字符序列化，再parse反序列化<br>语法：JSON.parse(JSON.stringify) </p>
<div class="tip">
后端传回的变量一般用它来拷贝足以应对。只是，
1、会忽略 undefined
                      
<p>2、会忽略 symbol</p>
<p>3、不能序列化函数</p>
<p>4、不能解决循环引用的对象</p>
<p>5、不能正确处理new Date()</p>
<p>6、不能处理正则</p>
<p>undefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// undefined symbol 函数示例</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;muyiy&#x27;</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">Symbol</span>(<span class="string">&#x27;muyiy&#x27;</span>),</span><br><span class="line">    <span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: &quot;muyiy&quot;, </span></span><br><span class="line"><span class="comment">// 	a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">   		<span class="attr">d</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = obj.b;</span><br><span class="line">obj.b.c = obj.a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new Date转化结果不正确 结果方案是转为时间戳</span></span><br><span class="line"><span class="keyword">let</span> date = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</span><br><span class="line"><span class="built_in">JSON</span>.stringify(date); </span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(date)); <span class="comment">// 和上面的输出是同一个值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="regexp">/&#x27;123&#x27;/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;, a: /&#x27;123&#x27;/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;name: &quot;muyiy&quot;, a: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>(2) 简易深拷贝</p>
<p>第一版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个虽然能简单实现 却有以下问题</span></span><br><span class="line"><span class="comment">// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 &#123;&#125;</span></span><br><span class="line"><span class="comment">// 2、对于对象的判断逻辑不严谨，因为 typeof null === &#x27;object&#x27;</span></span><br><span class="line"><span class="comment">// 3、没有考虑数组的兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里 如果是对象的时候递归调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二版 （非对象的返回自身以及数组的支持）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;<span class="comment">// 非对象返回自身</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep2</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; <span class="comment">// 非对象返回自身</span></span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;; <span class="comment">// 初始值为空数组或空对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepclone</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123; <span class="comment">// clear easy know version</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        target = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnPorperty(key)) &#123;</span><br><span class="line">            target[key] = deepclone(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep2(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>第三版 （支持对象循环引用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); <span class="comment">// 新增代码，查哈希表</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target); <span class="comment">// 新增代码，哈希表设值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep3(source[key], hash); <span class="comment">// 新增代码，传入哈希表</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">        <span class="attr">a1</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">a2</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">a3</span>: <span class="number">123</span>,</span><br><span class="line">        <span class="attr">book</span>: &#123;<span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;45&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    a.circleRef = a <span class="comment">// circleRef是个很奇特的属性，它能在自身存自己，并永久循环，</span></span><br><span class="line">    <span class="keyword">var</span> b = cloneDeep3(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>

<p>第四版 （保存引用关系）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组版</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, uniqueList</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source</span><br><span class="line">     <span class="keyword">if</span> (!uniqueList) uniqueList = []</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> uniqueData = find(uniqueList, source)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target</span></span><br><span class="line">     <span class="keyword">if</span>(uniqueData) &#123;</span><br><span class="line">         <span class="keyword">return</span> uniqueData.target</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 数据不存在，保存源数据，以及对应的引用</span></span><br><span class="line">     uniqueList.push(&#123; <span class="comment">// 用数组存储键值对</span></span><br><span class="line">         <span class="attr">source</span>: source,</span><br><span class="line">         <span class="attr">target</span>: target</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source,key)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                 target[key] = cloneDeep3(source[key], uniqueList)</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 target[key] = source[key]</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> target <span class="comment">// target很值得玩味，递归完了后的callStack让人惊奇</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> obj2 = &#123;<span class="attr">a</span>: obj1, <span class="attr">b</span>: obj1&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj2.a === obj2.b);</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj3 = cloneDeep3(obj2);</span><br><span class="line"> <span class="built_in">console</span>.log(obj3.a === obj3.b)</span><br><span class="line"> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第五版 （拷贝Symbol类型）<br>思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep4</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============= 新增代码</span></span><br><span class="line">    <span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找 </span></span><br><span class="line">    <span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功	</span></span><br><span class="line">        symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">                target[symKey] = cloneDeep4(source[symKey], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[symKey] = source[symKey];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep4(source[key], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 可以看到成功拷贝了Symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 创建新的symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;b&quot;</span>); <span class="comment">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class="line"></span><br><span class="line">a[sym1] = <span class="string">&quot;localSymbol&quot;</span>;</span><br><span class="line">a[sym2] = <span class="string">&quot;globalSymbol&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep4(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// 	a1: undefined,</span></span><br><span class="line"><span class="comment">//	a2: null,</span></span><br><span class="line"><span class="comment">// 	a3: 123,</span></span><br><span class="line"><span class="comment">// 	book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;,</span></span><br><span class="line"><span class="comment">// 	circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span></span><br><span class="line"><span class="comment">//  [Symbol(a)]: &#x27;localSymbol&#x27;,</span></span><br><span class="line"><span class="comment">//  [Symbol(b)]: &#x27;globalSymbol&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>


<p>第六版 破解递归爆栈 (待研究@todo)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep5</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">parent</span>: root,</span><br><span class="line">            <span class="attr">key</span>: <span class="literal">undefined</span>,</span><br><span class="line">            <span class="attr">data</span>: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="comment">// 广度优先</span></span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        <span class="attr">parent</span>: res,</span><br><span class="line">                        <span class="attr">key</span>: k,</span><br><span class="line">                        <span class="attr">data</span>: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="小语法："><a href="#小语法：" class="headerlink" title="小语法："></a>小语法：</h4><p>1 Object.keys(..) 返回一个数组，包含所有可枚举属性<br>2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举<br>3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述<br>4 in &amp;&amp; hasOwnProperty</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个关联到 anotherObject 的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">myObject.b = <span class="number">2</span>;</span><br><span class="line">(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;a&quot;</span> ); <span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;b&quot;</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。</span></span><br><span class="line"><span class="comment">// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。</span></span><br></pre></td></tr></table></figure>
<p>5 WeakMap<br>特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">      wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">      wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;,</span><br><span class="line">      o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">      o3 = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">wm1.set(o1, <span class="number">37</span>);</span><br><span class="line">wm1.set(o2, <span class="string">&quot;azerty&quot;</span>);</span><br><span class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象或一个函数</span></span><br><span class="line">wm2.set(o3, <span class="literal">undefined</span>);</span><br><span class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class="line"></span><br><span class="line">wm1.get(o2); <span class="comment">// &quot;azerty&quot;</span></span><br><span class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></span><br><span class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></span><br><span class="line"></span><br><span class="line">wm1.has(o2); <span class="comment">// true</span></span><br><span class="line">wm2.has(o2); <span class="comment">// false</span></span><br><span class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></span><br><span class="line"></span><br><span class="line">wm3.set(o1, <span class="number">37</span>);</span><br><span class="line">wm3.get(o1); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line">wm1.has(o1);   <span class="comment">// true</span></span><br><span class="line">wm1.delete(o1);</span><br><span class="line">wm1.has(o1);   <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考<br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" >MDN Object.assign<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/wengjq/Blog/issues/3" >wengjq issue<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/yygmind/blog/issues/25" >yygmind issue<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86" >yygmind 深浅拷贝汇总<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" >展开语法<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" >MDN Object.getOwnPropertyDescription<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" >MDN WeakMap<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.codenong.com/29413222/" >神奇的weakmap科普贴<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://segmentfault.com/a/1190000016672263" >颜海镜<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS 拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2020/05/27/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h3><p>柯里化是一种将使用<code>多个参数</code>的一个函数<code>转换成</code>一系列使用<code>一个参数</code>的函数的编程技术。<br>简单示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个 curry 函数可以做到柯里化</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add);</span><br><span class="line"></span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 调用跟 add (1，2)是一样的</span></span><br></pre></td></tr></table></figure>

<h3 id="2-curry函数的编写"><a href="#2-curry函数的编写" class="headerlink" title="2. curry函数的编写"></a>2. curry函数的编写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@feature </span>普通curry函数的编写</span></span><br><span class="line"><span class="comment"> arguments 对象是内部函数的。</span></span><br><span class="line"><span class="comment"> 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。</span></span><br><span class="line"><span class="comment"> arguments会视为每次传的参数而定</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = fn.length;</span><br><span class="line">    args = args || []; <span class="comment">// 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = args.slice(<span class="number">0</span>),</span><br><span class="line">            arg, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">            _args.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; length) &#123; <span class="comment">// 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面四种都会得出这样的结果： [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前返回的例子</span></span><br><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn, capture</span>) </span>&#123; <span class="comment">// 提前返回</span></span><br><span class="line">            el.addEventListener(type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123; <span class="comment">// 提前返回</span></span><br><span class="line">            el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="3-curry函数写法的引申思考"><a href="#3-curry函数写法的引申思考" class="headerlink" title="3. curry函数写法的引申思考"></a>3. curry函数写法的引申思考</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简易版，理解 fn1 中 return fn2的执行</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> k = testFn()</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="comment">// k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue 识别html标签的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params">tagStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tagArr = tagStr.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> tagObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> tag <span class="keyword">of</span> tagArr) &#123;</span><br><span class="line">    tagObj[tag] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tagName</span>) </span>&#123; <span class="comment">// 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗</span></span><br><span class="line">    <span class="keyword">return</span> !!tagObj[tagName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isHTMLTag = makeMap(<span class="string">&#x27;div,p,span,h1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isHTMLTag(<span class="string">&#x27;div&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-curry函数的特点与作用"><a href="#4-curry函数的特点与作用" class="headerlink" title="4. curry函数的特点与作用"></a>4. curry函数的特点与作用</h3><ul>
<li>参数复用，提前固定参数</li>
<li>提前返回</li>
</ul>
<hr>
<p>参考文章：<br><a class="link"   href="https://zh.javascript.info/currying-partials" >javascript.Info<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/mqyqingfeng/Blog/issues/42" >冴羽github文章<i class="fas fa-external-link-alt"></i></a><br><a href="https://my.oschina.net/u/4400687/blog/3660259"><code>arguments</code>和<code>function.length</code>的区别</a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" >Function.length<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/YvetteLau/Step-By-Step/issues/24" >github闭包论坛<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>判断对象是否是个空对象</title>
    <url>/2020/07/27/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</url>
    <content><![CDATA[<h4 id="1-遍历，根据是否有值"><a href="#1-遍历，根据是否有值" class="headerlink" title="1. 遍历，根据是否有值"></a>1. 遍历，根据是否有值</h4><p><code>for...in...</code></p>
<h4 id="2-整个对象转换为数组"><a href="#2-整个对象转换为数组" class="headerlink" title="2. 整个对象转换为数组"></a>2. 整个对象转换为数组</h4><p><code>Object.entries </code></p>
<h4 id="3-转为JSON字符串"><a href="#3-转为JSON字符串" class="headerlink" title="3. 转为JSON字符串"></a>3. 转为JSON字符串</h4><p><code>JSON.stringify()</code></p>
<h4 id="4-获取对象的属性名并以数组形式返回"><a href="#4-获取对象的属性名并以数组形式返回" class="headerlink" title="4. 获取对象的属性名并以数组形式返回"></a>4. 获取对象的属性名并以数组形式返回</h4><p><code>Object.getOwnPropertyNames()</code> / <code>Object.keys()</code></p>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...in...</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   isEmpty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key的遍历 ： Object.getOwnPropertyNames</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key的遍历： Object.keys 获取key的数组</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty = <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象转化为数组的遍历： Object.entries</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty;</span><br><span class="line">isEmpty = (<span class="built_in">Object</span>.entries(obj).length === <span class="number">0</span>) &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON字符串</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty;</span><br><span class="line">isEmpty = <span class="built_in">JSON</span>.stringify(obj) === <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>合并对象</title>
    <url>/2020/07/27/%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>1 <code>Object.assign</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:[<span class="number">1</span>], <span class="attr">b</span>:[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="attr">c</span>:<span class="number">5</span> , <span class="attr">d</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(obj1,obj2))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>…运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:[<span class="number">1</span>], <span class="attr">b</span>:[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="attr">c</span>:<span class="number">5</span> , <span class="attr">d</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(&#123;...obj1, ...obj2&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JS</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>复制内容</title>
    <url>/2019/03/02/%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h6 id="常用场景："><a href="#常用场景：" class="headerlink" title="常用场景："></a>常用场景：</h6><p>有时候需要复制内容，比如复制链接，需要用js实现，那么，可以这么解决</p>
<h6 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h6><p>利用input的<code>选择属性</code>，获取input的值，选择它，并且执行<code>document.execCommand(&quot;Copy&quot;)</code> 。而且因为往往值是隐藏的，所以这个input也是不外露的。</p>
<h6 id="上些代码："><a href="#上些代码：" class="headerlink" title="上些代码："></a>上些代码：</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inviteHideInput&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 1px;width: 1px;&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这是隐藏的input --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;复制邀请函链接&quot;</span> <span class="attr">class</span>=<span class="string">&quot;copyInviteUrl&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 这是触发的Dom --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.copyInviteUrl&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> eid = getQueryString(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> newUrl = location.host + <span class="string">&#x27;/invitation?eid=&#x27;</span> + eid;</span><br><span class="line">        $(<span class="string">&#x27;#inviteHideInput&#x27;</span>).attr(<span class="string">&#x27;value&#x27;</span>, newUrl);</span><br><span class="line">        $(<span class="string">&#x27;#inviteHideInput&#x27;</span>).select();</span><br><span class="line">        <span class="built_in">document</span>.execCommand(<span class="string">&quot;Copy&quot;</span>); <span class="comment">// 执行浏览器复制命令</span></span><br><span class="line">        PopupMessage(<span class="number">0</span>, <span class="string">&quot;已复制，您可以使用Ctrl+V粘贴。&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>合成图片</title>
    <url>/2019/02/15/%E5%90%88%E6%88%90%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><pre><code>H5的分享海报，需要从后台获取数据，绘制DOM，并且可以长按保存。也就是要求所有DOM都要转为image元素。
</code></pre>
<h6 id="需要引用的库"><a href="#需要引用的库" class="headerlink" title="需要引用的库"></a>需要引用的库</h6><pre><code>html2Canvas: Screenshots with JavaScript 等于是用js去转换指定的DOM成为image。
</code></pre>
<h6 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h6><pre><code>html2Canvas执行渲染时 ，需等待DOM本身获取后台数据的渲染完成。否则会出现黑背景
</code></pre>
<h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 关键在这里，延时进行html2Canvas操作</span></span><br><span class="line">        drawCanvas(<span class="string">&#x27;#sharePoster_bg_img&#x27;</span>).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">            img.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">            <span class="comment">// 将 canvas 导出成 base64</span></span><br><span class="line">            img.src = canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.92</span>);</span><br><span class="line">            img.crossOrigin = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">            <span class="comment">// 添加图片到预览</span></span><br><span class="line">            $(<span class="string">&#x27;#sharePoster_bg_img&#x27;</span>).html(img); <span class="comment">// 生成的base64图片填充到dom里</span></span><br><span class="line">            $(<span class="string">&#x27;.save_text&#x27;</span>).show();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="优化细节-以及-要用到的工具函数"><a href="#优化细节-以及-要用到的工具函数" class="headerlink" title="优化细节 以及 要用到的工具函数"></a>优化细节 以及 要用到的工具函数</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据像素比绘制canvas，使生成图片更加高清。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">DomSelector</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns <span class="variable">html2Canvas</span></span></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">drawCanvas</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取想要转换的 DOM 节点</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">    <span class="keyword">const</span> box = <span class="built_in">window</span>.getComputedStyle(dom);</span><br><span class="line">    <span class="comment">// DOM 节点计算后宽高</span></span><br><span class="line">    <span class="keyword">const</span> width = parseValue(box.width);</span><br><span class="line">    <span class="keyword">const</span> height = parseValue(box.height);</span><br><span class="line">    <span class="comment">// 获取像素比</span></span><br><span class="line">    <span class="keyword">const</span> scaleBy = DPR();</span><br><span class="line">    <span class="comment">// 创建自定义 canvas 元素</span></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比</span></span><br><span class="line">    canvas.width = width * scaleBy;</span><br><span class="line">    canvas.height = height * scaleBy;</span><br><span class="line">    <span class="comment">// 设定 canvas css宽高为 DOM 节点宽高</span></span><br><span class="line">    canvas.style.width = <span class="string">`<span class="subst">$&#123;width&#125;</span>px`</span>;</span><br><span class="line">    canvas.style.height = <span class="string">`<span class="subst">$&#123;height&#125;</span>px`</span>;</span><br><span class="line">    <span class="comment">// 获取画笔</span></span><br><span class="line">    <span class="keyword">const</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有绘制内容放大像素比倍 </span></span><br><span class="line">    context.scale(scaleBy, scaleBy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自定义 canvas 作为配置项传入，开始绘制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> html2canvas(dom, &#123;canvas,</span><br><span class="line">        <span class="attr">allowTaint</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">useCORS</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">async</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">width</span>: width,</span><br><span class="line">        <span class="attr">height</span>: height</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据window.devicePixelRatio获取像素比</span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns </span>像素比</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DPR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio &amp;&amp; <span class="built_in">window</span>.devicePixelRatio &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  将传入值转为整数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="注意细节："><a href="#注意细节：" class="headerlink" title="注意细节："></a>注意细节：</h6><pre><code>需绘制的DOM所用到的css属性值最好不用最新的属性，html2Canvas不支持最新的css属性解析，会造成生成的图片有黑色背景。
</code></pre>
<h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p>   <a class="link"   href="https://html2canvas.hertzen.com/" >html2Canvas官网<i class="fas fa-external-link-alt"></i></a><br>   <a class="link"   href="http://cdn.huodongxing.com/Content/v2.0/plugin/html2canvas/html2canvas.min.js" >js资源<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重</title>
    <url>/2019/02/25/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<blockquote>
<p>我们时常遇见数组去重的需求，或是后台给的数据重了，或是前端生成数据的时候重了，这时候往往需要处理下，那下面我归纳下各种解决方案吧🧐：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先给出几组测试数组</span></span><br><span class="line"><span class="keyword">let</span> includeObjArr = [ <span class="comment">// 待检测数组（含对象）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wang&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wang&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zhong&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zhong&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> includeNumArr =  [<span class="number">3</span>, <span class="number">62</span>, <span class="number">3</span>, <span class="number">38</span>, <span class="number">20</span>, <span class="number">42</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">38</span>, <span class="number">29</span>, <span class="number">42</span>]; <span class="comment">// 只含数字的简单数组</span></span><br></pre></td></tr></table></figure>

<h3 id="1-利用ES6的API-Set和-Array"><a href="#1-利用ES6的API-Set和-Array" class="headerlink" title="1. 利用ES6的API Set和 Array"></a>1. 利用ES6的API Set和 Array</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* es6 api的解决方案</span></span><br><span class="line"><span class="comment">* @param targetArr</span></span><br><span class="line"><span class="comment">* @returns &#123;any[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArray</span>(<span class="params">targetArr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(targetArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="结论：只能用于包含简单数字的数组去重"><a href="#结论：只能用于包含简单数字的数组去重" class="headerlink" title="结论：只能用于包含简单数字的数组去重"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id="2-利用array-splice"><a href="#2-利用array-splice" class="headerlink" title="2. 利用array.splice"></a>2. 利用array.splice</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* es6 api的解决方案</span></span><br><span class="line"><span class="comment">* @param arr</span></span><br><span class="line"><span class="comment">* @returns &#123;any[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArray</span>(<span class="params">arr</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(arr[j] === arr[i])&#123; </span><br><span class="line">                arr.splice(j--, <span class="number">1</span>); </span><br><span class="line">                &#125; </span><br><span class="line">              &#125; </span><br><span class="line">            &#125; </span><br><span class="line">          <span class="keyword">return</span> arr;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<h6 id="结论：只能用于包含简单数字的数组去重-1"><a href="#结论：只能用于包含简单数字的数组去重-1" class="headerlink" title="结论：只能用于包含简单数字的数组去重"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id="3-利用哈希表"><a href="#3-利用哈希表" class="headerlink" title="3. 利用哈希表"></a>3. 利用哈希表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对象存储的是引用而原始变量存储的是值。</span></span><br><span class="line"><span class="comment">* 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和&#x27;1&#x27;。</span></span><br><span class="line"><span class="comment">* 然而，因为我们使用的JSON.stringify，String类型的key 将会被存储为一个字符串值，这样hashTable的key就唯一了。</span></span><br><span class="line"><span class="comment">* 这意味着相同的值，但不同类型的元素，将以原来的格式保留。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedup</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> hashTable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(el);</span><br><span class="line">		<span class="keyword">var</span> match = <span class="built_in">Boolean</span>(hashTable[key]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (match ? <span class="literal">false</span> : hashTable[key] = <span class="literal">true</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="结论：可用于包含复杂类型的数组去重"><a href="#结论：可用于包含复杂类型的数组去重" class="headerlink" title="结论：可用于包含复杂类型的数组去重"></a>结论：可用于包含复杂类型的数组去重</h6><hr>
<h3 id="4-利用对象中key的唯一"><a href="#4-利用对象中key的唯一" class="headerlink" title="4. 利用对象中key的唯一"></a>4. 利用对象中key的唯一</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> tmpKey;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        tmpKey = <span class="keyword">typeof</span> arr[i] + <span class="built_in">JSON</span>.stringify(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(!tmp[tmpKey])&#123;</span><br><span class="line">            tmp[tmpKey] = <span class="number">1</span>;</span><br><span class="line">            ret.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="结论：可用于包含复杂类型的数组去重-1"><a href="#结论：可用于包含复杂类型的数组去重-1" class="headerlink" title="结论：可用于包含复杂类型的数组去重"></a>结论：可用于包含复杂类型的数组去重</h6><h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p><a class="link"   href="http://www.jstips.co/zh_cn/javascript/deduplicate-an-array/" >jstips<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/lifesinger/blog/issues/113" >blog<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/hanzichi/underscore-analysis/issues/9" >blog<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器-输入url系列</title>
    <url>/2020/03/13/%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%BE%93%E5%85%A5url%E6%93%8D%E4%BD%9C%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>共是五个步骤</p>
</blockquote>
<h3 id="1-浏览器的搜索框"><a href="#1-浏览器的搜索框" class="headerlink" title="1 浏览器的搜索框"></a>1 浏览器的搜索框</h3><p>浏览器会根据输入的内容，去匹配是用对应的引擎搜索内容，还是直接跳转url。<br>详细的讲，就是</p>
<ul>
<li>搜索内容+默认搜索引擎，形成新的URL</li>
<li>符合URL规则的话，在输入内容基础上加上协议，形成新的URL</li>
</ul>
<h3 id="2-dns解析"><a href="#2-dns解析" class="headerlink" title="2 dns解析"></a>2 dns解析</h3><ul>
<li>自己的理解：路由解析，找到背后的ip地址，路由缓存，域名缓存，为什么第二次加载会更快，跟这个有关。</li>
<li>dns：一个域名与ip地址相互映射的分布式数据库</li>
<li>我们无法记住的ip，那一个个长相平凡但是堆积在一起就是记不住的几个数字，是的，dns帮我们记住了。他以电话簿的形式，记住了许许多多的ip地址，映射到了所有网站上。</li>
<li>在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</li>
<li>本地dns服务器找不到的时候，去查询其他根dns服务器，顶级域服务器，权威dns服务器</li>
<li>查找的过程是有优化的地方：<ul>
<li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 </li>
<li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li>
<li>补充：域名与ip之间有映射关系，但是大多数情况下却不是一一对应的，我们可以将多个ip映射到同一个域名，因为用户是通过域名去进行访问的，具体访问哪个地址，则有DNS服务器的映射记录和一定的负载均衡算法来决定，用户拿到具体ip后再去访问，而这个过程对用户来说完全是透明的，通过DNS分流完成了第一步的负载均衡：</li>
</ul>
</li>
</ul>
<h3 id="3-Https，ssl协议，Tcp建立连接"><a href="#3-Https，ssl协议，Tcp建立连接" class="headerlink" title="3 Https，ssl协议，Tcp建立连接"></a>3 Https，ssl协议，Tcp建立连接</h3><p>浏览器通过http/https协议，建立tcp连接，三次握手建立请求，传输连接建立完毕。</p>
<h3 id="4-服务器处理请求，返回结果"><a href="#4-服务器处理请求，返回结果" class="headerlink" title="4 服务器处理请求，返回结果"></a>4 服务器处理请求，返回结果</h3><p>服务器，解析请求头，对比是否过期字段，缓存字段，返回对应的状态码和内容。返回所有内容后，可以关闭连接了亲。</p>
<h3 id="5-浏览器解析-渲染"><a href="#5-浏览器解析-渲染" class="headerlink" title="5 浏览器解析/渲染"></a>5 浏览器解析/渲染</h3><p>dom树解析，转换css单位成通用单位，cssdom解析，绘制。优先视口。</p>
<ul>
<li>构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示<ul>
<li>构建DOM树：html内容解析成DOM树（这里面用到HTML的parser）</li>
<li>css样式表，转为浏览器可以读懂的CSS规则树</li>
<li>由DOM树和CSS规则树结合，隐藏不可见元素，创建render树，计算布局信息，包括所有元素的尺寸、位置、还有position、z-index、overflow</li>
<li>Painting: 绘制render树，绘制页面像素（这里就属于重绘了）</li>
<li>GPU绘制，显示到显示屏</li>
</ul>
</li>
</ul>
<p>小知识点：</p>
<ul>
<li><p>绘制 render 树的流程：</p>
<ul>
<li>从 DOM 树遍历可见节点</li>
<li>对于每个可见节点，找到 CSSOM 树对应的节点样式规则，应用上</li>
<li>组合生成 render 树</li>
</ul>
</li>
<li><p>HTML的parser：</p>
<ul>
<li>转换：HTML编码成字符</li>
<li>分词：给字符们打上标记Tokens</li>
<li>词法：tokens转换成包含属性和规则的对象</li>
<li>DOM树创建</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a class="link"   href="https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A" >文章<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000012196642" >https<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/26682342" >https<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/weixin_34050389/article/details/93027673" >负载均衡<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since" >If-Unmodified-Since<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since" >If-Modified-Since<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires" >Expires<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" >Cache-Control<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649825731&idx=1&sn=2c0835cebfee3a44e82d9efeb54f6e43&chksm=f175eb00c602621649fd46d7c9de87f7f08a4cdaa9e08808b938948584ca6977e24a5f5336ce&scene=21#wechat_redirect" >浏览器相关<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000013662126" >全面<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000012925872" >浏览器进程/线程<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端</title>
    <url>/2018/11/03/%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    <content><![CDATA[<h4 id="如何编写移动端😎-？话不多说，即刻带大家进入今天主题"><a href="#如何编写移动端😎-？话不多说，即刻带大家进入今天主题" class="headerlink" title="如何编写移动端😎 ？话不多说，即刻带大家进入今天主题"></a>如何编写移动端😎 ？话不多说，即刻带大家进入今天主题</h4><ul>
<li>如我们常规所见，移动端和PC端的最大差异就是：设备的分辨率。</li>
<li>移动端：下面是一段默认加载在头部的设置<code>html标签的fontSize</code>的js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">pageWidth= <span class="number">750</span></span>) </span>&#123; <span class="comment">// 设计稿可以传参，普遍是750</span></span><br><span class="line">    !(<span class="function"><span class="keyword">function</span>(<span class="params">win, doc</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 获取设备 宽度</span></span><br><span class="line">            <span class="keyword">var</span> winWidth =  <span class="built_in">window</span>.innerWidth;</span><br><span class="line">            <span class="keyword">var</span> size = (winWidth / pageWidth) * <span class="number">100</span>;</span><br><span class="line">            doc.documentElement.style.fontSize = size + <span class="string">&#x27;px&#x27;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> evt = <span class="string">&#x27;onorientationchange&#x27;</span> <span class="keyword">in</span> win ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        win.addEventListener(evt, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(setFontSize, <span class="number">300</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        win.addEventListener(<span class="string">&quot;pageshow&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(setFontSize, <span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        setFontSize();</span><br><span class="line"></span><br><span class="line">    &#125;(<span class="built_in">window</span>, <span class="built_in">document</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态的获取设备独立像素，然后除以设计稿的宽度(常规UI是输出750宽度)，要乘100，然后赋给根字体的<code>fontsize</code>，以致做到自适应，来动态改变根字体大小。这里拿到是百分比 。</li>
<li>为什么要乘100，首先假设说设备分辨率是375，375 / 750是0.5，0.5我们称为<code>比例R</code>.而浏览器默认最小字体为12px。 这时我们的0.5就会被12重置了。所以我们需要放大一些，而100又很好算。在此，就把浏览器默认字号设置为100px，刚才获取的0.5是比例。那么相乘后获得的50px，就是自适应后的html根字体大小。</li>
<li>为了适配移动端，把单位转换成rem。  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    font-size: 16px; <span class="comment">// 会使rem不跟随错误的12px或者10px （比如设置62.5%时，就会`bodysize`是10px，那样em和rem都会算错。）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>那么1rem 等于（2）步骤返回的html 根字体大小。但这时候问题来了，设计稿输出的是750宽的图纸，而且是px，那么中间该怎么转化？？？比如说1rem 等于50px 那我现在的banner图是690px高，我应该是输出一个690/50 = result(rem)<br>借助<code>sass函数</code>，输入值为690px，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="function"><span class="keyword">function</span> <span class="title">pxTorem</span>(<span class="params">$px</span>)</span>&#123;<span class="comment">//$px为需要转换的字号</span></span><br><span class="line">    @<span class="keyword">return</span> $px / $browser-<span class="keyword">default</span>-font-size * 1rem; <span class="comment">// 其实这里可以理解为 $px * （1rem/ 100）,也就是banner图的高度 * （比例R），从而获得它在这个该设备应该有的大小。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
所以在我们平时写css的时候，可以这么写样式了<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.city-li&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  height: pxTorem(56px);</span><br><span class="line">  line-height: pxTorem(56px);</span><br><span class="line">  padding-left: pxTorem(10px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在可以书写移动端样式后。继续探讨：第二差异是网络环境。网络加载速度不一致是移动端的瓶颈，所以代码量的大小和质量是移动端性能优化的关键。</li>
</ul>
]]></content>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端拖拽</title>
    <url>/2019/02/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<blockquote>
<p>今天聊一下移动端的拖拽，上周一个拖动的需求，正好整理下</p>
</blockquote>
<h6 id="场景是这样的"><a href="#场景是这样的" class="headerlink" title="场景是这样的"></a>场景是这样的</h6><pre><code>需要在H5邀请函里做名字栏位的拖拽，并且要能记住它的位置以便于图片合成。
</code></pre>
<h6 id="用到的技术"><a href="#用到的技术" class="headerlink" title="用到的技术"></a>用到的技术</h6><pre><code>它们都属于原生JS - 移动端监听拖拽的API。
</code></pre>
<ul>
<li><code>touchStart</code> ：<strong>开始触摸</strong>屏幕时就触发</li>
<li><code>touchmove</code>：在屏幕上<strong>滑动</strong>时触发</li>
<li><code>touchend</code>:  <strong>屏幕上离开</strong>的时触发　　 </li>
</ul>
<ul>
<li>其中<em>touchStart</em>和<em>touchmove</em>会提供<em>touch</em>对象,包含</li>
</ul>
<ul>
<li>pageX：触摸目标在页面中的x坐标。</li>
<li>pageY：触摸目标在页面中的y坐标。<br>这次只用了这两个参数<h6 id="还是上点代码吧"><a href="#还是上点代码吧" class="headerlink" title="还是上点代码吧"></a>还是上点代码吧</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragStart</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    isdrag = <span class="literal">true</span>;</span><br><span class="line">    tempX = <span class="built_in">parseInt</span>($(<span class="string">&#x27;.guest_name&#x27;</span>).css(<span class="string">&#x27;left&#x27;</span>) + <span class="number">0</span>);</span><br><span class="line">    tempY = <span class="built_in">parseInt</span>($(<span class="string">&#x27;.guest_name&#x27;</span>).css(<span class="string">&#x27;top&#x27;</span>) + <span class="number">0</span>);</span><br><span class="line">    x = e.touches[<span class="number">0</span>].pageX;</span><br><span class="line">    y = e.touches[<span class="number">0</span>].pageY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isdrag) &#123; <span class="comment">// 这里 e.touches[0].pageY中的pageY</span></span><br><span class="line">        <span class="keyword">let</span> curX = tempX + e.touches[<span class="number">0</span>].pageX - x;</span><br><span class="line">        <span class="keyword">let</span> curY = tempY + e.touches[<span class="number">0</span>].pageY - y;</span><br><span class="line">        <span class="comment">// 边界判断</span></span><br><span class="line">        <span class="comment">// curX = curX &lt; 0 ? 0 : curX;</span></span><br><span class="line">        curY = curY &lt; <span class="number">0</span> ? <span class="number">0</span> : curY;</span><br><span class="line">        curX = curX &lt; <span class="built_in">document</span>.documentElement.clientWidth - <span class="number">80</span> ? curX : <span class="built_in">document</span>.documentElement.clientWidth - <span class="number">80</span>;</span><br><span class="line">        curY = curY &lt; $(<span class="string">&#x27;.firstPageBackground&#x27;</span>).height() - <span class="number">25</span> ? curY : $(<span class="string">&#x27;.firstPageBackground&#x27;</span>).height() - <span class="number">25</span>; <span class="comment">// 这里的高度限制 $(&#x27;.firstPageBackground&#x27;).height() - 25 是来源于业务上，邀请函画布的高度，控制名字不能超出限制。25是名字本身的高度。都以px为单位。</span></span><br><span class="line">        $(<span class="string">&#x27;.guest_name&#x27;</span>).css(&#123;</span><br><span class="line">            <span class="string">&#x27;left&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;top&#x27;</span>: curY</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 禁止浏览器默认事件</span></span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    isdrag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6>好啦，还是别卖关子了，其实原理就是，利用了两次监听移动提供的pageX和pageY 之差。将差值加到原来的绝对定位，left和top里。让dom的位置发生变化。从而达到拖拽的效果。</li>
</ul>
<h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p><a class="link"   href="https://blog.csdn.net/lee_magnum/article/details/17753807" >blog<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/qq_35800306/article/details/59502392" >blog<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>发布订阅模式</title>
    <url>/2021/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<blockquote>
<p>本文摘自《Javascript设计模式与开发实践》</p>
</blockquote>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li>对象之间的依赖关系。当一个对象的状态发生改变时，所有依赖它的对象都会得到通知</li>
<li>Javascript一般用事件模型来替代传统的发布-订阅模式</li>
<li>可能会有中介这个身份，中转所有依赖关系。让发布者和订阅者不需要了解彼此。</li>
</ul>
<h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ul>
<li>提供数据方，和接受数据方，不是强耦合的关系</li>
</ul>
<h3 id="3-模拟"><a href="#3-模拟" class="headerlink" title="3. 模拟"></a>3. 模拟</h3><pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间者统一处理</span></span><br><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clientList = &#123;&#125;,</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove;</span><br><span class="line">    </span><br><span class="line">    listen = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123; <span class="comment">// 添加</span></span><br><span class="line">        <span class="keyword">if</span> (!clientList[key]) &#123;</span><br><span class="line">            clientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        clientList[key] = fn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trigger = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 通知、发布</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">            fns = clientList[key];</span><br><span class="line">        <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++]) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123; <span class="comment">// 删除</span></span><br><span class="line">        <span class="keyword">var</span> fns = clientList[key]</span><br><span class="line">        <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123; <span class="comment">// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></span><br><span class="line">            fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = fns.length -<span class="number">1</span>; i&gt;=<span class="number">0</span>; i-- ) &#123;</span><br><span class="line">                <span class="keyword">var</span> _fn = fns[i]</span><br><span class="line">                <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                    fns.splice(i, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">listen</span>: listen,</span><br><span class="line">        <span class="attr">trigger</span>: trigger,</span><br><span class="line">        <span class="attr">remove</span>: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小红订阅消息 // 输出：&#x27;价格=2000000&#x27; </span></span><br><span class="line">Event.listen( <span class="string">&#x27;squareMeter88&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;价格= &#x27;</span> + price )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Event.trigger( <span class="string">&#x27;squareMeter88&#x27;</span>, <span class="number">2000000</span> );<span class="comment">// 售楼处发布消息</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="4-思考🤔"><a href="#4-思考🤔" class="headerlink" title="4. 思考🤔"></a>4. 思考🤔</h3><pre><code>订阅发布的顺序：
原本是先订阅，再发布，因为先发布没订阅的情况下，消息会丢失
增加先发布后订阅的能力：离线事件的堆栈，用来存储尚未被订阅的离线事件。等到有订阅的时候，再遍历堆栈执行。
需要注意的是，离线事件的触发只有一次。(具体代码实现结合书本参考 )
</code></pre>
<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h3><pre><code>+ 优点：时间和对象上的解耦，常用于异步编程。
+ 缺点：订阅了消息，订阅者会始终存在内存中。对象之间的必要联系会难以跟踪。
</code></pre>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="">设计模式篇观察订阅模式第10节</a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" >apply<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2021/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文摘自《Javascript设计模式与开发实践》</p>
</blockquote>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p> 给对象动态添加职责</p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><ul>
<li>解除耦合关系，如提交前的表单检验，函数参数封装等</li>
</ul>
<h3 id="3-模拟"><a href="#3-模拟" class="headerlink" title="3. 模拟"></a>3. 模拟</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href=""></a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>听到请回答1988</title>
    <url>/2019/04/06/%E8%AF%B7%E5%9B%9E%E7%AD%941988/</url>
    <content><![CDATA[<p>啊   感动啊感动<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-73eb983ad340c514bd4c33f08032000f_r.jpg"
                      alt="合照"
                ><br>很温暖，很简单，很友好的情感</p>
<p>我现在听着1988的网易云歌单，写下这篇日志，希望看到的人也和我一样喜欢这部片子呢</p>
<p>一部小小的电视机里，放着的是我们的润发哥和国荣哥的《英雄本色》，哇好有品位呀，我们故事里的主人公们坐在电视机前，善宇，娃娃鱼，正焕，德善，阿泽。</p>
<p>哈哈，豹纹女士大喊一声:”正焕啊，回家吃饭啦！”，接着他们都回家吃饭，留下我们呆萌的阿泽，阿泽爸爸也进来房间，微笑着说，阿泽，我们也吃饭吧😊</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/07/15/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-深度优先搜索-amp-amp-广度优先搜索"><a href="#1-深度优先搜索-amp-amp-广度优先搜索" class="headerlink" title="1. 深度优先搜索 &amp;&amp; 广度优先搜索"></a>1. 深度优先搜索 &amp;&amp; 广度优先搜索</h4><p>深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止<br>广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。</p>
<p>参考：<br><a class="link"   href="https://github.com/sisterAn/JavaScript-Algorithms" >瓶子君 算法<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器-重排&amp;&amp;重绘</title>
    <url>/2020/07/20/%E9%87%8D%E7%BB%98&amp;&amp;%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<h4 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h4><p>webkit 引擎将 render树上的每个可见元素，包装成 渲染对象 。 而 <strong>WebKits RenderObject</strong> 类是所有渲染对象的基类。<br>这个基类，包含了以下两个方法：<br>(1) <code>layout</code>:<br>    学名：布局 / 回流<br>    功能点：计算位置和大小 （开销最大，回流完需要重绘）</p>
<p> <strong>全局布局 &amp;&amp; 增量布局</strong></p>
<p>这两个布局改变，都会触发 layout ，重新计算元素位置和大小</p>
<ul>
<li><p>全局布局：触发整个 render 树的布局，触发原因可能有：</p>
<ul>
<li>字体大小</li>
<li>屏幕大小的调整</li>
</ul>
</li>
<li><p>增量布局：<br>  触发的原因：请求样式计算</p>
<ul>
<li>一个 DOM 元素的几何属性变化，常见的几何属性有 width、height、padding、margin、left、top、border 等等。</li>
<li>使 DOM 节点发生增减或者移动。</li>
<li>读写 offset 家族、scroll 家族和 client 家族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li>
<li>调用 window.getComputedStyle 方法。</li>
</ul>
</li>
</ul>
<p>（2）<code>paint</code>:<br>学名：重绘</p>
<p>功能点： 在构造render 树和 layout 阶段后，知道可见节点，以及样式和具体大小位置信息（几何信息）后，将每个render 节点转化成屏幕像素的过程。</p>
<p>触发原因：改变了元素外观风格的样式，没影响几何属性<br>    改变 visibility<br>    outline<br>    background-color</p>
<p>绘制顺序：<br>    1. 背景颜色<br>    2. 背景图片<br>    3. 边框<br>    4. 子代<br>    5. 轮廓</p>
<p>（3）回流一定会触发重绘，而重绘不一定发生回流</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>1 缓存 对几何信息的结果<br>（现在浏览器对 重绘和回流的优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。）</p>
<p>2 避免频繁操作 DOM<br>documentFragment</p>
<p>3 开启 GPU 加速<br>tranlateZ(0) 强制提升层等级</p>
<p>但同时存在缺陷，硬件加速不是万金油，单独创建合成层是有代价的，每创建一个合成层，就要为其分配内存，内存大小取决于复合层的数量。复合层的大小 层的管理也更为复杂，在一些低端和终端移动端设备中更为明显，滥用 GPU 加速会引起页面卡顿甚至闪退。</p>
<p>4 requestAnimationFrame （下次重绘前触发，可传入触发回调函数，优点是能适配屏幕刷新率）</p>
<p>参考：<br><a class="link"   href="https://segmentfault.com/a/1190000016990089" >segment<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.zoo.team/article/browser-redraw" >政采云<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>浏览器 CSS渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2019/12/03/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1.防抖"></a>1.防抖</h3><p>✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。<br>如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，<br>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.<br>简单的说法是，取决于上次没操作后，delay时间后执行。</p>
<p>👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）</p>
<p>介绍三个版本：</p>
<h4 id="1指定this"><a href="#1指定this" class="headerlink" title="1指定this"></a>1指定this</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(func,wait)  <span class="comment">// 保持只是一个定时器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-this指向-amp-amp-指定传参（比如event）"><a href="#2-this指向-amp-amp-指定传参（比如event）" class="headerlink" title="2 this指向 &amp;&amp; 指定传参（比如event）"></a>2 this指向 &amp;&amp; 指定传参（比如<code>event</code>）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="comment">// console.log(this) // 这里的时候指向window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span> <span class="comment">// 这里的时候指向btn 关键是缓存这时候的this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//没绑定context时，这里this指向window</span></span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-this指向-amp-amp-指定传参-amp-amp-立即执行"><a href="#3-this指向-amp-amp-指定传参-amp-amp-立即执行" class="headerlink" title="3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行"></a>3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123; <span class="built_in">clearTimeout</span>(timeout) &#125;</span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123; <span class="comment">// 立即执行</span></span><br><span class="line">                <span class="comment">// timeout有值的情况下，改为延时</span></span><br><span class="line">                <span class="keyword">var</span> callNow = !timeout</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span></span><br><span class="line">                &#125;,wait)</span><br><span class="line">                <span class="keyword">if</span> (callNow) &#123; func.apply(context,args) &#125;</span><br><span class="line">                <span class="comment">// 跑完立即执行，永远都会执行上面的timeout = null，</span></span><br><span class="line">                <span class="comment">// 然后下一次进入判断callNow时，又会是立即执行。 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;,wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-节流"><a href="#2-节流" class="headerlink" title="2.节流"></a>2.节流</h3><p>按指定的delay执行<br> 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景</p>
<p>下面介绍两个版本：</p>
<h4 id="✨-使用时间戳"><a href="#✨-使用时间戳" class="headerlink" title="✨ 使用时间戳"></a>✨ 使用时间戳</h4><p>  使用时间戳，当触发事件的时候，我们取出当前的时间戳，<br>  然后减去之前的时间戳(最一开始值设为 0 )，<br>  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，<br>  如果小于，就不执行。</p>
<div class="tip">
    第一下会立刻执行
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，</span></span><br><span class="line"><span class="comment">// Date.prototype.value方法等同于Date.prototype.getTime()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>() </span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">if</span> ((now - previous) &gt; wait) &#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">            previous = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✨-使用定时器"><a href="#✨-使用定时器" class="headerlink" title="✨ 使用定时器"></a>✨ 使用定时器</h4><p>当触发事件的时候，我们设置一个定时器，<br>再触发事件的时候，如果定时器存在，就不执行，<br>直到定时器执行，然后执行函数，<br>清空定时器，<br>这样就可以设置下个定时器。</p>
<div class="tip">
    第一下会延时执行
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span></span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-两者的关联与区别"><a href="#3-两者的关联与区别" class="headerlink" title="3.两者的关联与区别"></a>3.两者的关联与区别</h3><p>两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率<br>假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。</p>
<p>参考链接：<br><a class="link"   href="https://zhuanlan.zhihu.com/p/38313717" >专栏<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/mqyqingfeng/Blog/issues/26" >mqyqingfeng  issue<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS优化</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式</title>
    <url>/2020/04/09/CSS/%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>响应式原理，是在 pc 开发中 resize 页面时，或者在移动端布局时，都会需要根据屏幕的变化或屏幕大小去适配UI的整体大小。让我们看看吧！</p>
</blockquote>
<h5 id="方案一：-rem"><a href="#方案一：-rem" class="headerlink" title="方案一： rem"></a>方案一： rem</h5><p><strong>rem</strong> 是相对长度单位，相对于 <strong>根元素</strong>，常用于响应式布局<br><strong>em</strong> 是相对长度单位，相对于 <strong>父元素</strong>，不常用<br><strong>px</strong> 是绝对长度单位</p>
<p>rem的弊端：<br>具有 ”阶梯性“。需要设置对应的场景去适配对应的rem。无法<strong>预先适配</strong>所有场景。<br>结合 flexible.js 可以动态更改 根font-size; </p>
<p><a class="link"   href="https://segmentfault.com/a/1190000004403496" >flexible原理<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="方案二：-vw-vh-vmax-vmin"><a href="#方案二：-vw-vh-vmax-vmin" class="headerlink" title="方案二： vw vh vmax vmin"></a>方案二： vw vh vmax vmin</h5><p>先了解下网页视口尺寸<br>window.screen.height // 屏幕高度<br>window.innerHeight // 网页视口高度 （vh 、vw 就是相对于这个网页视口的百分一）<br>document.body.clientHeight // 页面内容 body高度</p>
<p>vmax 取 vh 和 vw 最大值<br>vmin 取 vh 和 vw 最小值</p>
<h5 id="方案三：-媒体查询-media-query-rem"><a href="#方案三：-媒体查询-media-query-rem" class="headerlink" title="方案三： 媒体查询 media-query + rem"></a>方案三： 媒体查询 media-query + rem</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">374px</span>) &#123;</span><br><span class="line">    <span class="comment">/* ihone5 or little more, use ihone5 width 320px to set font-size */</span></span><br><span class="line">    <span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">86px</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">374px</span>) &#123;</span><br><span class="line">    <span class="comment">/* ihone6 7 8 and iphonex */</span></span><br><span class="line">    <span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">100px</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">    <span class="comment">/* ihone6p or bigger more, use ihone6p width 414px to set font-size */</span></span><br><span class="line">    <span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">110px</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同屏幕宽度设置 根元素 font-size</p>
<hr>
<p><a class="link"   href="https://segmentfault.com/a/1190000041831493" >移动端常见适配方案<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://segmentfault.com/a/1190000041704010" >移动端常见适配方案<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.zhangxinxu.com/wordpress/2016/08/vw-viewport-responsive-layout-typography/" >基于vw等viewport视区单位配合rem响应式排版和布局<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.cn/post/7046169975706353701" >juejim移动端适配方案汇总<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 SASS 的一些思考</title>
    <url>/2021/10/07/CSS/SASS/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在看 Element UI 的 CSS 开发规范，也有一些启发。此文用来记录下。</p>
<p>主要是遵循 <strong>BEM</strong> 规范。</p>
<p>B: Block 模块<br>E: Element 元素<br>M: Modifier 修饰符（ 状态、属性 ）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block__element</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block--modifier</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>SASS 也是有一些 <strong>作用域机制</strong> 的，那么，<strong>局部变量</strong> 和 <strong>全局变量</strong> 就合理存在了。</p>
<p>一般用 <code>$</code> 表示 变量<br>也有用 <code>#&#123;&#125;</code> 表示 , 通过 <code>#&#123;&#125;</code> 插值语句可以在选择器或属性名中使用变量</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span>: foo;</span><br><span class="line"><span class="variable">$attr</span>: border;</span><br><span class="line"><span class="selector-tag">p</span>.#&#123;<span class="variable">$name</span>&#125; &#123;</span><br><span class="line">  #&#123;<span class="variable">$attr</span>&#125;-<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编译为 */</span> </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: blue; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量）。<br>不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。<br>将局部变量转换为全局变量可以添加 <strong>!global</strong> 声明：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="variable">$width</span>: <span class="number">5em</span> !global;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编译为 */</span> </span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Slot-插槽"><a href="#Slot-插槽" class="headerlink" title="Slot 插槽"></a>Slot 插槽</h5><p><code>@content</code> : 向混合样式中导入内容 (Passing Content Blocks to a Mixin)</p>
<p>官方解释： 在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方。</p>
<p>白话理解：<code>@content</code> 即为 插槽 、占位符。在 <code>include mixin</code> 时 ，定义在 <code>mixin</code> 里。</p>
<p>请看示例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> apply-to-ie6-only &#123;</span><br><span class="line">  * <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> apply-to-ie6-only &#123;</span><br><span class="line">  <span class="selector-id">#logo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(/logo.gif);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译为 */</span> </span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(/logo.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指令，类似-JS-功能-（-循环、-）"><a href="#指令，类似-JS-功能-（-循环、-）" class="headerlink" title="指令，类似 JS 功能 （ 循环、 ）"></a>指令，类似 JS 功能 （ 循环、 ）</h5><ul>
<li><code>@each</code> : 遍历循环 语法是 <code>$var in &lt;list&gt;</code><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span> in puma, sea-slug, egret, salamander &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译为 */</span> </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/puma.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/sea-slug.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/egret.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.salamander-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/salamander.png&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// element 这里用来便捷传入 e 参数数组</span></span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$unit</span> in <span class="variable">$element</span> &#123;</span><br><span class="line">    <span class="variable">$currentSelector</span>: #&#123;<span class="variable">$currentSelector</span> +</span><br><span class="line">      <span class="string">&quot;.&quot;</span> +</span><br><span class="line">      <span class="variable">$B</span> +</span><br><span class="line">      <span class="variable">$element-separator</span> +</span><br><span class="line">      <span class="variable">$unit</span> +</span><br><span class="line">      <span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 传入当前 `class`，可以是数组，逗号隔开即可。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@include</span> b((card)) &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ebeef5</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#303133</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">@include</span> e(footer) &#123;   <span class="comment">//传入单个</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> e((title, body)) &#123;  <span class="comment">//传入数组</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-class">.mk-card</span> <span class="selector-class">.mk-card__footer</span> &#123;  <span class="comment">//传入单个编译结果</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mk-card</span> <span class="selector-class">.mk-card__title</span>,  <span class="comment">//传入数组编译结果</span></span><br><span class="line"><span class="selector-class">.mk-card</span> <span class="selector-class">.mk-card__body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考文档：</p>
<p><a class="link"   href="https://www.sass.hk/docs/" >SASS doc<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title>margin负值问题</title>
    <url>/2020/04/08/CSS/margin%E8%B4%9F%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>也许在工作中 hack 样式时，有用过 margin 负值，但是没正式归纳过。让我们好好梳理下～</p>
</blockquote>
<h5 id="第一种情况：元素没有设置浮动且-没有设置定位或者-position-为-static"><a href="#第一种情况：元素没有设置浮动且-没有设置定位或者-position-为-static" class="headerlink" title="第一种情况：元素没有设置浮动且 没有设置定位或者 position 为 static"></a>第一种情况：元素<strong>没有设置浮动</strong>且 <strong>没有设置定位</strong>或者 <strong>position 为 static</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/%E6%83%85%E6%99%AF1.png"
                      alt="情景1"
                ></p>
<p>分析：<br>（1）设置 <strong>margin-top 和 margin-left</strong> 时，都是<strong>自身移动</strong> ：top 就是往上位移，left 就是往左位移<br>（2）设置 <strong>margin-bottom 和 margin-right</strong> 时，<strong>自身不移动</strong>，<strong>元素后面</strong>的元素（以下简称后面元素）往<strong>反方向</strong>位移：<br>margin-right 时就是，后面元素往左位移。 margin-bottom 时就是，后面元素往上位移。<br>并且，<strong>后面元素会覆盖</strong>在前面元素上面。</p>
<h5 id="第二种情况：元素没有设置浮动且-position-为-relative"><a href="#第二种情况：元素没有设置浮动且-position-为-relative" class="headerlink" title="第二种情况：元素没有设置浮动且 position 为 relative"></a>第二种情况：元素<strong>没有设置浮动</strong>且 <strong>position 为 relative</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/%E6%83%85%E6%99%AF2.png"
                      alt="情景2"
                ></p>
<p>分析：<br>（1）设置 <strong>margin-top 和 margin-left</strong> 时，都是<strong>自身移动</strong> ：top 就是往上位移，left 就是往左位移（同第一种）<br>（2）当设置 <strong>margin-bottom/right</strong> 的时候，元素本身也不会移动，元素后面的其他元素也会往该元素的方向移动相应的距离，但是，<strong>该元素会覆盖在后面的元素上面</strong> (当然，此处说的情况肯定是<strong>后面的元素没有设置定位以及 z-index</strong>的情况)。</p>
<h5 id="第三种情况：元素没有设置浮动且-position-为-absolute"><a href="#第三种情况：元素没有设置浮动且-position-为-absolute" class="headerlink" title="第三种情况：元素没有设置浮动且 position 为 absolute"></a>第三种情况：元素<strong>没有设置浮动</strong>且 <strong>position 为 absolute</strong></h5><p>分析：<br>（1）设置 <strong>margin-top 和 margin-left</strong> 时，都是<strong>自身移动</strong> ：top 就是往上位移，left 就是往左位移（同第一种）<br>（2）当设置 <strong>margin-bottom/right</strong> 的时候，不会对后面元素造成影响。因为该元素已经脱离了标准文档流。</p>
<h5 id="第四种情况：元素有设置浮动-（涉及比较多✨-需要重点看）"><a href="#第四种情况：元素有设置浮动-（涉及比较多✨-需要重点看）" class="headerlink" title="第四种情况：元素有设置浮动 （涉及比较多✨ 需要重点看）"></a>第四种情况：元素<strong>有设置浮动</strong> （涉及比较多✨ 需要重点看）</h5><p>分析：<br>（1）当元素，设置的 <strong>margin 的方向与浮动的方向</strong> <strong>相同</strong>，那么，该元素会往对应的方向移动对应的距离。<br>比如 float : left 和 margin-left：负值，该元素就会向左边位移。</p>
<p>应用场景：<br>双飞翼布局，中检侧float：left，width：100% 。<br>而右侧，可以设置width：100px ，margin-left：-100px，float：left。这样右侧会自动往左侧位移100px，就贴合在右边了。<br>而左侧，可以设置width：200px，**margin-left：-100%**，float：left。这样左侧会向左侧位移父盒子100%的宽度，就贴合在左边了。<br>撒花🎉</p>
<p>（2）当元素，设置的 <strong>margin 的方向与浮动的方向</strong> <strong>相反</strong>，那么，该元素本身不动，元素前后的元素会往该元素的方向移动对应的距离。<br>比如 float : right 和 margin-left：负值，该元素就会向左边位移。</p>
<hr>
<p>参考链接：<br><a class="link"   href="https://segmentfault.com/a/1190000007184954" >理解并运用 CSS 的负 margin 值 segmentFault<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>review target</title>
    <url>/2020/04/12/%E9%9D%A2%E8%AF%95%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<p>知己知彼，百战百胜<br>实力推荐<br><a class="link"   href="https://muyiy.cn/" >木易杨<i class="fas fa-external-link-alt"></i></a></p>
<p>参考链接：</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/69705235" >阿里p7要求<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/jawil/blog/issues/22" >阿里P6+要求<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/5e5522b36fb9a07ce152c51c" >掘金1<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/587dab348d6d810058d87a0a" >掘金2<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/axuebin/articles/issues/39" >axuebin issue<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/coffe1891/frontend-hard-mode-interview" >前端内参github<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>JS_review</title>
    <url>/2020/04/12/JS/JS_review/</url>
    <content><![CDATA[<h3 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h3><h5 id="值类型和引用类型，分别是什么，有什么区别"><a href="#值类型和引用类型，分别是什么，有什么区别" class="headerlink" title="值类型和引用类型，分别是什么，有什么区别"></a>值类型和引用类型，分别是什么，有什么区别</h5><p>JS的<strong>基本数据类型</strong>就是<strong>值类型</strong>，包括 Undefined, Null, Boolean, Number, String, Symbol<br>JS的<strong>引用类型</strong>，统称为<strong>Object类型</strong>，包括 Object，Array，Date，RegExp，Function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">X</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = obj1</span><br><span class="line"><span class="keyword">let</span> x1 = obj1.X</span><br><span class="line">obj2.X = <span class="number">101</span></span><br><span class="line">x1 = <span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">// &#123; X:101 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123; X:101 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(x1) <span class="comment">// 102</span></span><br></pre></td></tr></table></figure>


<h5 id="typeof-能判断哪些类型"><a href="#typeof-能判断哪些类型" class="headerlink" title="typeof 能判断哪些类型"></a>typeof 能判断哪些类型</h5><p>typefof 能判断所有基本类型数据，<br>对于引用类型 ：function =&gt; function<br>null 、 数组、对象 =&gt; Object （null 属于例外情况）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 是否为 null：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&#x27;object&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">666</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// number </span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line">a = [];</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object</span></span><br><span class="line">a = &#123;&#125;;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object</span></span><br><span class="line">a = <span class="regexp">/aaa/g</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object   </span></span><br></pre></td></tr></table></figure>

<p>判断全局变量有无时需要用到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (DEUBG) &#123; <span class="comment">// maybe throw error about not DEBUG </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;debugging is start&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> DEBUG !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="comment">// better</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;debugging is start&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="何时使用-，何时使用"><a href="#何时使用-，何时使用" class="headerlink" title="何时使用 === ，何时使用 =="></a>何时使用 === ，何时使用 ==</h5><p>“ == 允许在相等比较中进行强制类型转换，而 === 不允许。”</p>
<h5 id="JS深浅拷贝"><a href="#JS深浅拷贝" class="headerlink" title="JS深浅拷贝"></a>JS深浅拷贝</h5><p>在另一篇博文有详细介绍，链接：<a target="blank" href="/2020/07/13/克隆对象&&数组（一）/">点此</a></p>
<h5 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h5><p>在另一篇博文有详细介绍，链接：<a target="blank" href="/2021/07/13/JS/类型转换/">点此</a></p>
<hr>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><h5 id="如何准备判断一个变量是数组？"><a href="#如何准备判断一个变量是数组？" class="headerlink" title="如何准备判断一个变量是数组？"></a>如何准备判断一个变量是数组？</h5><p>a instanceof Array</p>
<h5 id="class-的原型本质？"><a href="#class-的原型本质？" class="headerlink" title="class 的原型本质？"></a>class 的原型本质？</h5><p>原型和原型链的原理</p>
<h5 id="jQuery-的基本结构？用-class-实现？要考虑插件和扩展性。"><a href="#jQuery-的基本结构？用-class-实现？要考虑插件和扩展性。" class="headerlink" title="jQuery 的基本结构？用 class 实现？要考虑插件和扩展性。"></a>jQuery 的基本结构？用 class 实现？要考虑插件和扩展性。</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">constructor</span>(<span class="params">selector</span>)</span> &#123; <span class="comment">// dom 查询 </span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">        <span class="keyword">const</span> length = result.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">// dom 绑定到实例上</span></span><br><span class="line">            <span class="built_in">this</span>[i] = result[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.length = length</span><br><span class="line">        <span class="built_in">this</span>.selector = selector</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">index</span>)</span> &#123; <span class="comment">// 获取 对应的 dom</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">each</span>(<span class="params">fn</span>)</span> &#123; <span class="comment">// 添加遍历行为</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length ; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> elem = <span class="built_in">this</span>[i]</span><br><span class="line">                fn(elem)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">on</span>(<span class="params">type, fn</span>)</span> &#123; <span class="comment">// 循环 添加事件监听</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.each(<span class="function"><span class="params">elem</span> =&gt;</span> &#123;</span><br><span class="line">                elem.addEventListener(type, fn, <span class="literal">false</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// execute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $p = <span class="keyword">new</span> jQuery(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">$p.get(<span class="number">1</span>)</span><br><span class="line">$p.each(<span class="function">(<span class="params">elem</span>) =&gt;</span> <span class="built_in">console</span>.log(elem.nodeName))</span><br><span class="line">$p.on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;clicked&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件 在原型链上添加</span></span><br><span class="line">jQuery.prototype.dialog = <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">    alert(info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展性 == 添加新方法 或者造轮子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myjQuery</span> <span class="keyword">extends</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">selector</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩展...</span></span><br><span class="line">    <span class="function"><span class="title">addClass</span>(<span class="params">className</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">style</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在另一篇博文有详细介绍，链接：点此"><a href="#在另一篇博文有详细介绍，链接：点此" class="headerlink" title="在另一篇博文有详细介绍，链接：点此"></a>在另一篇博文有详细介绍，链接：<a target="blank" href="/2020/04/07/JS/继承/">点此</a></h2><h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><h5 id="this-的不同应用场景，如何取值？"><a href="#this-的不同应用场景，如何取值？" class="headerlink" title="this 的不同应用场景，如何取值？"></a>this 的不同应用场景，如何取值？</h5><p>（1）作为普通函数 ，返回 window<br>（2）使用 call 、apply 、bind ，返回绑定的参数<br>（3）作为对象方法被调用，返回对象本身<br>（4）在 class 方法中被调用，返回 实例<br>（5）箭头函数： 取的是<strong>上级作用域</strong>的调用者</p>
<p>this 的值 是<strong>执行时</strong>确定的，而不是函数定义时。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">fn1.call(&#123; <span class="attr">x</span>: <span class="number">100</span> &#125;) <span class="comment">// &#123; x: 100 &#125;</span></span><br><span class="line"><span class="keyword">const</span> fn2 = fn1.bind(&#123; <span class="attr">x</span>: <span class="number">200</span> &#125;) <span class="comment">// bind 会返回一个新函数</span></span><br><span class="line">fn2() <span class="comment">// &#123;x: 200&#125;</span></span><br></pre></td></tr></table></figure>

<p>箭头函数中 和 setTimeout中 对 this的使用：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/this_1.webp"
                      alt="this_1"
                ></p>
<p>class 中 this的指向：实例本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    sayHi () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> People(<span class="string">&#x27;john&#x27;</span>)</span><br><span class="line">john.sayHi() <span class="comment">// john 实例</span></span><br></pre></td></tr></table></figure>
<h5 id="手写-bind-函数？"><a href="#手写-bind-函数？" class="headerlink" title="手写 bind 函数？"></a>手写 bind 函数？</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a , b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this: &#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;this is fn1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = fn1.bind(&#123;<span class="attr">x</span>: <span class="number">100</span>&#125;, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) <span class="comment">// function.prototype.bind</span></span><br><span class="line"><span class="keyword">const</span> res = fn2()</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// custom function bind1</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 将参数转为数组 slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组</span></span><br><span class="line">    <span class="keyword">const</span> t = args.shift()<span class="comment">// 获取 this</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span> <span class="comment">// 存 调用者</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(t, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在另一篇博文有详细介绍 call 、 apply、 bind，链接：<a target="blank" href="/2020/04/09/JS/call&apply&bind/">点此</a></p>
<h5 id="闭包是什么，实际开发中闭包的应用场景，举例说明："><a href="#闭包是什么，实际开发中闭包的应用场景，举例说明：" class="headerlink" title="闭包是什么，实际开发中闭包的应用场景，举例说明："></a>闭包是什么，实际开发中闭包的应用场景，举例说明：</h5><p>闭包是作用域应用的特殊情况，有两种表现：<br>（1）函数作为参数被传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">200</span></span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">300</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">print(fn)</span><br></pre></td></tr></table></figure>

<p>（2）函数作为返回值被返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a  = <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">200</span></span><br><span class="line"><span class="keyword">const</span> fn = create()</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>闭包在开发中的实际应用：<br>（1）隐藏数据，避免外界修改或污染某值<br>（2）做一个简单的 cache 工具</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;&#125; <span class="comment">// 闭包中的数据，被隐藏，不被外界访问</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">            data[key] = val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = createCache()</span><br><span class="line">c.set(<span class="string">&#x27;x&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">c.get(<span class="string">&#x27;x&#x27;</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<h5 id="10个-a-标签，点击弹出的序号是？"><a href="#10个-a-标签，点击弹出的序号是？" class="headerlink" title="10个 a 标签，点击弹出的序号是？"></a>10个 a 标签，点击弹出的序号是？</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i, a</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// i 在全局，结局是 alert 打印的都是 10</span></span><br><span class="line">    a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    a.innerHTML = i + <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br><span class="line">    a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        alert(i)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; ...) <span class="comment">// 这样可以解决</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="作用域-和-自由变量-分别是什么？"><a href="#作用域-和-自由变量-分别是什么？" class="headerlink" title="作用域 和 自由变量 分别是什么？"></a>作用域 和 自由变量 分别是什么？</h5><p>作用域包括：全局作用域 、函数作用域 、块级作用域（ ES6 新增 ）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// throw error: x is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>自由变量：<br>（1）一个变量在当前作用域没有定义，但被使用了<br>（2）向上级作用域，一层一层的寻找，直至找到<br>（3）如果到全局作用域都没找到，则报错：is not defined<br>（4）自由变量的查找，是在<strong>函数定义</strong>的地方，向上级作用域查找。不是在<strong>执行的地方</strong>。</p>
<p><a class="link"   href="https://chinese.freecodecamp.org/news/javascript-var-let-and-const/" >let var const<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<h3 id="异步-和-单线程"><a href="#异步-和-单线程" class="headerlink" title="异步 和 单线程"></a>异步 和 单线程</h3><h5 id="为什么说-JS-是单线程语言？"><a href="#为什么说-JS-是单线程语言？" class="headerlink" title="为什么说 JS 是单线程语言？"></a>为什么说 JS 是单线程语言？</h5><p>JS 是单线程语言，只能同时做一件事。</p>
<p>为了利用多核 CPU 的计算能力， HTML5提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<p>JS 和 DOM 渲染共用一个线程，因为 JS 可修改 DOM 结构</p>
<p>也是因为单线程机制，JS 发生请求 ，如果没有异步的话，会一直卡住接下来的 JS 运行，一直等待到结果返回，这样是不合理的，浪费了时间资源。</p>
<h5 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h5><p>遇到等待（网络请求 、 定时任务）不能卡住</p>
<p>以 callback 回调函数形式</p>
<h5 id="同步和异步的区别是什么？"><a href="#同步和异步的区别是什么？" class="headerlink" title="同步和异步的区别是什么？"></a>同步和异步的区别是什么？</h5><p>同步会阻塞代码执行</p>
<p>异步不会阻塞代码执行, 就是为了处理 JS 单线程时的执行问题</p>
<h5 id="Promise-的由来？callback-hell-是什么？"><a href="#Promise-的由来？callback-hell-是什么？" class="headerlink" title="Promise 的由来？callback hell 是什么？"></a>Promise 的由来？callback hell 是什么？</h5><p>callback hell ，就是传说中的回调地狱。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.get(url1, <span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1)</span><br><span class="line">    $.get(url2, <span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data2)</span><br><span class="line">        $.get(url3, <span class="function">(<span class="params">data3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data3)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="Promise-有哪三种状态？如何变化？"><a href="#Promise-有哪三种状态？如何变化？" class="headerlink" title="Promise 有哪三种状态？如何变化？"></a>Promise 有哪三种状态？如何变化？</h5><p>待定（ pending ）: 初始状态，既没有被兑现，也没有被拒绝。<br>已兑现（ fulfilled ）: 意味着操作成功完成。<br>已拒绝（ rejected ）: 意味着操作失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test 1</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test 2</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p2) <span class="comment">// Promise &lt;pending&gt; 但点击开时，已是完成的状态 [[PromiseState]]: &quot;fulfilled&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test 3</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        reject()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p3) <span class="comment">// Promise &lt;pending&gt; 但点击开时，已是完成的状态 [[PromiseState]]: &quot;rejected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test 4</span></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>) </span><br><span class="line">p4.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="promise-then-和-catch-的连接"><a href="#promise-then-和-catch-的连接" class="headerlink" title="promise then 和 catch 的连接"></a>promise then 和 catch 的连接</h5><p>then 正常返回 resolved ，里面有 throw Error 则返回 rejected<br>catch 正常返回 resolved ， 里面有 throw Error 则返回 rejected</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证 reject catch</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;my error&#x27;</span>).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p3: &#x27;</span>, p3)</span><br><span class="line">p3.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">// 可以触发的</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Promise &lt;pending&gt; 但点击开时，已是完成的状态  [[PromiseState]]: &quot;fulfilled&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;my new Error&#x27;</span>).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;catch err&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Promise &lt;pending&gt; 但点击开时，已是完成的状态  [[PromiseState]]: &quot;rejected&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p4: &#x27;</span>, p4) </span><br><span class="line"></span><br><span class="line">p4.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>) <span class="comment">// 无法触发</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>) <span class="comment">// 可以触发</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test 1</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;) <span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error1&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;) <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test 3</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error1&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="number">100</span> <span class="comment">// await 100 === await Promise.resolve(100)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a: &#x27;</span>, a)</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">200</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b: &#x27;</span>, b)</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">300</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c: &#x27;</span>, c)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h5 id="手写用-Promise-加载一张图片？"><a href="#手写用-Promise-加载一张图片？" class="headerlink" title="手写用 Promise 加载一张图片？"></a>手写用 Promise 加载一张图片？</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/this_1.webp&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">        img.onload = <span class="function">() =&gt;</span> &#123; resolve(img) &#125;</span><br><span class="line">        img.onerror = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`图片加载失败<span class="subst">$&#123;src&#125;</span>`</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(img)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">loadImg(url).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">await</span> 写法</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> img1 = <span class="keyword">await</span> loadImg(src1)</span><br><span class="line">    <span class="built_in">console</span>.log(img1)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h5 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h5><p>是 promise 的语法糖</p>
<p>async / await 用同步语法来写，取代回调函数写法</p>
<p>async 函数返回的是 Promise 对象</p>
<p>await 相当于 Promise 的 then</p>
<p>try … catch 可以 捕获异常</p>
<p>!!! async 里面 ，await 之前的代码（包括 await ）都会立即执行，await 之后的代码，也是等于 Promise then 后的回调代码，会让 Event Loop 分配事件池。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>) <span class="comment">// rejected status</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> p4</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p5 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;err1&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> awaitp5 = <span class="keyword">await</span> p5  <span class="comment">// 在这里就会抛出错误，下面的代码不会执行，除非用 try catch 去捕获异常</span></span><br><span class="line">    <span class="built_in">console</span>.log(awaitp5)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> <span class="comment">// 相当于 return Promise.resolve(100)</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = fn() <span class="comment">// Promise&lt;完成态：100&gt;&gt;</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> fn() <span class="comment">// 100</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// test 2</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="number">100</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>, a)</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">200</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, b)</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">300</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>, c)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// test 3</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test 4</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">await</span> async2() <span class="comment">// </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">setTimeout</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 下次宏任务 首先执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>) <span class="comment">// 8</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// 当次 微任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>) <span class="comment">// 7</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h5 id="前端使用异步的场景有哪些？"><a href="#前端使用异步的场景有哪些？" class="headerlink" title="前端使用异步的场景有哪些？"></a>前端使用异步的场景有哪些？</h5><p>网络请求，ajax 、图片加载</p>
<p>定时任务，如 setTimeout</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// img load</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;loaded&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">&#x27;/xxx.png&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="请描述-event-loop-（事件循环-事件轮询）的机制，可画图"><a href="#请描述-event-loop-（事件循环-事件轮询）的机制，可画图" class="headerlink" title="请描述 event loop （事件循环 / 事件轮询）的机制，可画图"></a>请描述 event loop （事件循环 / 事件轮询）的机制，可画图</h5><p>event loop 是异步回调的原理</p>
<p>包含三个概念：<br>callStack： 执行栈。不论是同步还是异步，放进来 callStack 就开始执行<br>callback Queue: 异步队列。 异步方法都往这里放。<br>Event Loop：事件轮询器。一个 JS 自带处理事件归属的机制，当 callStack 为空时，Event Loop 开始从 callback Queue 里拿出事件，并放进 callStack里。然后继续等 callStack 处理，执行完又继续轮询。</p>
<p>注意：<br>setTimeout(fn,0)的含义是，指定某个任务在 callStack 最早可得的空闲时间执行，也就是说，尽可能早执行。它在 callback Queue 的尾部添加一个事件，因此要等到 callStack 和  callback Queue 现有的事件都处理完，才会得到执行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/EventLoop.webp"
                      alt="EventLoop"
                ></p>
<h5 id="DOM-事件和-Event-loop的理解"><a href="#DOM-事件和-Event-loop的理解" class="headerlink" title="DOM 事件和 Event loop的理解"></a>DOM 事件和 Event loop的理解</h5><p>DOM 事件在没触发时，是存储在哪里？<br>触发后，存储在 callback Queue 里，通过 Event loop 来处理。<br>除了异步事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入 callback Queue ，等待主线程读取。</p>
<p>执行顺序：<br>（1）callStack 执行并清空<br>（2）从 微任务队列 micro task queue 里，获取微任务，执行<br>（3）在 DOM 有修改的情况下，尝试 DOM 渲染<br>（4）触发 Event loop</p>
<h5 id="JS-如何执行"><a href="#JS-如何执行" class="headerlink" title="JS 如何执行"></a>JS 如何执行</h5><p>从前到后，一行一行执行<br>如果某行执行报错，则停止下面代码的执行<br>先执行同步代码，再执行异步</p>
<h5 id="宏任务-和-微任务-分别是什么，区别是什么？"><a href="#宏任务-和-微任务-分别是什么，区别是什么？" class="headerlink" title="宏任务 和 微任务 分别是什么，区别是什么？"></a>宏任务 和 微任务 分别是什么，区别是什么？</h5><p>宏任务： setTimeout 、 setInterval 、 Ajax 、 DOM事件 （ 浏览器规定的 ）<br>微任务： Promise 、 async / await  （ ES6 语法 规定的 ）</p>
<p>宏任务 是 在 DOM 渲染后 触发<br>微任务 是 在 DOM 渲染前 触发</p>
<p>微任务执行时机 比 宏任务 <strong>要早</strong></p>
<h5 id="promise-和-setTimeout-的执行顺序：（与-宏任务-微任务-有关）"><a href="#promise-和-setTimeout-的执行顺序：（与-宏任务-微任务-有关）" class="headerlink" title="promise 和 setTimeout 的执行顺序：（与 宏任务 微任务 有关）"></a>promise 和 setTimeout 的执行顺序：（与 宏任务 微任务 有关）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">300</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">400</span>)</span><br></pre></td></tr></table></figure>

<h5 id="for-…-in-和-for-…-of"><a href="#for-…-in-和-for-…-of" class="headerlink" title="for … in 和 for … of"></a>for … in 和 for … of</h5><p>for … in （以及 forEach for ）是常规的同步遍历<br>for … of 常用于异步的遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout 返回自乘 模拟异步</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">plusNum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(num * num)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">testArr.forEach(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">await</span> plusNum(item)) <span class="comment">// 1 4 9 结果是同时出现 也是所有异步都同时调用了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> testArr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> plusNum(i)) <span class="comment">// 1 4 9 会同步的方式 执行所有await 会等待上次结果结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一篇博文有详细介绍 <strong>异步知识</strong>，链接：<a target="blank" href="/2020/07/17/JS/浏览器异步（一）/">点此</a><br>在另一篇博文有详细介绍 <strong>JS 执行知识</strong>，链接：<a target="blank" href="/2019/12/03/JS/JS执行顺序/">点此</a></p>
<h3 id="JS-Web-API"><a href="#JS-Web-API" class="headerlink" title="JS Web API"></a>JS Web API</h3><p>在另一篇博文有详细介绍 <strong>JS Web API</strong>，链接：<a target="blank" href="/2021/04/01/JS/web-API/">点此</a></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在另一篇博文有详细介绍 <strong>事件</strong>，链接：<a target="blank" href="/2018/07/27/JS/事件/">点此</a></p>
<p>参考链接：<br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#array-like" >MDN Array-like slice<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>在另一篇博文有详细介绍 <strong>运行环境</strong>，链接 <a target="blank" href="/2021/04/06/运行环境/运行环境/">点此</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行顺序 || EventLoop</title>
    <url>/2019/12/03/JS/JS%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1-EventLoop"><a href="#1-EventLoop" class="headerlink" title="1.EventLoop"></a>1.EventLoop</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 置底进程</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;from setTimeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行顺序：script start =&gt; script end =&gt; from setTimeout</span></span><br></pre></td></tr></table></figure>

<h3 id="2-微任务-amp-amp-宏任务"><a href="#2-微任务-amp-amp-宏任务" class="headerlink" title="2.微任务 &amp;&amp; 宏任务"></a>2.微任务 &amp;&amp; 宏任务</h3><p>优先级：同步代码 &gt; 微任务 &gt; 宏任务 &gt; 异步代码<br>宏任务：script , setTimeout, setInterval, setImmediate, i/0 , UI rendering ,requestAnimationFrame<br>微任务：process.nextTick, promise, Object.observe, MutationObserver,await</p>
<ul>
<li>new Promise(fn) // 也属于微任务，执行优先级高</li>
<li>且process.nextTick优先级大于promise.then</li>
<li>await后的async的fn 也会立刻执行 因为这是一个promise返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// setTimeout1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// process2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// promise2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// then2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// process1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>); <span class="comment">// new Promise立即执行</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// then1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// setTimeout2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// process3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// promise3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// then3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序 ：</span></span><br><span class="line"><span class="comment">// 第一步：</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>执行完 1 和 7后，现在看下，身边有这些任务</p>
<table>
<thead>
<tr>
<th>宏任务Event</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td align="center">process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="center">then1</td>
</tr>
</tbody></table>
<p>现在第一轮的主线跑完了，轮到第一轮的微任务了，<br>所以，接下来执行的是process1和then1，也就是<br>1，7，6，8， </p>
<p>第一轮结束，<br>第二轮开始。</p>
<p>接下来是开启新的一轮eventLoop。开始查询到新的宏任务setTimeout1；</p>
<table>
<thead>
<tr>
<th>宏任务Event</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td align="center">process2</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="center">then2</td>
</tr>
<tr>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td>1，7，6，8，2，4，3，5</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这下好了，setTimeout1宏任务完成了。<br>接下来，就剩setTimeout2宏任务。</p>
<table>
<thead>
<tr>
<th>宏任务Event</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="center">process3</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="center">then3</td>
</tr>
</tbody></table>
<p>1，7，6，8，2，4，3，5，9，11，10，12</p>
<h3 id="3-Vue的nextTick"><a href="#3-Vue的nextTick" class="headerlink" title="3. Vue的nextTick"></a>3. Vue的nextTick</h3><blockquote>
<p>异步更新内部是最重要的就是nextTick方法，它负责将异步任务加入队列和执行异步任务。<br>VUE  也将它暴露出来提供给用户使用。在数据修改完成后，立即获取相关DOM还没那么快更新，使用nextTick便可以解决这一问题。</p>
</blockquote>
<blockquote>
<p>watcher:每个监视者都有他们自己的id，当没有记录到对应的监视者.<br>即第一次进入逻辑，否则是重复的监视者，则不会进入。这一步就是实现监视者去重的点。</p>
</blockquote>
<blockquote>
<p>new Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</p>
</blockquote>
<blockquote>
<p>异步队列更新dom和数据，执行callback回调</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-<span class="keyword">if</span>=<span class="string">&quot;show&quot;</span> type=<span class="string">&quot;text&quot;</span> ref=<span class="string">&quot;myInput&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.show = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.$refs.myInput.focus() <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 获取dom的更新，成功执行</span></span><br><span class="line">        <span class="built_in">this</span>.$refs.myInput.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考链接：<br><a class="link"   href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html" >阮一峰 Event Loop<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/5aa8a07cf265da238a3022a4" >掘金<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.im/post/59e85eebf265da430d571f89" >掘金2<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://segmentfault.com/a/1190000019494012" >segment<i class="fas fa-external-link-alt"></i></a><br><a href="cxymsg.com/guide/eventLoop.html#%E5%89%8D%E8%A8%80">blog</a><br><a class="link"   href="https://segmentfault.com/a/1190000015057278" >promise async await<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/answershuto/learnVue/blob/master/docs/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown#nexttick" >vue nextTick原理<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS原理</tag>
      </tags>
  </entry>
  <entry>
    <title>call &amp;&amp; apply &amp;&amp; bind</title>
    <url>/2020/04/09/JS/call&amp;apply&amp;bind/</url>
    <content><![CDATA[<h4 id="1-apply"><a href="#1-apply" class="headerlink" title="1. apply"></a>1. apply</h4><p>调用一个具有<code>给定this值</code>的函数，以及<code>作为一个数组（或类似数组对象）</code>提供的参数。<br>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>

<div class="tip">
        如果这个函数处于非严格模式下，`thisArg`指定为 `null` 或 `undefined` 时会自动替换为`指向全局对象`，原始值会被包装！！！
</div>

<p> 基础用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"><span class="built_in">console</span>.log(max);<span class="comment">// expected output: 7</span></span><br></pre></td></tr></table></figure>

<p>将A数组里的元素都添加到B数组 （apply有种<code>循环参数数组</code>的能力）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.push.apply(BArray,AArray)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">BArray.push(...AArray)</span><br></pre></td></tr></table></figure>

<p>手写 apply：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @todo</span></span><br></pre></td></tr></table></figure>

<h4 id="2-call"><a href="#2-call" class="headerlink" title="2. call"></a>2. call</h4><p>调用一个具有<code>给定this值</code>的函数，以及一个或多个参数。<br>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.call(thisArg, arg1, arg2, ...) </span><br></pre></td></tr></table></figure>

<p>用来继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  Product.call(<span class="built_in">this</span>, name, price);</span><br><span class="line">  <span class="built_in">this</span>.category = <span class="string">&#x27;food&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Food(<span class="string">&#x27;cheese&#x27;</span>, <span class="number">5</span>).name);</span><br><span class="line"><span class="comment">// expected output: &quot;cheese&quot;</span></span><br></pre></td></tr></table></figure>

<p>绑定上下文</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reply = [<span class="built_in">this</span>.animal, <span class="string">&#x27;typically sleep between&#x27;</span>, <span class="built_in">this</span>.sleepDuration].join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">animal</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">sleepDuration</span>: <span class="string">&#x27;12 and 16 hours&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet.call(obj);  <span class="comment">// cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure>

<p>非严格模式下，不传值则默认上下文是全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sData = <span class="string">&#x27;Wisen&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sData value is %s &#x27;</span>, <span class="built_in">this</span>.sData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display.call();  <span class="comment">// sData value is Wisen   这里上下文是window</span></span><br></pre></td></tr></table></figure>

<p>手写 call ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 3.bind</span></span><br><span class="line"><span class="string">该方法创建一个新的函数，在 `</span>bind() <span class="string">`被调用时，这个`</span>新函数<span class="string">`的 `</span><span class="built_in">this</span> 被指定为 bind() 的第一个参数<span class="string">`，而其余参数将作为新函数的参数，供调用时使用。</span></span><br><span class="line"><span class="string">也就是说，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。</span></span><br><span class="line"><span class="string">语法：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>new</code>构造函数时，忽略<code>thisArg</code> </li>
<li>在<code>setTimeout</code>中回调函数使用时，<code>thisArg</code>的任何值都将转化成<code>object</code></li>
<li>如果<code>thisArg</code>为<code>null或undefined</code>，<code>执行作用域中的this</code>将作为新的<code>thisArg</code></li>
</ul>
<p>基础用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unboundGetX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(unboundGetX());</span><br><span class="line"><span class="comment">// expected output: window.x =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGetX = unboundGetX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundGetX());</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<p>偏函数<br>bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。<br>只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。<br>当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addArguments</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = addArguments(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设参数列表。</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">null</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> addThirtySeven = addArguments.bind(<span class="literal">null</span>, <span class="number">37</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); </span><br><span class="line"><span class="comment">// [37]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// [37, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = addThirtySeven(<span class="number">5</span>); </span><br><span class="line"><span class="comment">// 37 + 5 = 42 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = addThirtySeven(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 37 + 5 = 42 ，第二个参数被忽略</span></span><br></pre></td></tr></table></figure>

<p>有意思的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(unboundSlice);</span><br><span class="line"> <span class="comment">// 这里的Function.prototype.apply 其实就是apply函数 </span></span><br><span class="line">slice(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 等同于 apply.bind(unboundSlice); 也就是slice === Array.prototype.slice</span></span><br></pre></td></tr></table></figure>


<p>假如不支持<code>bind</code>的时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Does not work with `new (funcA.bind(thisArg, args))`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thatFunc = <span class="built_in">this</span>, thatArg = <span class="built_in">arguments</span>[<span class="number">0</span>]; <span class="comment">// 缓存调用函数，this指向，其它参数</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> thatFunc !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - &#x27;</span> +</span><br><span class="line">             <span class="string">&#x27;what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> funcArgs = args.concat(slice.call(<span class="built_in">arguments</span>)) <span class="comment">// 其它参数合并传入参数，并成统一的函参</span></span><br><span class="line">      <span class="keyword">return</span> thatFunc.apply(thatArg, funcArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="4-三者同否"><a href="#4-三者同否" class="headerlink" title="4. 三者同否"></a>4. 三者同否</h4><ul>
<li>apply是传参数数组(参数不确定)，call是传参数(参数确定)</li>
<li>apply、call、bind 三者都是为了<code>改变上下文</code>，改变函数<code>内部this</code>的指向</li>
<li>通过apply这种方式，您将面临超过JavaScript引擎的参数长度限制的风险</li>
<li>多次bind也只是bind第一次绑定的值</li>
</ul>
<p>参考链接：<br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" >MDN 关于 apply<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" >MDN 关于 bind<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/coco1s/p/4833199.html" >ChokCocoblog<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://muyiy.cn/blog/3/3.3.html#call-%E5%92%8C-apply" >模拟实现<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>事件</title>
    <url>/2018/07/27/JS/%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>介绍下事件流：<br>三个阶段：捕获、目标、冒泡<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E4%BA%8B%E4%BB%B6/%E4%BA%8B%E4%BB%B6%E6%B5%81.jpg"
                      alt="事件流"
                ></p>
<p>冒泡，字面上理解，就是从下往上冒泡，咕噜咕噜～可以理解成从具体节点到不具体节点的事件流（<code>addEventListener</code>默认监听选项）</p>
<p>捕获，与冒泡相反，就是从大节点一直往下获取事件流，直到具体节点</p>
<h3 id="事件委托（事件委托-是-别名）"><a href="#事件委托（事件委托-是-别名）" class="headerlink" title="事件委托（事件委托 是 别名）"></a>事件委托（事件委托 是 别名）</h3><p>如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jq</span></span><br><span class="line">$(<span class="string">&#x27;.top_wrapper a&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index,item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aLink = $(item).attr(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!aLink.includes(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">        aLink += <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coupon) &#123;</span><br><span class="line">        aLink +=<span class="string">`&amp;coupon=<span class="subst">$&#123;coupon&#125;</span>`</span>;</span><br><span class="line">        $(item).attr(<span class="string">&#x27;href&#x27;</span>,aLink );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qd) &#123;</span><br><span class="line">        aLink +=<span class="string">`&amp;qd=<span class="subst">$&#123;qd&#125;</span>`</span>;</span><br><span class="line">        $(item).attr(<span class="string">&#x27;href&#x27;</span>,aLink );</span><br><span class="line">    &#125;</span><br><span class="line">    $(item).attr(<span class="string">&#x27;href&#x27;</span>, aLink);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 原生</span></span><br><span class="line">    &lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#list&#x27;</span>)</span><br><span class="line">    list.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.target.tagName === <span class="string">&#x27;LI&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;当前元素事件触发成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p><code>addEventListener(eventName,function,bool)</code> // eventName事件名 function是触发的函数 bool为true时是捕获 默认是false冒泡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#list&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    list.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// elem.closest(selector) 方法返回与 selector 匹配的最近的祖先。&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 在我们的例子中，我们从源元素开始向上寻找 &lt;li&gt;。</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 限定不超出ul#list的范围</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> li = e.target.closest(<span class="string">&#x27;li&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (!li) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span>(!list.contains(li)) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(li)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>(1) 内联 (优先级最高)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(1);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2) 对象.事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="tip">以上两种方式只能绑定一个事件</div>

<p>(3) addEventListener</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">bt.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>event.stopPropagation: 阻止捕获和冒泡阶段中当前事件的进一步传播。<br>event.preventDefault: 阻止默认行为,调用了后就会取消事件的执行。</p>
<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><h5 id="事件绑定-1"><a href="#事件绑定-1" class="headerlink" title="事件绑定"></a>事件绑定</h5><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><h5 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h5><h3 id="QA："><a href="#QA：" class="headerlink" title="QA："></a>QA：</h3><h5 id="编写一个通用的事件监听函数"><a href="#编写一个通用的事件监听函数" class="headerlink" title="编写一个通用的事件监听函数"></a>编写一个通用的事件监听函数</h5><p>有时候在事件处理函数内部，您可能会看到一个固定指定名称的参数，例如 event，evt 或简单的 e。<br>这被称为事件对象，它被自动传递给事件处理函数，以提供额外的功能和信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem, type, selector, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn == <span class="literal">null</span>) &#123;</span><br><span class="line">        fn = selector</span><br><span class="line">        selector = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    elem.addEventListener(type, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> target = e.target</span><br><span class="line">        <span class="keyword">if</span> (selector) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target.matches(selector)) &#123; <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Element/matches 匹配css选择器 返回 布尔</span></span><br><span class="line">                fn.call(target, event)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fn.call(target, event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>)</span><br><span class="line">btnEvent(btn1, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;button&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    alert(<span class="string">&#x27;clicked&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="描述事件冒泡的流程"><a href="#描述事件冒泡的流程" class="headerlink" title="描述事件冒泡的流程"></a>描述事件冒泡的流程</h5><p>基于DOM 树形结构， DOM 树的深层级 往 浅层级 的事件响应，就是 事件冒泡<br>事件代理 的机制也是 事件冒泡</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻止事件冒泡</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#p1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body</span><br><span class="line">bindEvent(p1, <span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    alert(<span class="string">&#x27;子&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">bindEvent(body, <span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;父&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="无限下拉的图片列表，如何监听每个图片的点击？"><a href="#无限下拉的图片列表，如何监听每个图片的点击？" class="headerlink" title="无限下拉的图片列表，如何监听每个图片的点击？"></a>无限下拉的图片列表，如何监听每个图片的点击？</h5><hr>
<p>参考：<br><a class="link"   href="https://segmentfault.com/a/1190000013434835" >segment<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zh.javascript.info/event-delegation" >javascript.info<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation" >event.stopPropogation<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events" >事件 MDN<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>web-API</title>
    <url>/2021/04/01/JS/web-API/</url>
    <content><![CDATA[<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM ：（ Document Object Model 文档对象模型），是针对 HTML 和 XML 文档的一个 API 。<br>DOM 描绘了一个<strong>层次化的节点树</strong>，允许开发人员 <strong>增删改查</strong> 页面的某一部分。</p>
<p>attribute：getAttriubte 、 setAttribute 给 HTML 标签元素设置自定义属性<br>property ： dom.style.width 、dom.className 给 HTML 标签的 JS 变量设置属性<br>而 attribute 和 property 的修改，都可能引起 DOM 重新渲染。建议用 property。</p>
<p>nodeName：元素的标签名<br>nodeType: 表明节点类型</p>
<h5 id="DOM-是那种数据结构？"><a href="#DOM-是那种数据结构？" class="headerlink" title="DOM 是那种数据结构？"></a>DOM 是那种数据结构？</h5><p>树型</p>
<h5 id="DOM-操作的常用-API-？"><a href="#DOM-操作的常用-API-？" class="headerlink" title="DOM 操作的常用 API ？"></a>DOM 操作的常用 API ？</h5><p>获取 DOM 节点： getElementById 、getElementsByTagName 、 getElementByClassName 、 querySelectorAll</p>
<p>新增 、插入节点：<br>appendChild：用于向 childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增节点、父节点、以前的最后一个节点的关系指针都会更新。 appendChild() 返回新增的节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> returnNode = someNode.appendChild(newNode)</span><br><span class="line">returnNode === newNode <span class="comment">// true</span></span><br><span class="line">someNode.lastChild === newNode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>同时，如果 newNode 已经是文档中的一部分，那么页面呈现，将是该节点从原来的位置，转移到新的位置</p>
<p>获取子元素列表，获取父元素：<br>获取父元素: dom.parentNode<br>获取子元素列表: dom.childNodes (会把不同 nodeType 的元素 都弄在一起)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> childNodeFilter = <span class="built_in">Array</span>.prototype.slice.call(div.childNods).filter(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> child.nodeType === <span class="number">1</span> <span class="comment">// 过滤只保留标签元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>删除子元素：<br>removeChild:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beremovedTarget = dom.removeChild(dom.firstChild)</span><br></pre></td></tr></table></figure>

<h5 id="attr-和-property-的区别？"><a href="#attr-和-property-的区别？" class="headerlink" title="attr 和 property 的区别？"></a>attr 和 property 的区别？</h5><h5 id="DOM-性能"><a href="#DOM-性能" class="headerlink" title="DOM 性能"></a>DOM 性能</h5><p>DOM 操作昂贵，避免频繁的 DOM 操作<br>对 DOM 查询做缓存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不缓存 DOM 查询</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>).length; i++) &#123;</span><br><span class="line">    <span class="comment">// 每次循环，都会计算 length ，频繁对 DOM 查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存 DOM 查询结果</span></span><br><span class="line"><span class="keyword">const</span> PList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> length = PList.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 缓存 length 只进行一次 DOM 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将频繁操作改为一次性操作:<br>DocumentFragment 是一种轻量型文档（文档片段）。可以当作将要添加到 document 的<strong>节点仓库</strong>来使用。（临时区）<br>如果将 <strong>文档中的节点</strong> 添加到 文档片段中，就会从 文档树 移除该节点，也不会在浏览器看到该节点。<br>appendChild 或者 insertBefore 可以使 文档片段的节点 恢复到 文档树中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listNode = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frag = <span class="built_in">document</span>.createDocumentFragment() <span class="comment">// 文档片段 此时还没插入 DOM 结构中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    list.innerHTML = <span class="string">&#x27;list item &#x27;</span> + i</span><br><span class="line">    frag.appendChild(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listNode.appendChild(frag)</span><br></pre></td></tr></table></figure>

<p>一次性插入多个 DOM 节点，考虑性能</p>
<h3 id="BOM（浏览器对象模型）"><a href="#BOM（浏览器对象模型）" class="headerlink" title="BOM（浏览器对象模型）"></a>BOM（浏览器对象模型）</h3><h5 id="navigator-history-screen-location"><a href="#navigator-history-screen-location" class="headerlink" title="navigator history screen location"></a>navigator history screen location</h5><p>navigator 识别浏览器的标准<br>history 对象保存上网的历史记录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// navigator</span></span><br><span class="line"><span class="keyword">const</span> ua = navigator.userAgent</span><br><span class="line"><span class="keyword">const</span> isChorme = ua.indexOf(<span class="string">&#x27;Chrome&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isChrome)</span><br><span class="line"></span><br><span class="line"><span class="comment">// screen</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.width)</span><br><span class="line"><span class="built_in">console</span>.log(screen.height)</span><br><span class="line"></span><br><span class="line"><span class="comment">// history</span></span><br><span class="line">history.go(-<span class="number">1</span>) <span class="comment">// 参数为负数则是 后退多少页</span></span><br><span class="line">history.go(<span class="number">2</span>) <span class="comment">// 参数为正数则是 前进多少页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟浏览器前进后退</span></span><br><span class="line">history.forward() <span class="comment">// 前进</span></span><br><span class="line">history.back() <span class="comment">// 后退</span></span><br><span class="line"></span><br><span class="line">history.length === <span class="number">0</span> <span class="comment">// 页面是否为用户新打开的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// location</span></span><br><span class="line"><span class="built_in">window</span>.location === <span class="built_in">document</span>.location <span class="comment">// true</span></span><br><span class="line">location.href === location.toString()</span><br><span class="line"><span class="comment">// url: https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction?q=1#%E4%BB%80%E4%B9%88%E6%98%AF_dom</span></span><br><span class="line"><span class="built_in">console</span>.log(location.href) <span class="comment">// 页面完整 url https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction?q=1#%E4%BB%80%E4%B9%88%E6%98%AF_dom</span></span><br><span class="line"><span class="built_in">console</span>.log(location.protocal) <span class="comment">// https:</span></span><br><span class="line"><span class="built_in">console</span>.log(location.pathname) <span class="comment">// /zh-CN/docs/Web/API/Document_Object_Model/Introduction</span></span><br><span class="line"><span class="built_in">console</span>.log(location.search) <span class="comment">// &#x27;?q=1&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(location.hash) <span class="comment">// #%E4%BB%80%E4%B9%88%E6%98%AF_dom</span></span><br></pre></td></tr></table></figure>

<h5 id="如何识别浏览器的类型"><a href="#如何识别浏览器的类型" class="headerlink" title="如何识别浏览器的类型"></a>如何识别浏览器的类型</h5><h5 id="查询-url-字符串参数"><a href="#查询-url-字符串参数" class="headerlink" title="查询 url 字符串参数"></a>查询 url 字符串参数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">var</span> getUrlParam = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(^|&amp;)&quot;</span> + name + <span class="string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>);</span><br><span class="line">         <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">         <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">decodeURI</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getUrlParam(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> key</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">var</span> qs = location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> arr = qs.length ? qs.split(<span class="string">&#x27;&amp;&#x27;</span>) : []</span><br><span class="line">    <span class="keyword">const</span> length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = arr[i].split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(item)</span><br><span class="line">        key = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>])</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>])</span><br><span class="line">        key.length &amp;&amp; args[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getQueryStringArgs()[<span class="string">&#x27;q&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><p>XMLHttpRequest：<br>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p>
<p>readyState: </p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">状态</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">UNSENT</td>
<td align="left">代理被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">OPENED</td>
<td align="left">open() 方法已经被调用。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">HEADERS_RECEIVED</td>
<td align="left">send() 方法已经被调用，并且头部和状态已经可获得。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">LOADING</td>
<td align="left">下载中；responseText 属性已经包含部分数据。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DONE</td>
<td align="left">下载操作已完成。</td>
</tr>
</tbody></table>
<!-- 0  UNSENT               代理被创建，但尚未调用 open() 方法。
1  OPENED               open() 方法已经被调用。
2  HEADERS_RECEIVED     send() 方法已经被调用，并且头部和状态已经可获得。
3  LOADING              下载中；responseText 属性已经包含部分数据。
4  DONE                 下载操作已完成。 -->

<p>状态码：( xhr.status )</p>
<ul>
<li>2XX: 表示成功处理请求，如 200</li>
<li>3XX: 需要重定向，浏览器直接跳转，如 301 302 304</li>
<li>4XX: 客户端请求错误，如 404 403</li>
<li>5XX：服务器端错误</li>
</ul>
<p>同源：同源策略，跨域解决方案</p>
<p>同源策略仅限浏览器</p>
<ul>
<li>ajax 请求时，浏览器要求<strong>当前网页</strong> 和 <strong>server</strong> 必须同源（安全）</li>
<li>同源：协议、域名、端口，三者必须一致<br>eg: 前端：<a class="link"   href="http://a.com:8080/" >http://a.com:8080/<i class="fas fa-external-link-alt"></i></a> , server: <a class="link"   href="https://b.com/api/xxx" >https://b.com/api/xxx<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>加载 img JS CSS 无视 同源策略：（ img src \ link href \ script src ）</p>
<ul>
<li>img 可以做防盗链（服务器做）</li>
<li>img 可以做统计打点，使用第三方统计服务</li>
<li>link script 可使用 CDN CDN 一般是外链</li>
<li>script 可使用 JSONP</li>
</ul>
<p>跨域：</p>
<ul>
<li>所有的跨域，都必须经过 server 端允许和配合</li>
<li>未经 server 端允许就实现跨域，说明 浏览器 有漏洞，危险信号</li>
</ul>
<p>JSONP：</p>
<ul>
<li><p>访问 <a class="link"   href="https://imooc.com/%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E5%AE%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA" >https://imooc.com/，服务端一定返回一个<i class="fas fa-external-link-alt"></i></a> html 文件吗？<br>不一定。服务器可以任意动态拼接数据返回，只要符合 html 格式要求<br>同理于 <script src="https://imooc.com/getData.js"></script></p>
</li>
<li><p>script 跨域特性：<br>script 可绕过跨域限制<br>服务器可以任意动态拼接数据返回<br>所以，script 就可以获得跨域的数据，只要服务端愿意返回<br>一般 script 用在 JSONP ，都是动态创建</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">script.src = <span class="string">&#x27;http://free.net/json/?callback=handleResponse&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild)</span><br></pre></td></tr></table></figure>

<p>下面的代理，服务器代理返回了 obj 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jsonp.js</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">abc(obj)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.abc = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8002/jsonp.js?username=xxx&amp;callback=abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>jQuery 实现 JSONP：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:8082/x-orgin.json&#x27;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">    <span class="attr">jsonpCallback</span>: <span class="string">&#x27;callback&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>CORS：（服务器支持）</p>
<ul>
<li>服务器设置 http header<br>如果设置了，ajax 就可以直接跨域请求<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://localhost:8000&#x27;</span>) <span class="comment">// 不建议 *</span></span><br><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Requested-With&#x27;</span>)</span><br><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cookie</span></span><br><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="简易的-Ajax"><a href="#简易的-Ajax" class="headerlink" title="简易的 Ajax"></a>简易的 Ajax</h5></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api&quot;</span>, <span class="literal">true</span>) <span class="comment">// true 是异步 false 是同步</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步模块</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            alert(xhr.reponseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;其他情况&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>) <span class="comment">// XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise 版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readystate === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.status === <span class="number">404</span>) &#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;404 not found&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/data/test.json&#x27;</span></span><br><span class="line">ajax(url)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="跨域的常见方式"><a href="#跨域的常见方式" class="headerlink" title="跨域的常见方式"></a>跨域的常见方式</h5><ul>
<li>JSONP </li>
<li>CORS</li>
</ul>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" >MDN 定义<i class="fas fa-external-link-alt"></i></a><br>返回 promise<br>语法更简洁<br>不兼容 IE</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>cookie 、localStorage 、 sessionStorage</p>
<h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>cookie 本身用于浏览器 和 server 通讯，可以用 document.cookie 来修改</p>
<p>cookie 缺点：</p>
<ul>
<li>API 修改方式太过蹩脚</li>
<li>存储大小 最大 4KB</li>
<li>http 请求时需要发送到服务端，增加请求数据量</li>
</ul>
<h5 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h5><p>HTML5 专门为存储 设计，最大可存 5M<br>API 简单易用 getItem setItem<br>不会随着 http 请求，被发送出去<br>永久存储</p>
<h5 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h5><p>HTML5 专门为存储 设计，最大可存 5M<br>API 简单易用 getItem setItem<br>不会随着 http 请求，被发送出去<br>只存储在当前会话，关闭标签页则清空</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>开发界面，调用后端接口，提交 获取数据 - http 协议</p>
<p>review：</p>
<h5 id="http-常见的状态码有哪些"><a href="#http-常见的状态码有哪些" class="headerlink" title="http 常见的状态码有哪些"></a>http 常见的状态码有哪些</h5><ul>
<li><p>归类：<br>1XX 服务器收到请求<br>2XX 请求成功 如200<br>3XX 重定向 如 302<br>4XX 客户端错误 如 404<br>5XX 服务端错误 如 500</p>
</li>
<li><p>常见的：<br>200 成功<br>301 永久重定向 （ 配合 Response Headers 的 location 字段 ，浏览器自动处理）：域名到期 ，下次自动重定向到新域名 结合 百度第一次打开其他网站来看 NetWork<br>302 临时重定向 （ 配合 Response Headers 的 location 字段 ，浏览器自动处理）<br>304 资源未被修改 资源请求过，已缓存下来，在服务器端也认为是最新的，没必要再请求<br>404 资源未找到<br>403 没权限<br>500 服务器错误<br>504 网关超时 </p>
</li>
</ul>
<h5 id="http-常见的-header-有哪些？"><a href="#http-常见的-header-有哪些？" class="headerlink" title="http 常见的 header 有哪些？"></a>http 常见的 header 有哪些？</h5><ul>
<li><p>Request Headers:<br>Accept 浏览器可接收的数据格式<br>Accept-Encoding 浏览器可接收的压缩算法 ，如 gzip<br>Accept-language 浏览器接收语言<br>Connection: kee-alive 一次 TCP 连接重复使用<br>Cookie<br>Host: 请求的域名<br>User-Agent 浏览器信息<br>Content-type 发送数据的格式 如 application/json</p>
</li>
<li><p>Response Headers:<br>Content-type 返回数据的格式 如 application/json<br>Content-length 返回数据的大小 多少字节<br>Content-Encoding 返回数据的压缩算法<br>cross-origin-resource-policy: cross-origin</p>
</li>
<li><p>自定义 Header：用于验证特殊接口</p>
</li>
<li><p>缓存类的 Headers：<br>Cache-Control<br>Expires<br>Last-Modified<br>If-Modified-Since<br>Etag<br>If-None-Match</p>
</li>
</ul>
<h5 id="什么是-Restful-API？"><a href="#什么是-Restful-API？" class="headerlink" title="什么是 Restful API？"></a>什么是 Restful API？</h5><ul>
<li>http methods：<br>传统的：get 获取 服务器数据 ，post 提交数据到 服务器<br>现在的：get 获取数据 ，post 新建数据， patch / put 更新数据， delete 删除数据</li>
</ul>
<p>传统的 API 设计：把每个 url 当做一个功能 ( 重要 )</p>
<ul>
<li>Restful API ：<br>是 一种新的 API 设计方法（ 早已推广使用 ）<br>把每个 url 当作一个唯一的资源 ( 重要 )</li>
</ul>
<h5 id="如何设计一个资源？"><a href="#如何设计一个资源？" class="headerlink" title="如何设计一个资源？"></a>如何设计一个资源？</h5><p>尽量不用 url 参数<br>传统 API 设计： /api/list?pageIndex=2<br>Restful API 设计：/api/list/2</p>
<ul>
<li><p>用 method 表示操作类型<br>传统 API ：<br>post ： /api/create-blog<br>post ： /api/update-blog?id=100<br>get  ： /api/get-blog?id=100</p>
</li>
<li><p>Restful：<br>post:  /api/blog<br>patch: /api/blog/100<br>get:   /api/blog/100</p>
</li>
</ul>
<h5 id="描述一下-http-的缓存机制（-重要-）"><a href="#描述一下-http-的缓存机制（-重要-）" class="headerlink" title="描述一下 http 的缓存机制（ 重要 ）"></a>描述一下 http 的缓存机制（ 重要 ）</h5><ul>
<li><p>关于缓存，为什么需要缓存<br>网络请求 速度 和 不稳定（ 地域或环境 ），已经成为目前计算机优秀 CPU 算力和 优秀渲染引擎的 短板，有必要进行缓存，减少请求的体积，让页面加载的更快。</p>
</li>
<li><p>哪些资源需要缓存？<br>静态资源：JS CSS Img（ 哈希后缀 ）<br>可结合 打包工具 webpack 输出哈希</p>
</li>
<li><p>缓存策略 （ 强制缓存 + 协商缓存 ）<br>强制缓存：<br>Response Headers中，</p>
</li>
</ul>
<p> Cache-Control：max-age=31536000 ( 单位是秒 ) 最大缓存一年<br>    除了 max-age<br>    还有 no-cache 指定 no-cache 或 max-age=0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。<br>    no-store 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。<br>    private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。<br>    public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS文件和JavaScript文件。</p>
<p> 初次请求，返回资源和 Cache-Control。</p>
<p> 如果还在 Cache-Control 控制时间内，浏览器再次请求，会直接从 <strong>本地缓存</strong> 中请求，返回资源。</p>
<p>缓存失效，会再次请求服务端，返回资源 和 Cache-Control。</p>
<p>Expires： 也是控制缓存过期，后 被 Cache-control代替</p>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" >MDN Cache-Control<i class="fas fa-external-link-alt"></i></a></p>
<p>（1）协商缓存：<br>服务端 缓存策略<br>服务端 判断客户端资源 ，是否和服务端资源一样<br>一致则返回 304 ，否则返回 200 和 最新资源</p>
<p>浏览器初次请求服务端，返回资源和资源标识。<br>再次请求，带着资源标识，返回304，或返回资源和新的资源标识。</p>
<p>（2）资源标识：<br>在 Response Headers 中，有两种：Last-Modified 和 Etag</p>
<p>优先使用 Etag 精确到 毫秒</p>
<p>Last-Modified 资源的最后修改时间 精确到 秒</p>
<p>初次请求，返回资源和 Last-Modified<br>再次请求，Req Headers 带着 If-Modified-Since，<br>服务器判断是不是一样，304，否则返回资源 和 新的 Last-Modified</p>
<p>Etag 资源的唯一标识 （ 一个字符串，类似人类的指纹 ）<br>初次请求，返回资源和 Etag<br>再次请求，Req Headers 带着 If-None-Match，<br>服务器判断是不是一样，304，否则返回资源 和 新的 Etag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/Http%E7%BC%93%E5%AD%98.webp"
                      alt="Http缓存"
                ></p>
<ul>
<li>刷新操作方式，对缓存的影响<br>正常操作：地址栏输入 url，跳转链接，前进后退等：<br>强制缓存有效，协商缓存有效</li>
</ul>
<p>手动刷新：F5 点击刷新 右击菜单刷新<br>强制缓存失效，协商缓存有效</p>
<p>强制刷新：Ctrl + F5<br>强制缓存失效，协商缓存失效</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器异步（三）</title>
    <url>/2020/07/18/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BPromise%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>此篇博文转载自瓶子君的blog <a class="link"   href="https://github.com/sisterAn/blog/issues/13" >链接<i class="fas fa-external-link-alt"></i></a>，并加以自己的理解和注释。</p>
</blockquote>
<h3 id="Promise本质"><a href="#Promise本质" class="headerlink" title="Promise本质"></a>Promise本质</h3><p><strong>Promise就是为了解决callback的问题而产生的。</strong></p>
<p>Promise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。</p>
<p><strong>开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转</strong>。</p>
<p>我们把上面那个多层回调嵌套的例子用Promise的方式重构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getPromise1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;XXX1&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">let</span> key = data;</span><br><span class="line">               resolve(key);         </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getPromise2 = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;XXX2&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                <span class="attr">key</span>: key</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getPromise3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;XXX3&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getPromise1()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPromise2(key);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPromise3(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;业务数据：&#x27;</span>, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure>

<p>Promise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。</p>
<p>所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。</p>
<h3 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h3><p>Promise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，<strong>它是一种规范，是一套处理JavaScript异步的机制</strong>。</p>
<p>Promise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：</p>
<ul>
<li>英文版：<a class="link"   href="https://promisesaplus.com/" >Promise/A+<i class="fas fa-external-link-alt"></i></a></li>
<li>翻译版：<a class="link"   href="http://www.ituring.com.cn/article/66566" >【翻译】Promises/A+规范<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>这里只简要介绍下几点与接下来内容相关的规范：</p>
<ul>
<li>Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。</li>
<li>then 方法可以被同一个 promise 调用多次。</li>
<li>then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise</li>
<li>值穿透</li>
</ul>
<h3 id="Promise-实现及源码解读"><a href="#Promise-实现及源码解读" class="headerlink" title="Promise 实现及源码解读"></a>Promise 实现及源码解读</h3><p>首先，我们看一下Promise的简单使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do an async task async task and then...</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* good condition */</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Failure!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* do something with the result */</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* error :( */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们通过这种使用构建Promise实现的第一个版本</p>
<p><strong>自己的写法也是结合调用实例的逆推过程</strong>。</p>
<p>为什么要将callback单独传入呢？因为啊，new Promise(… ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。</p>
<h4 id="Promise构建版本一"><a href="#Promise构建版本一" class="headerlink" title="Promise构建版本一"></a>Promise构建版本一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="keyword">var</span> onResolvedCallback  <span class="comment">// Promise resolve回调函数</span></span><br><span class="line">    <span class="keyword">var</span> onRejectedCallback  <span class="comment">// Promise reject回调函数</span></span><br><span class="line">    <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        onResolvedCallback()</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// reject 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        onRejectedCallback()</span><br><span class="line">    &#125; </span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。</p>
<h4 id="Promise构建之二：链式存储"><a href="#Promise构建之二：链式存储" class="headerlink" title="Promise构建之二：链式存储"></a>Promise构建之二：链式存储</h4><p>链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。</p>
<p>首先，举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b=<span class="number">2</span>;</span><br><span class="line">            resolve(b);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c=<span class="number">3</span></span><br><span class="line">            resolve(c);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上例结果是每间隔1s打印一个数字，顺序为1、2、3。</p>
<p>这里保证了：</p>
<ul>
<li>让a,b,c的值能在then里面的回调接收到</li>
<li>在连续调用异步，如何确保异步函数的执行顺序</li>
</ul>
<p>Promise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用<code>setTimeout</code>来处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行</span></span><br><span class="line">            _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行</span></span><br><span class="line">            _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之三：状态机制、顺序执行"><a href="#Promise构建之三：状态机制、顺序执行" class="headerlink" title="Promise构建之三：状态机制、顺序执行"></a>Promise构建之三：状态机制、顺序执行</h4><p>为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            	_this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            	_this.value = value</span><br><span class="line">            	_this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之四：递归执行"><a href="#Promise构建之四：递归执行" class="headerlink" title="Promise构建之四：递归执行"></a>Promise构建之四：递归执行</h4><p>每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.</p>
<p>当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            	_this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            	_this.value = value</span><br><span class="line">            	_this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之五：异常处理"><a href="#Promise构建之五：异常处理" class="headerlink" title="Promise构建之五：异常处理"></a>Promise构建之五：异常处理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            	_this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            	_this.value = value</span><br><span class="line">            	_this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="comment">// new Promise(() =throw Error(&#x27;error&#x27;))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之六：then的实现"><a href="#Promise构建之六：then的实现" class="headerlink" title="Promise构建之六：then的实现"></a>Promise构建之六：then的实现</h4><p>then 方法是 Promise 的核心，这里做一下详细介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）</p>
<ul>
<li>onFulfilled 特性：<ul>
<li>当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值</li>
<li>在 Promise 执行结束前不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
<li>onRejected 特性<ul>
<li>当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值</li>
<li>在 Promise 执行结束前不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
<li>调用时机<br><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a class="link"   href="http://es5.github.io/#x10.3" >执行环境<i class="fas fa-external-link-alt"></i></a>堆栈仅包含<strong>平台代码</strong>时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）</li>
<li>调用要求<br><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值，在 <strong>严格模式（strict）</strong> 中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。）</li>
<li>多次调用<br><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次<ul>
<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>
<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>
</ul>
</li>
<li>返回<br><code>then</code>方法会返回一个<code>Promise</code>，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise(<a class="link"   href="https://promisesaplus.com/differences-from-promises-a#point-5" >详情<i class="fas fa-external-link-alt"></i></a>)对象，所以在我们的实现中，也让then返回一个新的Promise对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>



<ul>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li>
<li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li>
<li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的拒因</li>
</ul>
<strong>不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected</strong>。<br>每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。</li>
</ul>
<p>下面代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附：值穿透解读</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到值穿透，值穿透即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> MyPromise((resolve, reject) =&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(() =&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="string">&#x27;2&#x27;</span>).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>

<p>最终打结果是<code>1</code>而不是<code>2</code></p>
<p>再例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(resolve =resolve(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">    .then()</span><br><span class="line">    .then()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        alert(value)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// output: alert 出 1</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>return this</code> 只实现了值穿透的一种情况，其实值穿透有两种情况：</p>
<ol>
<li>promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(() =&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&#123;</span><br><span class="line">    promise.then().then((res) =&#123; <span class="comment">// 状况A</span></span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    promise.catch().then((res) =&#123; <span class="comment">// 状况B</span></span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(promise.then() === promise.catch()) <span class="comment">// output: true</span></span><br><span class="line">    <span class="built_in">console</span>.log(promise.then(<span class="number">1</span>) === promise.catch(&#123;<span class="attr">name</span>: <span class="string">&#x27;anran&#x27;</span>&#125;)) <span class="comment">// output: true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 <code>return this</code>。<br>注意：原生的Promise实现里并不是这样实现的，会打印出两个false</li>
<li>promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve) =&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(() =&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = promise.then()</span><br><span class="line">a.then((res) =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> b = promise.catch()</span><br><span class="line">b.then((res) =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>Promise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。</p>
<p>根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果promise1被resolve了，promise2的被<code>1</code>resolve，如果promise1 被reject了，promise2将被<code>new Error(&#39;error&#39;)</code>reject。</p>
<p>所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为<code>x</code>）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class="line">        <span class="comment">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line">      		<span class="comment">// 所以用了 setTimeout 包裹下</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                	<span class="comment">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class="line">                	<span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    	x.then(resolve, reject)</span><br><span class="line">                	&#125;</span><br><span class="line">                	resolve(x) <span class="comment">// 否则，以它的返回值为 promise2 的结果</span></span><br><span class="line">            	&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                	reject(err) <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                	<span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                    	x.then(resolve, reject)</span><br><span class="line">                	&#125;</span><br><span class="line">            	&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                	reject(err)</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class="line">        <span class="comment">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class="line">        <span class="comment">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内</span></span><br><span class="line">        <span class="comment">// 处理逻辑和以上相似</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            _this.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            _this.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之七：catch的实现"><a href="#Promise构建之七：catch的实现" class="headerlink" title="Promise构建之七：catch的实现"></a>Promise构建之七：catch的实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch 的实现</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们大致实现了Promise标准中所涉及到的内容。</p>
<h4 id="Promise构建之八：问题补充：无缝调用"><a href="#Promise构建之八：问题补充：无缝调用" class="headerlink" title="Promise构建之八：问题补充：无缝调用"></a>Promise构建之八：问题补充：无缝调用</h4><p>不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// ES6 的 Promise</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.all([ <span class="comment">// Q 的 Promise</span></span><br><span class="line">        <span class="keyword">new</span> MyPromise(resolve =resolve(<span class="string">&#x27;3&#x27;</span>)) <span class="comment">// 我们实现的Promise</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>.eresolve(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// ES6 的 Promise</span></span><br><span class="line">        Q.resolve(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// Q 的 Promise</span></span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。</p>
<p>接下来，我们解决这个问题</p>
<p>关于不同Promise之间的交互，其实<a class="link"   href="https://promisesaplus.com/#point-46" >Promise/A+标准<i class="fas fa-external-link-alt"></i></a>中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。</p>
<p>即我们要<strong>把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象</strong>，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。</p>
<p>而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。</p>
<p>关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规范 2.3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class="line"><span class="comment">也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class="line"><span class="comment">x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class="line"><span class="comment">resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class="line"><span class="comment">相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规范 2.3.2</span></span><br><span class="line">    <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class="line">        <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">                <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">                <span class="comment">// 把值传给下个 then</span></span><br><span class="line">                resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class="line">            <span class="comment">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then</span><br><span class="line">            <span class="comment">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">    			<span class="comment">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    y =&#123; <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                        called = <span class="literal">true</span></span><br><span class="line">                        <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                        <span class="keyword">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    r =&#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                        called = <span class="literal">true</span></span><br><span class="line">                         <span class="keyword">return</span> reject(r)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 规范 2.3.3.2</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们使用<code>resolutionProcedure</code>函数替换<code>MyPromise.prototype.then</code>里面几处判断x是否为MyPromise对象的位置即可。即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve(x) // 否则，以它的返回值为 promise2 的结果</span></span><br></pre></td></tr></table></figure>

<p>替换为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolutionProcedure(promise2, x, resolve, reject)</span><br></pre></td></tr></table></figure>

<p>总共四处，不要遗漏了</p>
<h4 id="Promise构建九：完整代码实现"><a href="#Promise构建九：完整代码实现" class="headerlink" title="Promise构建九：完整代码实现"></a>Promise构建九：完整代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 Promise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(() =&#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(() =&#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="comment">// new Promise(() =throw Error(&#x27;error&#x27;))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class="line">        <span class="comment">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                <span class="comment">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class="line">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                reject(err) <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class="line">        <span class="comment">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class="line">        <span class="comment">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内</span></span><br><span class="line">        <span class="comment">// 处理逻辑和以上相似</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            _this.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            _this.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范 2.3</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class="line"><span class="comment">    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class="line"><span class="comment">    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class="line"><span class="comment">    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class="line"><span class="comment">    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 规范 2.3.2</span></span><br><span class="line">        <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class="line">            <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">                x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">                    <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">                    <span class="comment">// 把值传给下个 then</span></span><br><span class="line">                    resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">                &#125;, reject)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class="line">                x.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class="line">                <span class="comment">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class="line">                <span class="keyword">let</span> then = x.then</span><br><span class="line">                <span class="comment">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">                    <span class="comment">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class="line">                    then.call(</span><br><span class="line">                        x,</span><br><span class="line">                        y =&#123; <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                            called = <span class="literal">true</span></span><br><span class="line">                            <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                            <span class="keyword">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        r =&#123;</span><br><span class="line">                            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                            called = <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">return</span> reject(r)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 规范 2.3.3.2</span></span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                called = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">            resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch 的实现</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// finally 的实现</span></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(callback()).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(callback()).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>额外，附加 <code>Promise.race</code> 与 <code>Promise.all</code> 的实现，有兴趣的可以了解一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// race</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            MyPromise.resolve(value).then(resolve, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// all</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">        <span class="keyword">var</span> remaining = args.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            res(i, args[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">res</span>(<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise &amp;&amp; val.then === MyPromise.prototype.then) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val.currentState === RESOLVED) <span class="keyword">return</span> res(i, val.value)</span><br><span class="line">                    <span class="keyword">if</span> (val.currentState === REJECTED) reject(val.value)</span><br><span class="line">                    val.then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                        res(i, val)</span><br><span class="line">                    &#125;, reject)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> then = val.then</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(then.bind(val))</span><br><span class="line">                        p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">                            res(i, val)</span><br><span class="line">                        &#125;, reject)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args[i] = val</span><br><span class="line">            <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">                resolve(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。</p>
<p>void是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。</p>
<p>setTimeout 如果不传时间，默认取0。</p>
<p>“参考”</p>
<p><a class="link"   href="https://segmentfault.com/q/1010000009781257" >promise取消的一些讨论<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>Promise 工具</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器异步（二）</title>
    <url>/2020/07/18/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载自瓶子君的blog <a class="link"   href="https://github.com/sisterAn/blog/issues/12" >链接<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h3 id="step1：回调函数callback"><a href="#step1：回调函数callback" class="headerlink" title="step1：回调函数callback"></a>step1：回调函数callback</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">asyncFunction(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Time out&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>其中，我们称<code>setTimeout</code>为发起函数，<code>fn</code>为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行<code>setTimeout</code>1s后，执行function函数。</p>
<p>下面，我们再看一种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;XXX1&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&#x27;XXX2&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    <span class="attr">url</span>: <span class="string">&#x27;XXX3&#x27;</span>,</span><br><span class="line">                    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// todo</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。</p>
<p><strong>问题1: 回调地狱</strong></p>
<p>回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。</p>
<p>主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。</p>
<p>再例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p>A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。</p>
<p>但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。</p>
<p>这种情况称为<strong>控制反转</strong>，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。</p>
<p>既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：</p>
<ol>
<li>调用回调过早</li>
<li>调用回调过晚</li>
<li>调用回调次数太多或者太少</li>
<li>未能把所需的参数成功传给你的回调函数</li>
<li>吞掉可能出现的错误或异常</li>
<li>……</li>
</ol>
<p>这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。</p>
<p>这里，我们引出了回调函数处理异步的第二个问题：<strong>控制反转</strong>。</p>
<h3 id="step2：控制反转"><a href="#step2：控制反转" class="headerlink" title="step2：控制反转"></a><strong>step2：控制反转</strong></h3><p>综上，回调函数处理异步流程存在2个问题：</p>
<p><strong>1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</strong></p>
<p><strong>2. 缺乏可信任性： 控制反转导致的一系列信任问题</strong></p>
<p>那么如何来解决这两个问题，先驱者们开始了探索之路……</p>
<hr>
<p>参考：<br><a class="link"   href="https://github.com/sisterAn/blog/issues/12" >瓶子君 blog<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/2021/07/13/JS/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<ul>
<li>从定义来讲，类型转换，就是将值从一种类型转为另一个种类型（<strong>显式转换</strong>）。<br>另外还有一种<strong>隐式的转换</strong>，也成为强制类型转换。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&#x27;&#x27;</span> <span class="comment">// 隐式强制类型转换</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">String</span>(a) <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">100</span> + <span class="number">10</span> <span class="comment">// 110</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span> + <span class="string">&#x27;10&#x27;</span> <span class="comment">// &#x27;10010&#x27;</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">true</span> + <span class="string">&#x27;10&#x27;</span> <span class="comment">// &#x27;true10&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">&#x27;100&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建议：除了 == null 外，其他都用 === ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  obj = &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (obj.a == <span class="literal">null</span>) &#123;&#125; <span class="comment">// 相当于 obj.a === null || obj.a === undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="if-语句和逻辑运算"><a href="#if-语句和逻辑运算" class="headerlink" title="if 语句和逻辑运算"></a>if 语句和逻辑运算</h3><p>!!转换符 可以取到 该值的布尔值</p>
<p>以下都是 falsely 变量。除此之外，都是 truly 变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!!<span class="number">0</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">NaN</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">null</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">undefined</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">false</span> === <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>注意：!!{} 是 true 、 !![] 是 true</p>
<h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> &amp;&amp; <span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">0</span> &amp;&amp; <span class="number">10</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;abc&#x27;</span> <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line">!<span class="built_in">window</span>.abc <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>ES5规范，定义了部分转换规则：（ ToString 、 ToNumber、ToBoolean、 ToOrimitive ）</p>
</blockquote>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString:"></a>ToString:</h3><p>(1) 基本类型：<br>null =&gt; ‘null’ 、 undefined =&gt; ‘undefined’ 、 true =&gt; ‘true’ 、 2 =&gt; ‘2’<br>(2) 极小值和极大值单独处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1.07</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">a.toString() <span class="comment">// 1.07e21</span></span><br></pre></td></tr></table></figure>
<p>(3) 对象:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(4) 数组：<br>数组的 toString ，将所有单元字符串化，然后用’,’连接起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.toString() === <span class="string">&#x27;1,2,3&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(5) JSON.stringify()<br>分为对象 和 数组的不同处理 ：<br>对象时，会忽略 undefined function symbol<br>数组时，会把 undefined function symbol 转为 null</p>
<p>不能处理包含循环引用的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( [<span class="number">1</span>,<span class="literal">undefined</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="number">4</span>] ) <span class="comment">// &#x27;[1,null,null,4]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; ) <span class="comment">// &#x27;&#123;&quot;a&quot;:2&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>额外知识：<br>我们可以向 JSON.stringify(..) 传递一个可选参数 replacer， 它可以是数组或者函数， 用 来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除.<br>如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象 的属性名称，除此之外其他的属性则被忽略。</p>
<p>如果 replacer 是一个函数， 它会对对象本身调用一次， 然后对对象中的每个属性各调用 一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined ，否则返回指定 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&quot;42&quot;</span>,</span><br><span class="line">    <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">JSON</span>.stringify( a, [<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>] ) <span class="comment">// &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a, <span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;  <span class="comment">// &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">&quot;c&quot;</span>) <span class="keyword">return</span> v;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>true =&gt; 1 、false =&gt; 0 、 undefined =&gt; NaN 、 null =&gt; 0<br>处理对象、数组，会看处理值，是否内部有 valueOf() 方法，有则调用并返回基本类型值，使用该值进行强制类型转换<br>没有则使用 toString() 的返回值来进行强制类型转换。<br>如果这两个方法都没返回基本类型值，会产生 TypeError 错误。</p>
<h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><p>以下这些是假值：<br>• undefined<br>• null<br>• false<br>• +0 、 -0 和 NaN<br>• “”</p>
<p>推荐使用 Boolean() 和 !! 来显示转换布尔值。</p>
<p>顺路说一条parseInt的奇特题目：<br>[1,2,3].map(parseInt) // [1, NaN, NaN]</p>
<p>parseInt api 和 map api都要了解，才能正确解答此题。</p>
<p>参考:<br><a class="link"   href="https://segmentfault.com/a/1190000015895317" >segmentFault parseInt题解析<i class="fas fa-external-link-alt"></i></a><br>(你不知道的js《中卷》)[]</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器异步（一）</title>
    <url>/2020/07/17/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>注： 转载瓶子君文章 <a class="link"   href="https://github.com/sisterAn/blog/issues/11" >详细连接<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。</p>
<h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-浏览器是多进程的"><a href="#1-浏览器是多进程的" class="headerlink" title="1. 浏览器是多进程的"></a>1. 浏览器是多进程的</h4><p>它主要包括以下进程：</p>
<ul>
<li>Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li>
<li>GPU 进程：用于 3D 绘制等，最多一个。</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li>
<li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li>
</ul>
<h4 id="2-渲染进程（浏览器内核）"><a href="#2-渲染进程（浏览器内核）" class="headerlink" title="2. 渲染进程（浏览器内核）"></a>2. 渲染进程（浏览器内核）</h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：</p>
<ul>
<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li>
<li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li>
<li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li>
<li>定时触发器线程：传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms 。</li>
<li>异步 http 请求线程：在 <code>XMLHttpRequest</code> 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>
</ul>
<p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时</strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h3 id="二、单线程的-JavaScript"><a href="#二、单线程的-JavaScript" class="headerlink" title="二、单线程的 JavaScript"></a>二、单线程的 JavaScript</h3><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p>
<p><strong>问题：首先为什么要引入单线程？</strong></p>
<p>我们知道：</p>
<ul>
<li>浏览器需要渲染 DOM</li>
<li>JavaScript 可以修改 DOM 结构</li>
<li>JavaScript 执行时，浏览器 DOM 渲染停止</li>
</ul>
<p>如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p>
<p>你可能会说，<a class="link"   href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" >web worker<i class="fas fa-external-link-alt"></i></a> 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p>
<p><strong>原因：避免 DOM 渲染的冲突</strong></p>
<p>当然，我们可以为浏览器引入<strong>锁</strong> 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。</p>
<p>引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例1</span></span><br><span class="line"><span class="keyword">let</span> i, sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i ++) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>

<p>在实例1中，<code>sum</code> 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 <code>console.log(sum)</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">alert(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在实例2中，浏览器先打印 <code>1</code> ，然后弹出弹框，点击确定后才执行 <code>console.log(2)</code> 。</p>
<p><strong>总结：</strong></p>
<ul>
<li>优点：实现比较简单，执行环境相对单纯</li>
<li>缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>
</ul>
<p>为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步</p>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func(args...)</span><br></pre></td></tr></table></figure>

<p>如果在函数 <code>func</code> 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">Math</span>.floor(a)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-异步"><a href="#2-异步" class="headerlink" title="2. 异步"></a>2. 异步</h4><p>如果在函数 <code>func</code> 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>JavaScript 采用异步编程原因有两点，</p>
<ul>
<li>一是 JavaScript 是单线程；</li>
<li>二是为了提高 CPU 的利用率。</li>
</ul>
<h3 id="四、异步过程"><a href="#四、异步过程" class="headerlink" title="四、异步过程"></a>四、异步过程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在执行这段代码时，<code>fs.readFile</code> 函数返回时，并不会立刻打印 <code>data</code> ，只有 <code>data.json</code> 读取完成时才打印。也就是异步函数 <code>fs.readFile</code> 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。</p>
<p>主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。</p>
<p>工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。</p>
<h3 id="五、消息队列与事件循环"><a href="#五、消息队列与事件循环" class="headerlink" title="五、消息队列与事件循环"></a>五、消息队列与事件循环</h3><p>工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。</p>
<ul>
<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>
<li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>
</ul>
<h4 id="1-事件循环（eventloop）"><a href="#1-事件循环（eventloop）" class="headerlink" title="1. 事件循环（eventloop）"></a>1. 事件循环（eventloop）</h4><p>主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。</p>
<p>大致实现过程如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = queue.get()</span><br><span class="line">    execute(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// output：4321 或 4312</span></span><br></pre></td></tr></table></figure>

<p>其中，主线程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>异步队列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 100ms后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ajax加载完成之后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。</strong></p>
<h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h4><p>其中，消息就是注册异步任务时添加的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(<span class="string">&#x27;XXX&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 <code>XXX</code>，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息队列里的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>callback</code> 是 AJAX 网络请求成功响应时的回调函数。</p>
<p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 <code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code>通知</code> ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67"
                     
                ></p>
<p>异步过程中的回调函数，<strong>一定不在当前这一轮事件循环中执行</strong>。</p>
<h3 id="六、异步与事件"><a href="#六、异步与事件" class="headerlink" title="六、异步与事件"></a>六、异步与事件</h3><p>消息队列中的每条消息实际上都对应着一个事件。</p>
<p>其中一个重要的异步过程就是： <strong>DOM事件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">button.addEventLister(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;事件&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从异步的角度看，<code>addEventLister</code> 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。</p>
<p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</p>
<p>另外，所有的异步过程也都可以用事件来描述。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(func, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 可以看成：</span></span><br><span class="line">timer.addEventLister(<span class="string">&#x27;timeout&#x27;</span>, <span class="number">1000</span>, func)</span><br></pre></td></tr></table></figure>

<p>其中关于事件的详细描述，可以看这篇文章： <a class="link"   href="http://blog.xieliqun.com/2016/08/12/event-delegate/" >事件绑定、事件监听、事件委托<i class="fas fa-external-link-alt"></i></a>，这里不再深入介绍。</p>
<h3 id="七、生产者与消费者"><a href="#七、生产者与消费者" class="headerlink" title="七、生产者与消费者"></a>七、生产者与消费者</h3><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966"
                     
                ></p>
<p>从生产者与消费者的角度看，异步过程是这样的：</p>
<p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p>
<p>那么异步的实现方式有哪些？</p>
<ul>
<li>ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅</li>
<li>ES6：Generator</li>
<li>ES7: Async/Await</li>
</ul>
<hr>
<p>参考：<br><a class="link"   href="https://github.com/sisterAn/blog/issues/11" >瓶子君 blog<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/sisterAn/blog/issues/23" >瓶子君 Generator<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/sisterAn/blog/issues/27" >瓶子君 co函数<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的几种继承方式</title>
    <url>/2020/04/07/JS/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>我们来谈谈JS的继承吧</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>方式 <code>son.prototype = new father()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grandFather</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.gF_paroperty = <span class="string">&#x27;gF_paroperty&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">grandFather.prototype.getGFPropery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 祖父原型的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.gF_paroperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherPropery = <span class="string">&#x27;fatherPropery&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 grandFather 和 father 的 连接 让父亲继承祖父（核心）</span></span><br><span class="line">father.prototype = <span class="keyword">new</span> grandFather(); </span><br><span class="line"></span><br><span class="line">father.prototype.getFatherVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 父亲原型的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.fatherPropery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sonInstance = <span class="keyword">new</span> father() <span class="comment">// 儿子继承父亲</span></span><br><span class="line"><span class="built_in">console</span>.log(sonInstance.getGFPropery()); <span class="comment">// expect output : &#x27;gF_paroperty&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(sonInstance.getFatherVal()); <span class="comment">// expect output : fatherPropery</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法缺陷: 多个子实例会改变引用类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance2.__proto__.colors) <span class="comment">// array[4]</span></span><br></pre></td></tr></table></figure>

<h4 id="检测是否属于原型上的实例"><a href="#检测是否属于原型上的实例" class="headerlink" title="检测是否属于原型上的实例"></a>检测是否属于原型上的实例</h4><ul>
<li>instanceof :<br>运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。返回布尔。</li>
</ul>
<p> 最高级对象是 <strong>Object</strong><br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myString  = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line">myString <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// 返回 true</span></span><br><span class="line">myString <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>hasOwnProperty :<br>检测自身原型上是否有传入参数的属性,返回布尔<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.property1 = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(object1.hasOwnProperty(<span class="string">&#x27;property1&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(object1.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(object1.hasOwnProperty(<span class="string">&#x27;hasOwnProperty&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构造函数-结合call继承"><a href="#构造函数-结合call继承" class="headerlink" title="构造函数 结合call继承"></a>构造函数 结合<code>call</code>继承</h4><p>描述：核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用SuperType构造函数，于是SubType的<code>每个实例都会</code>将SuperType中的属性<code>复制一份</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.specialWay = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="comment">// alert(instance1.color);//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// alert(instance2.color);//&quot;red,green,blue&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.specialWay); <span class="comment">// output：undefined 原型上的属性、方法继承不了</span></span><br></pre></td></tr></table></figure>
<div class="tip">
(1) 只能继承父类的实例属性和方法，不能继承原型属性/方法
(2) 无法实现复用，`每个子类都有父类实例函数的副本`，影响性能
</div>

<h4 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a><code>Object.create</code></h4><p>也就是提供一个返回一个新对象，并且该对象的__proto__指向传入的对象<br>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较好的用法👍</span></span><br><span class="line">son.prototype = <span class="built_in">Object</span>.create(father.prototype)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip">
(1) 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
(2) 无法传递参数
</div>

<h4 id="ES6-class-extends-super"><a href="#ES6-class-extends-super" class="headerlink" title="ES6 class extends super"></a>ES6 class <code>extends</code> <code>super</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123; <span class="comment">// class 名一般都是大写开头</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123; <span class="comment">// Getter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123; <span class="comment">// Method</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>class 的 继承 <strong>extends</strong> 关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>; <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>class 实际上是函数的语法糖🍬</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Rectangle <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> Square <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ES5继承和ES6继承的区别"><a href="#ES5继承和ES6继承的区别" class="headerlink" title="ES5继承和ES6继承的区别"></a>ES5继承和ES6继承的区别</h4><ul>
<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.  </li>
<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。<br>因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>
</ul>
<p>参考链接：<br><a class="link"   href="https://juejin.im/post/5bcb2e295188255c55472db0" >掘金<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://es6.ruanyifeng.com/#docs/class#%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88getter%EF%BC%89%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88setter%EF%BC%89" >es6 阮一峰 class getter setter<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" >mdn instanceof<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端协作历史 &amp;&amp; SPA</title>
    <url>/2022/04/13/%E6%8A%80%E6%9C%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8D%8F%E4%BD%9C&amp;&amp;SPA/</url>
    <content><![CDATA[<p>一种技术登场，总有着它的使命。</p>
<blockquote>
<p>前言</p>
</blockquote>
<p>今天我们要聊的是<strong>路由</strong>。</p>
<p>路由是什么？路由是浏览器的地址栏的 <code>URL</code>，往往不同路由对应不同业务模块。</p>
<p>比如：<a class="link"   href="http://www.example.com/photo" >www.example.com/photo<i class="fas fa-external-link-alt"></i></a> 指的是photo页面; <a class="link"   href="http://www.example.com/profile" >www.example.com/profile<i class="fas fa-external-link-alt"></i></a> 指的是个人资料页面;</p>
<p>而<code>SPA ( single page application )</code>: 单页面应用。作为前端路由能力的解决方案。</p>
<blockquote>
<p>回溯</p>
</blockquote>
<h4 id="1-前后端的协作发展"><a href="#1-前后端的协作发展" class="headerlink" title="1. 前后端的协作发展"></a>1. 前后端的协作发展</h4><p>1 前后端没分离：</p>
<pre><code>特点：

（1）项目与页面结构：前端项目依附在后端指定目录里，如 wwwroot。并且页面和结构相对耦合度高，比如JSP、.net。

前端除了编写自己业务，还得了解后台语法，无形提高很多维护成本。

（2）路由能力：前端缺乏路由能力。请求新路由，会跳转到新的网页，并从服务器端下载 HTML，加载样式，JS等等;

重复请求公共页面，会造成资源浪费；

（3）数据获取：后台会在业务结构里传递全局变量，前端需拿到处理逻辑。另一种则是 Ajax 请求;

优点：SEO友好，首屏渲染快;

缺点：维护成本高，资源浪费;

技术栈：JAVA、PHP、.net、Ajax
</code></pre>
<p>2 前后端部分分离:</p>
<pre><code>特点：

（1）项目结构：除了前后端不分离，还存在 把部分脱离后端业务的前端页面（定制或纯展示），放在云存储里。

如：https://www.cdnjs.com/custom-h5.html

（2）路由能力：window.History 模块推出了API pushState，让前端可以实现路由改变。

结合 aJax技术，JQuery推出了pJax库; 具体表现为，后台识别为pjax请求，返回页面某个区域的ajax请求html字符串;

前端替换这个区域的dom渲染，同时利用 pushState 改变路由;

技术栈：Ajax、Pjax、CDN
</code></pre>
<p>3 前后端分离：</p>
<pre><code>繁杂的前端业务结构和日益庞大的后台数据逻辑，已经很难再合并一起开发；

特点：

（1）前端的工程化：从工具链（Gulp、Grunt）到大型构建（Webpack），项目脚手架。并独自部署维护项目;

（2）路由：前端可以构建大型应用，并以 SPA 模式去维护项目的跳转路由; 提升用户体验，节省下载资源;

三大框架(Vue React Angular)对 SPA 实践。React-router、Vue-router等;

本文的例子也是基于vue-router 展开;

优点：便于维护; 缺点：首屏渲染白屏时间过长; SEO不友好;

技术栈：Vue React Angular 、Nginx、WebPack
</code></pre>
<p>4 前端 SSR：解决SEO问题，将web代码放在服务端渲染。涉及篇幅较多，会另开介绍;</p>
<hr>
<h4 id="2-SPA"><a href="#2-SPA" class="headerlink" title="2. SPA"></a>2. SPA</h4><p>那么我们已经了解到 SPA 是一种路由解决方案。</p>
<p>对于 SPA 理解：</p>
<pre><code>单页 single page 的理解就是从开始加载到离开浏览器，前端都是同一个 HTML。

只是在这个页面做路由监听，以及对应处理(跳转路由，切换DOM结构)。

现在的前端框架对虚拟DOM，数据绑定已是驾轻就熟，在监听路由改变时，无刷新切换路由和更新视图。

application 的理解：当页面和业务规模到一定程度的时候，就是一个应用。
</code></pre>
<p>对于 SPA 原理：</p>
<pre><code>路由有两种形式：

（1）带 hash： URL中有#，后面跟着的是hash值

路由例子：https://www.google.com/#hash

设置和获取：`location.hash`

监听改变：
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// code... &#125;)</span></span><br></pre></td></tr></table></figure>
<pre><code>（2）不带 hash (也称 history模式)

路由例子：https://www.example.com/user

设置和获取：
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">location.pathName + location.search + location.hash, 处理 query</span><br><span class="line"><span class="comment">// 跳转：参数说明：data 设置后是可以在history.state获取, title是暂时用不上的，url是要跳转的路由，字符串形式存在</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(data, title, url) </span><br><span class="line"><span class="built_in">window</span>.history.replaceState(data, title, url)</span><br></pre></td></tr></table></figure>
<pre><code>监听改变：
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">//code... &#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-Vue-router-构建-SPA-的一些思考"><a href="#3-Vue-router-构建-SPA-的一些思考" class="headerlink" title="3. Vue-router 构建 SPA 的一些思考"></a>3. Vue-router 构建 SPA 的一些思考</h4><p>1 install 钩子方法，注册 vue 组件 <strong>router-link</strong> <strong>router-view</strong> 。扩展当前 vue 根实例。也巧妙的给 vue 原型赋值: $route 和 $router，并做了防止原型链污染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// vue.prototype.$router 是 router实例上一些方法</span></span><br><span class="line">  <span class="comment">// 如果是new vue()的新实例，this._routerRoot值是没有的，值为undefined。所以无需担心原型链污染</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vue.prototype, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._router <span class="comment">// 只有传入router以及配置的vue实例才会有值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue.util.defineReactive 方法，给指定对象定义响应式。这个方法，实现了在vue实例上收集当前路由的依赖。</p>
<p>定义 router-view 组件时，用了函数式组件的写法：funtional: true。特点是：没有this 没有data 没有生命周期，减少性能消耗。</p>
<p>router-view 中的做法：路由匹配得到的数组 类似 [{ path: ‘/home’, component: aa}, {path: ‘/home/a’}, component: bb] ，</p>
<p>递归改变数组匹配深度，调用render 函数，传入对应组件渲染。保证从子到父都渲染到。有点类似冒泡。</p>
<p>2 <strong>history</strong> 为核心模块。专门处理底层的路由跳转，路由监听，以及路由匹配。（注：这里的底层，是不会直接暴露给用户使用的）</p>
<p>它考虑的很周全，公用的方法采取<code>继承</code>的方式。公用的方法有 存储和更新当前路由、路由匹配、创建路由方法、队列处理周期钩子（如 beforeEach）</p>
<p>两种路由模式(<strong>hash</strong> <strong>history</strong>) 的不同之处：</p>
<p>（1）获取当前路径</p>
<p>（2）监听路由改变：监听的事件不一样，触发的回调也不一样</p>
<p>我们对 <code>$routerd的API</code> 的操作，都会直接映射到这两个基类去操作。比如 <code>push</code> 其实调用的是 <code>history.push</code> 方法，而 push 方法在两模式下实现的方式也各有不同。</p>
<p>队列处理钩子这部分，用到了循环运行迭代器的思想。递归执行到最后，执行回调函数。(<a target="blank" href="/2022/04/14/编程技巧/编程技巧/">点此</a>有介绍)</p>
<p>3 Matcher 模块。负责处理用户 router 配置，递归映射成如： url =&gt; route的 map 结构，增加路由等;</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>结合现在前端框架的组件能力以及浏览器相关 API（location、history、event），也是可以实现 SPA 的。</p>
<p>感谢现在的前端框架，能让我们学的这么多技巧和知识！</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>国际化</title>
    <url>/2022/05/15/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>业务场景</tag>
      </tags>
  </entry>
  <entry>
    <title>扫码登录</title>
    <url>/2022/05/15/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>形如微信扫码登录的场景，我们常常也会遇到类似的需求。 </p>
<p>大致表现形式为：</p>
<ul>
<li><p>第一步：<code>PC</code>有个扫码登录的需求，出现二维码，不扫则会在几分钟内过期，过期的二维码无效。可点击刷新获取最新二维码。</p>
</li>
<li><p>第二步：<code>移动</code>（APP / 小程序） 端会打开同意授权 <code>PC</code> 页面（移动端需持有登录态，未登录将在支撑扫码登录业务前 先进行自身端的登录），确认授权后，<code>PC</code> 会获得用户信息并刷新界面。</p>
</li>
</ul>
<p>注意：本文后面的<code>移动端</code>都会泛指（APP / 小程序）😉~</p>
<p>疑问点：</p>
<p>那么 <code>pc</code> 是如何拿到 <code>app</code> 的 某种 <strong>授权机制</strong> 去登录呢？ok! 让我们剖析背后的时机，数据以及请求方式。</p>
<hr>
<h4 id="1-多端的猜想与验证"><a href="#1-多端的猜想与验证" class="headerlink" title="1 多端的猜想与验证"></a>1 多端的猜想与验证</h4><p>以下交互参考腾讯云：</p>
<blockquote>
<p><code>多端</code> ：首先完成这个需求，至少要出现以下几个端 ，先从表现上分析：</p>
</blockquote>
<p><code>PC</code>： </p>
<p>二维码的几种状态：</p>
<p> a.  未扫码：此时会出现完整的二维码。</p>
<p> b.  <code>APP</code> 或者 微信扫码后，二维码会出现蒙版，蒙版上面有已扫描成功的效果，并提示在扫码端点击确认。</p>
<p> c.  假如过期时间到了仍没被扫码，将会出现过期态和重新获取最新二维码的按钮。</p>
<p>快问快答：</p>
<p> 问：那么这个二维码是怎么来的，里面存储了哪些信息呢？</p>
<p> 答：pc的身份识别信息？</p>
<p><code>移动端</code> ：</p>
<p> （1）打开扫一扫</p>
<p> （2）跳转扫码确认页</p>
<p> （3）扫码成功</p>
<p><code>后台</code>：</p>
<p> （1）生成二维码</p>
<p> （2）</p>
<p> （3）</p>
<h4 id="2-扫码登录的优势？"><a href="#2-扫码登录的优势？" class="headerlink" title="2 扫码登录的优势？"></a>2 扫码登录的优势？</h4><h4 id="3-完整的扫码登录流程-code"><a href="#3-完整的扫码登录流程-code" class="headerlink" title="3 完整的扫码登录流程 code"></a>3 完整的扫码登录流程 code</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 轮询</span></span><br><span class="line">code</span><br></pre></td></tr></table></figure>

<hr>
<p>参考链接：<br><a class="link"   href="https://www.cnblogs.com/huanshilang/p/12365376.html" >blog<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://cloud.tencent.com/developer/article/1893465" >原理<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>业务场景</tag>
      </tags>
  </entry>
  <entry>
    <title>JS编程技巧</title>
    <url>/2022/04/14/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<blockquote>
<p>最近看vue-router源码，有一些 JS 技巧记录下：</p>
</blockquote>
<h6 id="1-尽量写纯函数，将上下文依赖减少"><a href="#1-尽量写纯函数，将上下文依赖减少" class="headerlink" title="1 尽量写纯函数，将上下文依赖减少"></a>1 尽量写纯函数，将上下文依赖减少</h6><h6 id="2-减少主函数的体积，降低心智负担。尽量抽离模块。"><a href="#2-减少主函数的体积，降低心智负担。尽量抽离模块。" class="headerlink" title="2 减少主函数的体积，降低心智负担。尽量抽离模块。"></a>2 减少主函数的体积，降低心智负担。尽量抽离模块。</h6><h6 id="3-递归-：只要有适当的触发条件，会帮上很多忙。层级结构可以打上标记，关联-parent层-和-children层"><a href="#3-递归-：只要有适当的触发条件，会帮上很多忙。层级结构可以打上标记，关联-parent层-和-children层" class="headerlink" title="3 递归 ：只要有适当的触发条件，会帮上很多忙。层级结构可以打上标记，关联 parent层 和 children层;"></a>3 递归 ：只要有适当的触发条件，会帮上很多忙。层级结构可以打上标记，关联 parent层 和 children层;</h6><p>if 或者 while 都是常用的方式</p>
<h6 id="4-队列处理函数"><a href="#4-队列处理函数" class="headerlink" title="4 队列处理函数:"></a>4 队列处理函数:</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环运行迭代器 (相当于中间件)</span></span><br><span class="line"><span class="comment"> * 递归执行内置next函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runQueue</span>(<span class="params">queueList, iterator, cb</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= queueList.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> cb()</span><br><span class="line">        &#125;</span><br><span class="line">        iterator(queueList[index], <span class="function">() =&gt;</span> next(index + <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    next(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook, nextFn</span>) =&gt;</span> &#123; <span class="comment">// 迭代器 只管中间参数</span></span><br><span class="line">    hook(newCurrent, <span class="built_in">this</span>.current, nextFn)</span><br><span class="line">&#125;</span><br><span class="line">runQueue(hooksQueue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// callback()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>运行环境</title>
    <url>/2021/04/06/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="网页加载"><a href="#网页加载" class="headerlink" title="网页加载"></a>网页加载</h3><h5 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h5><ul>
<li><p>加载资源的形式：<br>HTML 代码<br>媒体文件，图片，视频<br>JS CSS</p>
</li>
<li><p>加载资源的过程：<br>DNS 解析：域名 =&gt; IP 地址<br>浏览器根据 IP 地址，向服务器发起 Http 请求<br>三次握手<br>服务器处理 Http 请求，并返回给浏览器</p>
</li>
<li><p>渲染页面的过程：<br>根据 HTML 代码生成 DOM Tree<br>根据 CSS 代码生成 CSSOM<br>将 DOM Tree 和 CSSOM 整合进 Render Tree<br>根据 Render Tree 渲染页面<br>JS 可能会改变 DOM，所以 JS 线程 和 渲染线程，是<strong>共用线程</strong>，所以遇到 script 暂停渲染，优先加载并执行 JS 代码，然后继续渲染页面，直至完成 Render Tree</p>
</li>
</ul>
<h5 id="从输入-url-到-渲染出页面的整个过程？"><a href="#从输入-url-到-渲染出页面的整个过程？" class="headerlink" title="从输入 url 到 渲染出页面的整个过程？"></a>从输入 url 到 渲染出页面的整个过程？</h5><p> 加载资源的过程 + 渲染页面的过程</p>
<h5 id="window-onload-和-DOMContentLoaded-的区别？"><a href="#window-onload-和-DOMContentLoaded-的区别？" class="headerlink" title="window.onload 和 DOMContentLoaded 的区别？"></a>window.onload 和 DOMContentLoaded 的区别？</h5><p>onload：页面全部资源加载完 才执行，包括 图片、视频<br>window.addEventListener(‘load’, function() {}) </p>
<p>DOMContentLoaded：DOM 渲染完 即执行，此时 图片、视频还可能没有加载完（ 快 ）<br>document.addEventListener(‘DOMContentLoaded’, function() {})</p>
<h5 id="为什么建议把-CSS-放在-head-中？JS-为什么建议-放后面？"><a href="#为什么建议把-CSS-放在-head-中？JS-为什么建议-放后面？" class="headerlink" title="为什么建议把 CSS 放在 head 中？JS 为什么建议 放后面？"></a>为什么建议把 CSS 放在 head 中？JS 为什么建议 放后面？</h5><p>早点生成 CSSOM，避免 Render 延迟<br>JS 会 阻碍页面渲染，同步等待，会让 用户等待时间延长</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h5 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h5><ul>
<li><p>缓存：url 和 文件不变，则会自动触发 http 缓存机制，返回 304</p>
</li>
<li><p>SSR： 服务端渲染，将网页和数据一起加载，一起渲染</p>
</li>
<li><p>懒加载：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img id=<span class="string">&quot;img1&quot;</span> src=<span class="string">&quot;preview.png&quot;</span> data-realsrc=<span class="string">&quot;abc.png&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> img1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img1&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    img.src = img1.getAttribute(<span class="string">&#x27;data-realsrc&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>DOM 缓存 ：用变量存储查询的 DOM 结果，避免 For 循环 一直查询</p>
</li>
<li><p>防抖 （ debounce ）<br>常用场景：<br>监听输入框，文字变化后 触发 change 事件<br>直接用 keyup 事件，频繁触发 change 事件<br>用户输入<strong>结束或暂停</strong>时，才会 触发 change 事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123; <span class="built_in">clearTimeout</span>(timer) &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(input.value)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123; <span class="built_in">clearTimeout</span>(timer) &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">input1.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(input1.value)</span><br><span class="line">&#125;, <span class="number">500</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>节流<br>适用于任何频繁触发的，如 scroll 、mousemove 、 drag<br>拖拽一个元素，随时拿到该元素被拖拽的位置，按一定触发的速率去触发，而不是频繁触发，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dragDiv&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dragDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;dragDiv&#x27;</span>)</span><br><span class="line">dragDiv.addEventListener(<span class="string">&#x27;drag&#x27;</span>, throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetX, e.offsetY)</span><br><span class="line">&#125;, <span class="number">200</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay=<span class="number">100</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://juejin.cn/post/6844903705763020807" >掘金 节流优化<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h5 id="性能优化入手："><a href="#性能优化入手：" class="headerlink" title="性能优化入手："></a>性能优化入手：</h5><p>加载更快：<br>减少资源体积大小（ 打包📦工具压缩代码 ）<br>减少请求次数：合并代码，SSR 服务器端渲染，缓存（ 根据内容进行静态资源加哈希后缀，文件内容变化才会影响哈希后缀 ）<br>使用更快的网络：CDN</p>
<p>渲染更快：<br>CSS 放 Head 位置，JS 放在 Body 下面<br>尽早开始执行 JS，用 DOMContentLoaded 触发<br>懒加载（ 图片懒加载，上滑加载更多 ）<br>对 DOM 查询进行缓存<br>频繁 DOM 操作，合并到一起插入 DOM 结构<br>节流 throttle ，防抖 debounce</p>
<h5 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h5><p>多使用 内存、缓存 或其他方法<br>减少 CPU 计算量，减少网络加载耗时<br>适用于所有编程的性能优化 — 空间换时间（ 内存 换 加载时间 ）</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>常见的 web 安全 ：</p>
<h5 id="XSS-跨站请求攻击：嵌入恶意-script-脚本，获取-阅读者-用户敏感信息"><a href="#XSS-跨站请求攻击：嵌入恶意-script-脚本，获取-阅读者-用户敏感信息" class="headerlink" title="XSS 跨站请求攻击：嵌入恶意 script 脚本，获取 阅读者 用户敏感信息"></a>XSS 跨站请求攻击：嵌入恶意 script 脚本，获取 阅读者 用户敏感信息</h5><p>预防：<br>替换特殊字符，如 &lt; 变为 &lt; ,  &gt; 变为 &gt;<br>将 script 标签左右的 尖括号，前端后端都替换，直接显示，不作为脚本执行<br>有个工具做的不错的，npmjs.com/package/xss</p>
<h5 id="XSRF-跨站请求伪造："><a href="#XSRF-跨站请求伪造：" class="headerlink" title="XSRF 跨站请求伪造："></a>XSRF 跨站请求伪造：</h5><p>伪造用户身份去跨域请求<br>预防：<br>post 请求<br>请求增加验证手段，密码，验证码，指纹等</p>
]]></content>
      <tags>
        <tag>运行环境</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建脚手架 &amp;&amp; 发布 Npm 仓库</title>
    <url>/2021/11/01/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E8%84%9A%E6%89%8B%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<p>工作以来，积累了几套项目模板，包括 PC 、H5 、Electron 、小程序等，平时可用于快速创建 <strong>项目模板</strong>。<br>提升开发效率，也是<strong>前端工程化</strong>的所需要的。</p>
<p>那么这次，封装的 脚手架（ JZ-cli ），采用 命令行交互式 询问安装，方便快速开发新项目。<br>主技术栈为 <strong>Node</strong> <strong>Npm</strong>。</p>
<p>话不多说，直接开搞：</p>
<h5 id="脚手架的原理："><a href="#脚手架的原理：" class="headerlink" title="脚手架的原理："></a>脚手架的原理：</h5><p>脚手架在命令行交互选择，选中所需 <strong>web</strong> 模板时，去下载远程 <strong>git</strong> 仓库的模板文件。下载完，拷贝目录到项目根目录。删除多出来的目录，并复制工具库。按照在命令行传入的配置，渲染最新的 package.json.</p>
<h5 id="仓库托管："><a href="#仓库托管：" class="headerlink" title="仓库托管："></a>仓库托管：</h5><p>因为 脚手架还需要单独发布到 <strong>npm</strong> ，包的体积大小不适合太大。所以分开 脚手架 和 模板 的目录，我这里都选择了 <strong>github</strong> 去托管。（ 也可以用 <strong>gitlab</strong> ） </p>
<h5 id="初始化-package-json-与-bin-命令"><a href="#初始化-package-json-与-bin-命令" class="headerlink" title="初始化 package.json 与 bin 命令"></a>初始化 package.json 与 bin 命令</h5><ul>
<li><p><code>npm init -y</code> ( 初始化 package.json )</p>
</li>
<li><p>package.json 里 新建 <strong>bin</strong> 字段:<br>bin 是 会链接到全局 path。把 bin 中的命令，在命令行可以执行，并直接运行全局的 bin 指向路径的文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jz-temp-cli&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;一款以node技术为主，包括PC、H5、小程序、Electron的脚手架&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bin&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;JZ-temp&quot;</span>: <span class="string">&quot;bin/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;JZ-cli&quot;</span>: <span class="string">&quot;bin/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;JZ&quot;</span>: <span class="string">&quot;bin/index.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考链接：<a class="link"   href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#bin" >npm docs :bin<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>主文件：<code>bin / index.js</code><br>index.js 里，首行： #!/usr/bin/env node<br>因为我们需要用 node 去执行相关命令，所以 需要这句话 <code>#!/usr/bin/env node</code> ，使用 node 进行脚本的解释程序，那下面的就可以使用 node 的语法了。</p>
</li>
<li><p>调试前，需要 <code>npm i . -g</code> ，将本地包安装到全局。然后 <code>npm link</code>，建立 本地包 和 全局包的 同步关联。<br>接下来可以愉快的调试了～</p>
</li>
</ul>
<h5 id="几个关键库："><a href="#几个关键库：" class="headerlink" title="几个关键库："></a>几个关键库：</h5><ul>
<li><p>commander ： 终端交互库</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line">program</span><br><span class="line">.version(packageJson.version) <span class="comment">// version 赋予版本号</span></span><br><span class="line">.command(<span class="string">&#x27;create [project]&#x27;</span>) <span class="comment">// command：指令名字</span></span><br><span class="line">.description(<span class="string">&#x27;初始化项目模板&#x27;</span>) <span class="comment">// 对应 command指令的 描述</span></span><br><span class="line">.action(<span class="keyword">async</span> (projectName) =&gt; &#123; <span class="comment">// action 对应 命令指定处理函数</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;../lib/create&#x27;</span>)(projectName)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8.webp"
                      alt="脚手架使用"
                ></p>
</li>
<li><p>inquirer : 实现交互式命令行</p>
</li>
<li><p>chalk : 给命令行设置颜色</p>
</li>
<li><p>fs-extra : 基于 fs 的额外补充版, 原型是 fs</p>
</li>
<li><p>log-symbols : 各种日志级别的彩色图标</p>
</li>
<li><p>ora : 终端 loading</p>
</li>
<li><p>mvdir : 迁移文件目录</p>
</li>
<li><p>del : 删除 文件 和 目录 ，支持 promise 调用</p>
</li>
</ul>
<p>交互效果如图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/%E4%BA%A4%E4%BA%92.webp"
                      alt="交互"
                ></p>
<h5 id="具体脚手架代码："><a href="#具体脚手架代码：" class="headerlink" title="具体脚手架代码："></a>具体脚手架代码：</h5><ul>
<li>项目链接：<a class="link"   href="https://github.com/jonnzer/project-temp-cli" >github temp-cli<i class="fas fa-external-link-alt"></i></a></li>
<li>因为文章篇幅，就不展开讲了。代码量不算多，可以去看下～</li>
</ul>
<h5 id="发布-npm-需要做的准备："><a href="#发布-npm-需要做的准备：" class="headerlink" title="发布 npm 需要做的准备："></a>发布 npm 需要做的准备：</h5><ul>
<li>登录 npm（ <a class="link"   href="https://www.npmjs.com/" >https://www.npmjs.com/<i class="fas fa-external-link-alt"></i></a> ） ，注册账号 (存好账号密码)</li>
<li>切换 npm 源，为默认的 切换为默认源<br>命令行输入：npm config set registry <a class="link"   href="https://registry.npmjs.org/" >https://registry.npmjs.org<i class="fas fa-external-link-alt"></i></a></li>
<li>修改 package.json</li>
</ul>
<p><strong>author</strong> ：名字 <email> (github link)<br> “author”: “jonnzer <a class="link"   href="mailto:&#106;&#97;&#x6e;&#101;&#98;&#101;&#x6e;&#x6a;&#x6f;&#x68;&#x6e;&#x40;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#99;&#x6f;&#x6d;" >&#106;&#97;&#x6e;&#101;&#98;&#101;&#x6e;&#x6a;&#x6f;&#x68;&#x6e;&#x40;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#99;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a> (<a class="link"   href="http://github.com/jonnzer)&quot;" >http://github.com/jonnzer)&quot;<i class="fas fa-external-link-alt"></i></a>,</p>
<ul>
<li>name ：需要遵循规范：唯一，由小写英文字母、数字和下划线组成，不能包含空格</li>
</ul>
<h5 id="npm-发布"><a href="#npm-发布" class="headerlink" title="npm 发布"></a>npm 发布</h5><p>在命令行，按顺序输入以下命令：</p>
<ul>
<li><code>npm login</code>: 登录 npm ，需要用到刚刚注册的用户名密码</li>
<li><code>npm publish</code></li>
<li>去 npm 个人 packages 页，看下有没有你最新的发布包。</li>
<li>恭喜您完成本教程啦～～～</li>
</ul>
<p>参考链接：<br><a class="link"   href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#bin" >npm docs :bin<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md" >github command API<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.yuque.com/docs/share/1fbb0f4b-a7c7-40ac-8a39-9da4723c4620#cz6xG" >yuque deploy npm package<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>部署web服务器</title>
    <url>/2023/02/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%99%A8/index/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>部署<code>Node</code>应用和<code>web</code>应用，都需要部署到云服务器。</p>
<p>那么，今天来记录下怎么一个云服务器如何构建，以满足<code>web</code>开发的基本使用。</p>
<hr>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="服务器选购"><a href="#服务器选购" class="headerlink" title="服务器选购"></a>服务器选购</h5><p>首先得买台云服务器，我选的是腾讯的 <code>centos</code>系统，配置是 cpu 2核内存4G的云服务器。<br>如果喜欢命令行方式，推荐选 <code>centos</code>。<br>更喜欢图形化界面，也可以选 <code>windowServer</code> 或者其他系统。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/jonnzer/saveImgForYun@master/WebServer/%E7%B3%BB%E7%BB%9F.webp"
                      alt="img"
                ></p>
<h5 id="安装功能（可使用-yum-wget）"><a href="#安装功能（可使用-yum-wget）" class="headerlink" title="安装功能（可使用 yum  wget）"></a>安装功能（可使用 <code>yum</code>  <code>wget</code>）</h5><ul>
<li><code>Node</code>(自带<code>Npm</code>)</li>
<li><code>Nvm</code>: Node版本管理工具</li>
<li><code>Nginx</code>: 映射多页面多端口，可以部署多个web应用</li>
<li><code>pm2</code>: <code>Node</code>进程管理工具 （npm i -g pm2）</li>
</ul>
<p>可选:</p>
<ul>
<li><code>lsb_release</code>： 查看<code>Linux</code>发行版本 （yum install lsb_release）</li>
</ul>
<p>其中，<br><code>NodeJs</code>安装 这块，可以参考文档<a class="link"   href="https://cloud.tencent.com/document/product/213/38237" >部署NodeJs环境<i class="fas fa-external-link-alt"></i></a></p>
<p><code>PM2</code> 需要用到的基本命令：<br>(1) <code>pm2 start index.js</code>（<code>Node Application entry file</code>）：启动<code>Node</code>服务<br>(2) <code>pm2 list</code> ： 查看所有正在使用<code>pm2</code>的服务列表<br>(3) <code>pm2 monit</code>: 查看 <code>cpu</code>和内存占用情况</p>
<p><code>Nginx</code>安装这块，可以参考文档<a class="link"   href="https://www.digitalocean.com/community/tutorials/how-to-install-Nginx-on-centos-7" >Nginx安装<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://help.aliyun.com/document_detail/171730.html" >Nginx 简单部署多页面，并且用域名访问教程<i class="fas fa-external-link-alt"></i></a></p>
<p><code>Nginx</code> 一些常用命令：<br>(1) <code>nginx -t</code>： 修改配置后，检测语法是否正确<br>(2) <code>nginx -s reload</code>: 重启 <code>Nginx</code>服务器</p>
<p><code>Nginx</code> 的基本配置，是在 <code>/etc/nginx/nginx.conf</code>，可以看到 里面有一句：<code> include /etc/nginx/conf.d/*.conf;</code><br>也就是我们的自定义<code>Nginx</code>配置 <code>conf</code>文件，应该在 <code>/etc/nginx/conf.d</code> 文件夹里放置<br>所以，接下来的<code>Node.conf</code> 和 <code>front.conf</code> 的位置都是在这个文件夹里。</p>
<p><code>Nginx</code> 部署 <code>Node</code>项目:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># Node.conf</span><br><span class="line">    upstream my_nodejs_upstream &#123;</span><br><span class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3002</span>;</span><br><span class="line">        keepalive <span class="number">64</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  <span class="number">42.193</span><span class="number">.248</span><span class="number">.156</span>;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            </span><br><span class="line">            proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            proxy_pass http:<span class="comment">//my_nodejs_upstream/;</span></span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_read_timeout 240s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p><code>Nginx</code>部署 <code>web</code> 项目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># front.conf</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       <span class="number">8080</span>; # 需要云服务器新增一个<span class="number">8080</span>端口，此处会有更优解</span><br><span class="line">        server_name  <span class="number">42.193</span><span class="number">.248</span><span class="number">.156</span>;    #此处使用测试域名。实际配置中使用您的服务器域名。</span><br><span class="line">        access_log  /<span class="keyword">var</span>/log/Nginx/front.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/local/web/front;    #测试站点路径。即您的项目代码路径。</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            try_files $uri /index.html;  # 解决刷新<span class="number">404</span>问题</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   /usr/share/Nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h5><p>(1) <code>XX command not found</code>(拿 <code>pm2</code> 举例子:):<br>a. <code>find / -name pm2</code>: 寻找该包的安装地址 命令行会输出pm2的安装位置 比如 pm2路径 /usr/local/nodejs/node-v10.16.3-linux-x64/bin/pm2<br>b. <code>ln -s pm2路径 /usr/local/bin</code>： 关联软链接到环境变量下</p>
<h5 id="可用命令记录"><a href="#可用命令记录" class="headerlink" title="可用命令记录"></a>可用命令记录</h5><p>(1) <code>lsb_release -a</code>: 查看系统版本信息</p>
<p>参考链接；<br><a class="link"   href="https://cloud.tencent.com/developer/article/1526857" >yum： Linux软件包安装 命令<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/peida/archive/2013/03/18/2965369.html" >wget: Linux下载文件 命令<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序入门</title>
    <url>/2019/08/05/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<ul>
<li>目录结构</li>
<li>页面结构</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>业务开发需要用到小程序，上次开发也是3年前，这期间小程序也有一定程度的迭代。</p>
<p>ok的，我们可以做进一步的理解。</p>
<h4 id="小程序与网页端和服务端的区别"><a href="#小程序与网页端和服务端的区别" class="headerlink" title="小程序与网页端和服务端的区别"></a>小程序与网页端和服务端的区别</h4><p> (1) 小程序: 逻辑层和渲染层是分开的，分别运行在不同的线程中，逻辑层运行在 <strong><code>JSCore</code></strong> 中，并没有一个完整浏览器对象，因而缺少相关的 <code>DOM</code> API和 <code>BOM</code> API。所以基于 <code>DOM</code> 的操作库 例如 <code>jQuery</code>、 <code>Zepto</code> 等，在小程序中是无法运行的。</p>
<p>​ (2) 网页：网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，网页开发者可以使用到各种浏览器暴露出来的 <code>DOM</code> API，进行 <code>DOM</code> 选中和操作。</p>
<p> (3) 与服务端相比： <code>JSCore</code> 的环境同 <code>NodeJS</code> 环境也是不尽相同，所以一些 <code>NPM</code> 的包在小程序中也是无法运行的。</p>
<hr>
<p>代码构成：</p>
<ul>
<li>1.<code>wxml</code>: <ul>
<li>常用标签略微有点不一样，web开发常用的div，换成它的<strong><strong>view</strong></strong>标签。span换成它的<strong>text</strong>标签。<br>图片标签换成<strong>image</strong>标签，属性一样，用法一样。</li>
<li>谈下<strong>cover-view</strong>这个标签，它是可以在<code>map</code>、<code>video</code>、<code>canvas</code>、<code>camera</code>、<code>live-player</code>、<code>live-pusher</code>等等之上的渲染的标签。这时候<strong>view</strong>标签表示无能为力的。</li>
</ul>
</li>
<li>2.<code>wxss</code>:<ul>
<li>单位：px单位换成rpx,适配设备的单位，这个是真香，不用再换算。</li>
<li>flex布局支持。</li>
</ul>
</li>
<li>3.<code>js</code>:<ul>
<li>页面组件的js结构：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// import utils</span></span><br><span class="line">  Page(&#123;</span><br><span class="line">   <span class="attr">data</span>: &#123; <span class="comment">// 页面所需变量</span></span><br><span class="line"> 	&#125;,</span><br><span class="line">   <span class="attr">onShow</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fetch data</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">customEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 自己定义的触发函数</span></span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line">&#125;)    </span><br></pre></td></tr></table></figure>
<a class="link"   href="https://developers.weixin.qq.com/miniprogram/dev/framework/" >官方API<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
