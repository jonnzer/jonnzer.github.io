<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AST</title>
    <url>/2020/07/03/AST/</url>
    <content><![CDATA[<p>AST 一种语法树<span id="more"></span></p>
<div class="tip">
   tip文案
</div>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS准备</title>
    <url>/2020/04/08/CSS_review/</url>
    <content><![CDATA[<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="1-介绍下BFC及其应用"><a href="#1-介绍下BFC及其应用" class="headerlink" title="1. 介绍下BFC及其应用"></a>1. 介绍下BFC及其应用</h4><ul>
<li><p>BFC 是什么:<br>它是 css 盒模型的渲染模式。<br>有着盒子对齐，外边距重叠，清除浮动，防止文字环绕，多列最后列宽度自定义（不挤掉）</p>
</li>
<li><p>怎么新建一个 BFC :<br>一个新的 BFC 可以通过给容器添加任何一个触发 BFC 的 CSS 样式，如 overflow : scroll, overflow : hidden, display : flex, float: left,或者 display: table来创建。<br>display: table 可能会产生一些问题<br>overflow: scroll 可能会显示不必要的滚动条<br>float: left 将会把元素置于容器的左边，其他元素环绕着它<br>overflow: hidden 将会剪切掉溢出的元素</p>
</li>
</ul>
<p>参考链接：<br><a href="https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html">w3cPlus</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN</a></p>
<h4 id="2-float布局，clearfix"><a href="#2-float布局，clearfix" class="headerlink" title="2. float布局，clearfix"></a>2. float布局，clearfix</h4><h4 id="3-flex布局"><a href="#3-flex布局" class="headerlink" title="3. flex布局"></a>3. flex布局</h4><h4 id="4-盒子模型理解以及相关CSS属性"><a href="#4-盒子模型理解以及相关CSS属性" class="headerlink" title="4. 盒子模型理解以及相关CSS属性"></a>4. 盒子模型理解以及相关CSS属性</h4><ul>
<li>什么是盒子模型？<br>网页的 dom 具有盒子的属性，一层一层的装载。故把 dom 称为盒子模型。<br>盒子模型范围包括：content 、padding 、border 、margin</li>
</ul>
<p>存在两种盒子模型：标准 w3c 盒子模型（主流）、IE盒子模型（以页面头顶的 Doctype 声明来区分）<br>它们区别在于：标准 w3c 盒子模型，content 是仅仅包括自身宽高，而 IE盒子模型的 content 宽高是（自身宽高+ padding + border）</p>
<ul>
<li><p><strong>offset</strong>系列：<br>(offset 单词自身就有偏移量的意思) 表示元素在屏幕上占用的可见空间，都以像素为单位。<br>属性为 只读不可写<br>可见大小由：高度、宽度、内边距、滚动条、边框。 （<strong>！！！不包括外边距</strong>）</p>
<ul>
<li>offsetHeight : 元素在垂直方向占用的空间大小</li>
<li>offsetWidth : 元素在水平方向占用的空间大小</li>
<li>offsetLeft : 元素的左边框 至 <strong>包含元素</strong>的左内边框 的像素距离</li>
<li>offsetTop : 元素的上边框 至 <strong>包含元素</strong>的上内边框 的像素距离</li>
<li>offsetParent : 包含元素的引用</li>
</ul>
</li>
<li><p><strong>client</strong>系列：<br>属性为 只读不可写<br>(表示客户区大小的含义) 元素内容以及内边距占用的空间大小</p>
<ul>
<li>clientWidth : 内容宽度 + 左右内边距 </li>
<li>clientHeight : 内容高度 + 上下内边距<br>应用场景：<br>浏览器视口大小：document.documentElement.clientWidth / clientHeight<br>适配ie7:      document.body.clientWidth / clientHeight<br>(document.compatMode == ‘BackCompat’ // 确保浏览器在混杂模式 此时是适配ie系列)</li>
</ul>
</li>
<li><p><strong>scroll</strong>系列：</p>
</li>
<li><p><strong>getBoundingClientrect</strong></p>
</li>
</ul>
<h4 id="5-margin"><a href="#5-margin" class="headerlink" title="5. margin"></a>5. margin</h4><pre><code>+ margin塌陷问题
+ margin负值问题
</code></pre>
<h4 id="slot-A-display-none-B-visibility-hidden-C-opacity-0的区别"><a href="#slot-A-display-none-B-visibility-hidden-C-opacity-0的区别" class="headerlink" title="#### slot. A: display:none; B: visibility:hidden; C: opacity: 0的区别"></a>#### slot. A: display:none; B: visibility:hidden; C: opacity: 0的区别</h4><ul>
<li>展示程度上<br>都不显示</li>
<li>dom可操作上<br>A不可操作，B不可操作，C可操作</li>
<li>继承性<br>A和C的父盒子设置了对应的属性A和C，则他们的子代也是不可见，不可操作。B的子代是可以设置显示的</li>
<li>性能<br>A改变了结构，引起文档回流，性能消耗最大<br>B引起元素重绘，消耗中等<br>C消耗最低</li>
</ul>
<p>参考链接：<br><a href="https://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/">张鑫旭BLOG</a></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2019新变化</title>
    <url>/2020/07/20/ES2019%E6%96%B0%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>1 数组：<br>数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]];</span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>flat还会移除数组空项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat(); <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>2 字符串<br>去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="string">&quot; hello &quot;</span>;</span><br><span class="line"></span><br><span class="line">test.trim(); <span class="comment">// &quot;hello&quot;;</span></span><br><span class="line">test.trimStart(); <span class="comment">// &quot;hello &quot;;</span></span><br><span class="line">test.trimEnd(); <span class="comment">// &quot; hello&quot;;</span></span><br></pre></td></tr></table></figure>


<p>3 对象<br>Object.fromEntries() 数组转对象<br>与之相对应的是Object.entries() 对象转数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">prop1</span>: <span class="number">2</span>, <span class="attr">prop2</span>: <span class="number">10</span>, <span class="attr">prop3</span>: <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为键值对数组：</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Object</span>.entries(obj); </span><br><span class="line"><span class="comment">// [[&quot;prop1&quot;, 2], [&quot;prop2&quot;, 10], [&quot;prop3&quot;, 15]]</span></span><br><span class="line"></span><br><span class="line">array = array.map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> [key, <span class="built_in">Math</span>.pow(value, <span class="number">2</span>)]); </span><br><span class="line"><span class="comment">// [[&quot;prop1&quot;, 4], [&quot;prop2&quot;, 100], [&quot;prop3&quot;, 225]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">Object</span>.fromEntries(array); </span><br><span class="line"><span class="comment">// &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://github.com/sisterAn/blog/issues/47">瓶子君的blog</a></p>
]]></content>
      <tags>
        <tag>ES JS</tag>
      </tags>
  </entry>
  <entry>
    <title>H5-insertAdjacentElement</title>
    <url>/2019/03/11/H5-insertAdjacentElement/</url>
    <content><![CDATA[<h6 id="insertAdjacentElement作用是？"><a href="#insertAdjacentElement作用是？" class="headerlink" title="insertAdjacentElement作用是？"></a>insertAdjacentElement作用是？</h6><p>该方法将一个给定的元素节点<code>插入到</code><em>相对于被调用的元素</em>的给定的<code>一个位置</code>。</p>
<h6 id="如何用呢？"><a href="#如何用呢？" class="headerlink" title="如何用呢？"></a>如何用呢？</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element1.insertAdjacentElement(position, element2);</span><br></pre></td></tr></table></figure>
<p>参数positon:</p>
<ul>
<li><code>beforebegin</code>: 在该元素本身的前面.</li>
<li><code>afterbegin</code>:只在该元素当中, 在该元素第一个子孩子前面.</li>
<li><code>beforeend</code>:只在该元素当中, 在该元素最后一个子孩子后面.</li>
<li><code>afterend</code>: 在该元素本身的后面.</li>
</ul>
<p>element1：不动的元素<br>element2：被插入的元素</p>
<h6 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fileWrap = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;<span class="built_in">this</span>.fileWrapId&#125;</span>`</span>);</span><br><span class="line">fileWrap.insertAdjacentElement(<span class="string">&#x27;afterbegin&#x27;</span>, elem); <span class="comment">// elem为插入的元素</span></span><br></pre></td></tr></table></figure>

<h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentElement">mdn</a></p>
]]></content>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML面试准备</title>
    <url>/2020/04/12/HTML_review/</url>
    <content><![CDATA[<h4 id="1-如何理解HTML语义化"><a href="#1-如何理解HTML语义化" class="headerlink" title="1. 如何理解HTML语义化"></a>1. 如何理解HTML语义化</h4><p>之所以尽可能用<strong>贴近应用场景</strong>的标签</p>
<ul>
<li>能让<strong>开发者</strong>一目了然层级关系，增加代码可读性。</li>
<li>能让<strong>搜索引擎🔍</strong>更好的识别（<strong>SEO</strong>）。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/jonnzer/saveImgForYun@master/test1/%E8%AF%AD%E4%B9%89%E5%8C%96.jpeg" alt="语义化"></p>
<h4 id="2-块级元素和内联元素"><a href="#2-块级元素和内联元素" class="headerlink" title="2. 块级元素和内联元素"></a>2. 块级元素和内联元素</h4><pre><code>块级：display: block / table ； 有 div h1 h2 table ul ol p等；
内联：display: inline / inline-block; 有 span img input button等；
</code></pre>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行顺序 || EventLoop</title>
    <url>/2019/12/03/JS%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1-EventLoop"><a href="#1-EventLoop" class="headerlink" title="1.EventLoop"></a>1.EventLoop</h3><p>EventLoop就是那只看不见的手，由它主宰着JS的一切执行。<br>JS的异步代码，遇到时会被放置在一个小圈子里，当把同步代码执行完，就从这圈子里取出来异步代码执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 置底进程</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;from setTimeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行顺序：script start =&gt; script end =&gt; from setTimeout</span></span><br></pre></td></tr></table></figure>

<h3 id="2-微任务-amp-amp-宏任务"><a href="#2-微任务-amp-amp-宏任务" class="headerlink" title="2.微任务 &amp;&amp; 宏任务"></a>2.微任务 &amp;&amp; 宏任务</h3><p>优先级：同步代码 &gt; 微任务 &gt; 宏任务 &gt; 异步代码<br>宏任务：script , setTimeout, setInterval, setImmediate, i/0 , UI rendering ,requestAnimationFrame<br>微任务：process.nextTick, promise, Object.observe, MutationObserver,await</p>
<ul>
<li>new Promise(fn) // 也属于微任务，执行优先级高</li>
<li>且process.nextTick优先级大于promise.then</li>
<li>await后的async的fn 也会立刻执行 因为这是一个promise返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// setTimeout1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// process2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// promise2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// then2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// process1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>); <span class="comment">// new Promise立即执行</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// then1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// setTimeout2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// process3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// promise3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// then3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序 ：</span></span><br><span class="line"><span class="comment">// 第一步：</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>执行完 1 和 7后，现在看下，身边有这些任务</p>
<table>
<thead>
<tr>
<th>宏任务Event</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td align="center">process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="center">then1</td>
</tr>
</tbody></table>
<p>现在第一轮的主线跑完了，轮到第一轮的微任务了，<br>所以，接下来执行的是process1和then1，也就是<br>1，7，6，8， </p>
<p>第一轮结束，<br>第二轮开始。</p>
<p>接下来是开启新的一轮eventLoop。开始查询到新的宏任务setTimeout1；</p>
<table>
<thead>
<tr>
<th>宏任务Event</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td align="center">process2</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="center">then2</td>
</tr>
<tr>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td>1，7，6，8，2，4，3，5</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这下好了，setTimeout1宏任务完成了。<br>接下来，就剩setTimeout2宏任务。</p>
<table>
<thead>
<tr>
<th>宏任务Event</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="center">process3</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="center">then3</td>
</tr>
</tbody></table>
<p>1，7，6，8，2，4，3，5，9，11，10，12</p>
<h3 id="3-Vue的nextTick"><a href="#3-Vue的nextTick" class="headerlink" title="3. Vue的nextTick"></a>3. Vue的nextTick</h3><blockquote>
<p>异步更新内部是最重要的就是nextTick方法，它负责将异步任务加入队列和执行异步任务。<br>VUE  也将它暴露出来提供给用户使用。在数据修改完成后，立即获取相关DOM还没那么快更新，使用nextTick便可以解决这一问题。</p>
</blockquote>
<blockquote>
<p>watcher:每个监视者都有他们自己的id，当没有记录到对应的监视者.<br>即第一次进入逻辑，否则是重复的监视者，则不会进入。这一步就是实现监视者去重的点。</p>
</blockquote>
<blockquote>
<p>new Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</p>
</blockquote>
<blockquote>
<p>异步队列更新dom和数据，执行callback回调</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-<span class="keyword">if</span>=<span class="string">&quot;show&quot;</span> type=<span class="string">&quot;text&quot;</span> ref=<span class="string">&quot;myInput&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.show = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.$refs.myInput.focus() <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 获取dom的更新，成功执行</span></span><br><span class="line">        <span class="built_in">this</span>.$refs.myInput.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考链接：<br><a href="https://juejin.im/post/5aa8a07cf265da238a3022a4">掘金</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89">掘金2</a><br><a href="https://segmentfault.com/a/1190000019494012">segment</a><br><a href="cxymsg.com/guide/eventLoop.html#%E5%89%8D%E8%A8%80">blog</a><br><a href="https://segmentfault.com/a/1190000015057278">promise async await</a><br><a href="https://github.com/answershuto/learnVue/blob/master/docs/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown#nexttick">vue nextTick原理</a></p>
]]></content>
      <tags>
        <tag>JS原理</tag>
      </tags>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/2020/01/04/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>模块化的简单包装</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 利用了自执行函数的封闭性</span></span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(_count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(_count + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">m1</span>: m1,</span><br><span class="line">        <span class="attr">m2</span>: m2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>


<h3 id="1-JS模块化发展历史"><a href="#1-JS模块化发展历史" class="headerlink" title="1 JS模块化发展历史"></a>1 JS模块化发展历史</h3><ul>
<li>CommonJS 和 AMD CMD 鼎足之势 （前） ES6 （后）<br>（知名框架 Node.js、RequireJS前置加载 和 Seajs就近加载 分别对应前三个）</li>
<li>谈谈现阶段：<ul>
<li>ES6标准发布后，module成为标准，标准使用是以<code>export</code>指令导出接口，以<code>import</code>引入模块。</li>
<li>在我们一贯的node模块中，我们依然采用的是<code>CommonJS</code>规范，使用<code>require</code>引入模块，使用<code>module.exports</code>导出接口。是<code>同步</code>加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范<code>无法直接在浏览器</code>中使用。</li>
</ul>
</li>
</ul>
<h3 id="2-对于es6模块的看法（参考阮一峰老师）"><a href="#2-对于es6模块的看法（参考阮一峰老师）" class="headerlink" title="2 对于es6模块的看法（参考阮一峰老师）"></a>2 对于es6模块的看法（参考阮一峰老师）</h3><ul>
<li><p><code>es6标准</code>将成为服务器和浏览器端模块化的<code>通用解决方法</code> </p>
</li>
<li><p><code>运行时加载</code>：代码运行到这个语句的时候才会加载 </p>
</li>
<li><p><code>编译时加载</code>：打包工具编译js时，就会去分析模块之间的依赖关系，所以不能放在任何条件代码块里。层级最优先</p>
</li>
<li><p>es6模块中的this指向是undefined，不要轻易用this, CommonJs中的this指向当前模块</p>
</li>
<li><p>export的使用，如果需导出的模块前面没有export，那在export的时候就要加上{}</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;fn&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>export导出语句是动态绑定的，如果导出的值发生变化，那import进的值也会随之变化</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// exportJs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; () =&gt; foo = <span class="string">&#x27;baz&#x27;</span>; &#125;,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">那么foo变量值将在500ms后变成baz字符串，这点与<span class="string">`commonJS`</span>不一样，commonJs是会缓存值。</span><br></pre></td></tr></table></figure></li>
<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部并首先执行，但还是建议放在头部写比较好。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>; <span class="comment">// right </span></span><br></pre></td></tr></table></figure></li>
<li><p>*号指定整体输出的一个对象</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> funciton <span class="function"><span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 需要引入cilcle.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">circle.fn1();</span><br><span class="line">circle.fn2();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>export 的default输出，默认输出</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exportJs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// importJs</span></span><br><span class="line"><span class="keyword">import</span> customFn <span class="keyword">from</span> <span class="string">&#x27;./exportJS&#x27;</span></span><br><span class="line">customFn();</span><br></pre></td></tr></table></figure></li>
<li><p>import函数大括号的写法时机<br>export后面接着default的时候，不用大括号，没接着的时候是要大括号的。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无 default</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; fn1&#125; <span class="keyword">from</span> <span class="string">&#x27;exportJs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有default</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> fn2 <span class="keyword">from</span> <span class="string">&#x27;exportJs&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为静态分析没有运行时加载那么“动态化”，所以，import有个提案，目前可以在webpack使用，可以动态输入一个较为狭窄的路径，然后返回一个promise对象<br>这个情况下的import是支持<code>按需加载</code>，<code>条件加载</code>，和<code>动态的模块路径</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./someModule/$&#123;someVariable&#125;.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">module</span>.loadPageInfo(main)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        mian.textContent = err.message;                                                 </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>script标签的defer和async属性差异，两者都是取消了js的同步属性。<br>但是defer是<code>渲染完再执行</code>，而async是<code>下载完就执行</code>。</p>
</li>
<li><p>待验证：es6模块在网页上的加载</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;./util.js&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>es6模块，导出的变量不可以重新赋值，但可以添加或修改属性，就是内存地址不能改，里面存的内容随你改，待验证。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">&#x27;lib&#x27;</span></span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// right</span></span><br><span class="line">obj = &#123;&#125;        <span class="comment">// typeError</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>import</code>命令加载<code>commonJS</code>模块，Node会自动将<code>module.exports</code>当成模块的默认输出，即等同于<code>export default</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#123;default: null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; somethimg &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span> <span class="comment">// error！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = express.default() <span class="comment">// right</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>commonJs</code>的加载原理<br>commonJs每个模块都是一个脚本文件，Node内部用require命令第一次加载就会执行这个脚本，然生成一个对象，这个会缓存，即是多次require，不清缓存下，都取第一次。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,         <span class="comment">// 模块名</span></span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;,    <span class="comment">// 导出模块, </span></span><br><span class="line">    <span class="attr">loaded</span>: <span class="literal">true</span>    <span class="comment">// 是否加载过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>循环加载：模块之间相互引用<br>CommonJs会出现，输出已执行的部分，未执行的部分不会输出<br>es6模块则不会报错</p>
</li>
</ul>
<p>参考文章：<br><a href="https://juejin.im/post/58882a42128fe100684ad9de">掘金</a><br>阮一峰es6 模块篇章</p>
]]></content>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM实现（Object.defineProperty &amp;&amp; 观察订阅）</title>
    <url>/2020/07/23/MVVM/</url>
    <content><![CDATA[<h3 id="1-MVVM特点图解"><a href="#1-MVVM特点图解" class="headerlink" title="1. MVVM特点图解"></a>1. MVVM特点图解</h3><p><img src="/MVVM/MVVM1.png" alt="MVVM注解图1"><br><img src="/MVVM/MVVM2.png" alt="MVVM注解图2"><br><img src="/MVVM/MVVM3.png" alt="MVVM注解图3"><br><img src="/MVVM/MVVM4.png" alt="MVVM注解图4"><br><img src="/MVVM/MVVM5.png" alt="MVVM注解图5"></p>
<h3 id="2-MVVM的功能："><a href="#2-MVVM的功能：" class="headerlink" title="2. MVVM的功能："></a>2. MVVM的功能：</h3><ul>
<li>给所有data属性值都设置数据劫持，绑定好属性观察。（<em>也是深度响应原理</em>）</li>
<li>结合观察订阅者模式</li>
</ul>
<h3 id="3-代码实现：-MVVM-包含双向数据绑定、v-model、computed"><a href="#3-代码实现：-MVVM-包含双向数据绑定、v-model、computed" class="headerlink" title="3.代码实现：(MVVM 包含双向数据绑定、v-model、computed)"></a>3.代码实现：(<code>MVVM </code>包含双向数据绑定、<code>v-model</code>、<code>computed</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * let zs = new Vue(&#123;</span></span><br><span class="line"><span class="comment"> *     el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="comment"> *     data: &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment"> * &#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>options 参考vue实例化时传进的对象,代表我们存储的所有对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoVue</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options;  <span class="comment">// 当前实例，存储存进的对象</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">this</span>._data = <span class="built_in">this</span>.$options.data;  <span class="comment">// 当前实例，存储options.data 准备像vue一样观察数据</span></span><br><span class="line">    observe(data);</span><br><span class="line">    <span class="comment">// 为了代理_data属性。可以直接在实例的时候取到data，再用define一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,key,&#123;</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>._data[key]; <span class="comment">// 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>._data[key] = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> computed = <span class="built_in">this</span>.$options.computed;</span><br><span class="line">    operatedComputed.call(<span class="built_in">this</span>)  <span class="comment">// computedde 的操作需放在数据都已被观察完，并挂载到_data里</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">new</span> Compile(options.el, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operatedComputed</span>(<span class="params"></span>) </span>&#123; <span class="comment">// computed 处理函数</span></span><br><span class="line">    <span class="keyword">let</span> vm = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> computedFn = <span class="built_in">this</span>.$options.computed</span><br><span class="line">    <span class="built_in">Object</span>.keys(computedFn).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// computed挂载到vm上</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(vm,key,&#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">typeof</span> computedFn[key] === <span class="string">&#x27;function&#x27;</span> ?  computedFn[key] : computedFn[key].get,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 数据劫持，增加Object.defineProperty</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Observe(data); <span class="comment">// 方便递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把数据编译到dom上，实现数据绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>el 替换的dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>vm 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * note:</span></span><br><span class="line"><span class="comment"> * (1) 文档碎片</span></span><br><span class="line"><span class="comment"> * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]</span></span><br><span class="line"><span class="comment"> * (3)正则图形化 https://regexper.com/</span></span><br><span class="line"><span class="comment"> * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">    vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment(); <span class="comment">// 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低</span></span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="comment">// 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方</span></span><br><span class="line">    <span class="comment">// 因此vm.$el.firstChild才会不停地切换成下一个子节点。</span></span><br><span class="line">    <span class="comment">// --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (child = vm.$el.firstChild) &#123;</span><br><span class="line">        fragment.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    replace(fragment);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Array.from 将伪数组对象转为数组实例</span></span><br><span class="line"><span class="comment">      textContext: 节点内容</span></span><br><span class="line"><span class="comment">      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字</span></span><br><span class="line"><span class="comment">      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Array</span>.from(fragment.childNodes).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> text = node.textContent;</span><br><span class="line">            <span class="keyword">let</span> exp;</span><br><span class="line">            <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">               exp = text.replace(reg, <span class="string">&#x27;$1&#x27;</span>); <span class="comment">// 正则匹配中第一个括号所代表的内容</span></span><br><span class="line">                <span class="keyword">let</span> pointArr = exp.split(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// a.a b</span></span><br><span class="line">                <span class="keyword">let</span> existVal = vm;</span><br><span class="line">                pointArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">// vm.a.a  vm.b</span></span><br><span class="line">                    existVal = existVal[key];</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 添加一个watcher事件 监听了值的变化</span></span><br><span class="line">                <span class="keyword">new</span> Watcher(vm,exp,<span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                    node.textContent = text.replace(reg, newVal);</span><br><span class="line">                &#125;);</span><br><span class="line">                 <span class="comment">// @todo此处parser有待完善，只能兼容纯&#123;&#123;&#125;&#125;，带上其他字符会让existVal失效</span></span><br><span class="line">                node.textContent = text.replace(reg, existVal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">1</span> ) &#123; <span class="comment">// v-model实现</span></span><br><span class="line">                <span class="keyword">let</span> attr = <span class="built_in">Array</span>.from(node.attributes)</span><br><span class="line">                <span class="keyword">let</span> attr_value;</span><br><span class="line">                attr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (item.name === <span class="string">&#x27;v-model&#x27;</span>) &#123;</span><br><span class="line">                        attr_value = item.value</span><br><span class="line">                        <span class="keyword">new</span> Watcher(vm,attr_value, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                            node.value = newVal</span><br><span class="line">                        &#125;)</span><br><span class="line">                        node.addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                            vm[attr_value] = e.target.value</span><br><span class="line">                        &#125;)  </span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.childNodes) &#123;</span><br><span class="line">                replace(node);</span><br><span class="line">            &#125;</span><br><span class="line">            vm.$el.appendChild(fragment); <span class="comment">// 文档碎片的内容重新添加到原来挂载的元素里</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 实际观察方法,设置 Object.defineProperty</span></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = data[key];</span><br><span class="line">        observe(val); <span class="comment">// 这里就已经可以递归了</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data,key, &#123;</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 此时Dep.target是this</span></span><br><span class="line">                <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                    dep.addSub(Dep.target); <span class="comment">// 添加事件订阅（watcher 的 push）</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (newVal ===  val) &#123; <span class="comment">// 值没发生变化</span></span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    val = newVal; <span class="comment">// 更新值。get获取值时，也可以得到最新的值。</span></span><br><span class="line">                    observe(newVal); <span class="comment">// 这里是为了给新值也添上观察者</span></span><br><span class="line">                    dep.notify(); <span class="comment">// 添加事件的通知更新（watcher的update）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Dep</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []; <span class="comment">// 事件池</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">sub</span>) </span>&#123; <span class="comment">// 订阅</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 通知</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">        sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件池其中的一个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>vm: 实例环境（总的数据来源）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>正则表达式的遍历对象exp (要更改的对象)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn（处理的回调函数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm,exp,fn</span>) </span>&#123; <span class="comment">// fn是回调函数 new的时候传进来</span></span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.exp = exp;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到订阅中</span></span><br><span class="line">    <span class="comment">// Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> val = vm;</span><br><span class="line">    <span class="keyword">let</span> arr = exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123; <span class="comment">// 这里获取 this.a.a时还是会触发到默认的getter</span></span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// watcher的更新方法</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">this</span>.vm;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">this</span>.exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123;</span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.fn(val); <span class="comment">// 把最新值传进callback</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;a.a&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;b&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;cacultate_c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;script src=&quot;../dist/my_bundle.js&quot;&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./compile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 调用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> little = <span class="keyword">new</span> demoVue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">a</span>: &#123;<span class="attr">a</span>:<span class="string">&quot;是a&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">b</span>: <span class="string">&quot;是b&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">cacultate_c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.a.a + <span class="built_in">this</span>.b;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">cacultate_d</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.a.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.b</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.a = val</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>1、 <code>Object.defineProperty</code> 给对象设置某属性，并且可以设置setter，用于绑定属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;school&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 让 delete 更新属性值 生效</span></span><br><span class="line">    <span class="attr">enumberable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123; <span class="comment">// 设置值时触发</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setting &#x27;</span>)</span><br><span class="line">        obj.school = val <span class="comment">// 超出内存 mag size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.im/post/5e7410ed51882549087dc365#heading-0">掘金 - MVVM</a><br><a href="https://blog.csdn.net/hf872914334/article/details/88899326">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href="https://zhuanlan.zhihu.com/p/51357583">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href="https://segmentfault.com/a/1190000019700618">Vue2.0响应原理</a></p>
]]></content>
      <tags>
        <tag>MVVM 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA</title>
    <url>/2020/02/06/PWA/</url>
    <content><![CDATA[<h3 id="1-PWA是什么？（Progressive-Web-App）"><a href="#1-PWA是什么？（Progressive-Web-App）" class="headerlink" title="1.PWA是什么？（Progressive Web App）"></a>1.PWA是什么？（<code>Progressive Web App</code>）</h3><p>书面上意思：渐进式网络应用<br>特点：</p>
<ul>
<li>稳定：不好的网络环境下也有好的展现数据能力（<code>service worker</code>）</li>
<li>过渡自然的动画交互，良好的滚动，响应快</li>
<li>像原生一般丝滑，可以推送，可安装</li>
<li>android支持度好，apple支持度差</li>
</ul>
<h3 id="1-1-关键技术"><a href="#1-1-关键技术" class="headerlink" title="1.1 关键技术"></a>1.1 关键技术</h3><ul>
<li>service worker : 一个存在于客户端和服务器之间的代理，可以控制缓存和应对资源请求,预缓存关键资源。所以它对安全的要求也很高，需要在Https环境下运行。</li>
<li>manifest: （可以理解为一个可设置的入口文件）<br>​              能够将你浏览的网页添加到你的手机屏幕上<br>​              在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）<br>​              控制屏幕 横屏 / 竖屏 展示<br>​              定义启动画面<br>​              可以设置你的应用启动是从主屏幕启动还是从 URL 启动<br>​              可以设置你添加屏幕上的应用程序图标、名字、图标大小</li>
</ul>
<h3 id="2-可以用来干嘛呢"><a href="#2-可以用来干嘛呢" class="headerlink" title="2.可以用来干嘛呢"></a>2.可以用来干嘛呢</h3><ul>
<li>推送，这点需要安卓去验证，目前PWA的支持度仅是安卓比较好。ios的google浏览器也不支持</li>
<li>离线缓存。 可以设置缓存的资源，即使离线也可以访问</li>
</ul>
<h3 id="3-DEMO"><a href="#3-DEMO" class="headerlink" title="3. DEMO"></a>3. DEMO</h3><p>demo已放在mineScript文件夹下<br>github地址是：<a href="https://github.com/jonnzer/good_snippet/tree/master/PWA">demo</a></p>
<ul>
<li>代码结构：</li>
</ul>
<ul>
<li>sw.js: 引入serviceWorker.js，定义缓存资源，部署整个sw的生命周期代码</li>
<li>manifest.json: 一个定义好背景颜色，展示图片，icon，的入口文件。</li>
<li>建议部署在https环境下的cdn。</li>
</ul>
<p>参考链接：<br><a href="https://developers.google.com/web/progressive-web-apps/">官网</a><br><a href="https://juejin.im/post/5ae2f82f6fb9a07acd4d761e">掘金1</a><br><a href="https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6">serviceWorker的调试</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>apollo主题增加Valine评论</title>
    <url>/2020/07/11/apollo%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0Valine%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><p>大道至简<br>最近刚迁移主题到<code>Apollo</code>，相当清新的主题，具体的参考<a href="https://github.com/pinggod/hexo-theme-apollo">github</a></p>
<h4 id="评论系统的选择"><a href="#评论系统的选择" class="headerlink" title="评论系统的选择"></a>评论系统的选择</h4><p>从支持的表情与颜值上来看，果断选择了<code>Valine</code><br>效果图可以看博客下方😊</p>
<div class="tip">
    因为Apollo主题已经关闭issue，所以只能自己去增加评论的初始化代码了
</div> 

<h4 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h4><p>1 <code>themes/apollo/_config.yml</code>:<br>    <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">    <span class="comment"># 开启 Valine 评论</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 设置应用 id 和 key</span></span><br><span class="line">    <span class="attr">appId:</span> <span class="string">您的appId</span></span><br><span class="line">    <span class="attr">appKey:</span> <span class="string">您的appkey</span></span><br></pre></td></tr></table></figure><br>2 <code>themes/apollo/source/js/Valine.min.js</code>： 拷贝Valinecdn路径，缓存到本地，以防万一<br>3 <code>themes/apollo/layout/partial/head.jade</code>: 增加引用<code>script(src=url_for(&quot;js/Valine.min.js&quot;))</code><br>4 <code>themes/apollo/layout/partial/comment.jade</code>: 增加主题的评论判断<br>     <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.valine</span><br><span class="line">    div#vcomments</span><br><span class="line">    <span class="comment">//script(src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;)</span></span><br><span class="line">    script.</span><br><span class="line">        <span class="keyword">new</span> Valine(&#123; <span class="comment">// 里面的参数配置具体参考Valine官网</span></span><br><span class="line">            <span class="attr">el</span>: <span class="string">&#x27;#vcomments&#x27;</span>,</span><br><span class="line">            <span class="attr">appId</span>: <span class="string">`#&#123;theme.valine.appId&#125;`</span>,</span><br><span class="line">            <span class="attr">appKey</span>: <span class="string">`#&#123;theme.valine.appKey&#125;`</span>,</span><br><span class="line">            <span class="attr">placeholder</span>: <span class="string">&#x27;快来评论吧(#^.^#)&#x27;</span>,</span><br><span class="line">            <span class="attr">avatar</span>: <span class="string">&#x27;wavatar&#x27;</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考<br><a href="https://www.playpi.org/2019032001.html">Valine前后所需介绍</a><br><a href="https://valine.js.org/">Valine官网</a></p>
]]></content>
      <tags>
        <tag>Apollo Hexo Valine</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见技巧</title>
    <url>/2020/05/26/array/</url>
    <content><![CDATA[<h3 id="1-数组降维"><a href="#1-数组降维" class="headerlink" title="1. 数组降维"></a>1. 数组降维</h3><p>二维数组降维成一维数组（引自vue源码）</p>
<blockquote>
<p>利用原理：<br>(1) <code>concat</code>的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；<br>(2) <code>apply</code>的优化：<code>Array.prototype.concat.apply</code>([], children) 等同于 [].concat(demoArr)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demoArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">22</span>,<span class="number">23</span>,<span class="number">43</span>]]</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">simpleNormalizeChildren(demoArr)  </span><br><span class="line"><span class="comment">// result =&gt;  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>多维数组递归降维(借助了<code>递归</code>的能力)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> children = [<span class="number">1</span>, [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]], [<span class="number">9</span>, <span class="number">10</span>]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      children = <span class="built_in">Array</span>.prototype.concat.apply([], children);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j&lt;children.length; j++) &#123;</span><br><span class="line">        simpleNormalizeChildren(children)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line">simpleNormalizeChildren(children); </span><br><span class="line"><span class="comment">// result =&gt;  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2. 数组去重"></a>2. 数组去重</h3><p>（1） ES6 <code>set</code>方法 (Set 对象允许你存储任何类型的唯一值)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line"> <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"> <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;] </span></span><br></pre></td></tr></table></figure>
<div class="tip">
  set方法无法识别重复的{}空对象
</div> 

<p>（2）双重for循环，splice去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//前者等于后者的时候，splice方法删除后者</span></span><br><span class="line">                    arr.splice(j,<span class="number">1</span>);</span><br><span class="line">                    j--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">     <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="tip">
NaN和{}没有去重，两个null直接消失了
</div>


<p>(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">           <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">   <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  </span></span><br></pre></td></tr></table></figure>
<div class="tip">
NaN、{}没有去重</div>

<p>(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> seen; <span class="comment">// 动态指针</span></span><br><span class="line">  <span class="comment">// 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数</span></span><br><span class="line">  <span class="keyword">var</span> targetArr = <span class="built_in">Array</span>.prototype.concat.call(arr).sort() </span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="comment">// 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;targetArr.length; i++) &#123; </span><br><span class="line">     <span class="comment">// 这里 0转为boolean是false，!0即true</span></span><br><span class="line">    <span class="comment">// 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素</span></span><br><span class="line">    <span class="keyword">if</span> (!i || seen !== targetArr[i]) &#123;</span><br><span class="line">      result.push(targetArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    seen = targetArr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">         <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure>

<div class="tip">
  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。
</div>

<p>(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法<br> <code>array</code>： 必填参数，去重目标数组<br><code>isSorted</code>: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf<br><code>iteratee</code>: 自定义对目标数组的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array, isSorted, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> seen = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = array[i];</span><br><span class="line">        <span class="keyword">var</span> computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || seen !== computed) &#123;</span><br><span class="line">                res.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">            seen = computed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.indexOf(computed) === -<span class="number">1</span>) &#123;</span><br><span class="line">                seen.push(computed);</span><br><span class="line">                res.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res.indexOf(value) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(value);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array3, <span class="literal">false</span>, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> item == <span class="string">&#x27;string&#x27;</span> ? item.toLowerCase() : item</span><br><span class="line">&#125;)); <span class="comment">// [1, &quot;a&quot;, 2]</span></span><br></pre></td></tr></table></figure>

<p>(6) 利用Object的key是唯一的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) </span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是叹为观止，妙！妙在哪？</p>
<ul>
<li><code>array.filter</code>本身就兼职<code>遍历，过滤，返回新数组</code>于一身，干净利落</li>
<li>Object的<code>key确实是唯一</code>的，如果重复时候，只能是覆盖value的</li>
<li>filter过滤条件需要的<code>true和false</code>就由 Obj是否包含这个<code>type+value</code>为key  来决定，<br>如果之前没存进obj，可以任意设置一个value，就是三元运算符里的<code>obj[typeof item + item] = true</code></li>
</ul>
<hr>
<h3 id="API补充："><a href="#API补充：" class="headerlink" title="API补充："></a>API补充：</h3><ol>
<li><code>reduce</code></li>
</ol>
<p>升序让数组每一项都调用传入函数，可以设置初始值。<br>四个参数<br><code>Accumulator</code> (acc) (累计器)<br><code>Current Value</code> (cur) (当前值)<br><code>Current Index</code> (idx) (当前索引)<br><code>Source Array </code>(src) (源数组)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 统计出现次数</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tiff&#x27;</span>, <span class="string">&#x27;Bruce&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>];</span><br><span class="line"><span class="comment">// allNames为Accumulator累积器，name为当前值</span></span><br><span class="line"><span class="keyword">var</span> countedNames = names.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">allNames, name</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (name <span class="keyword">in</span> allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    allNames[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// countedNames is:</span></span><br><span class="line"><span class="comment">// &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// proxy结合reduce实现 链式调用函数封装 需是get结尾</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">// value是参数 闭包缓存funcStack数组</span></span><br><span class="line">          <span class="keyword">var</span> funcStack = [];</span><br><span class="line">          <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">              <span class="attr">get</span> : <span class="function"><span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) </span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">&#x27;fnName is:&#x27;</span> + fnName)</span><br><span class="line">                  <span class="keyword">if</span> (fnName === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">                      <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> fn(val);</span><br><span class="line">                      &#125;,value);</span><br><span class="line">                  &#125;</span><br><span class="line">                  funcStack.push(<span class="built_in">window</span>[fnName]);</span><br><span class="line">                  <span class="built_in">console</span>.log(funcStack)</span><br><span class="line">                  <span class="keyword">return</span> oproxy;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> oproxy;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line">  <span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(pipe(<span class="number">3</span>)[<span class="string">&#x27;double&#x27;</span>].pow.get);</span><br><span class="line">  <span class="comment">// pipe(3).double.pow.reverseInt.get; // 63 </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>slice</code><br>类数组 =&gt; 真数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以写成 [].slice.call(arguments) </span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.from</code><br>从一个类似数组或可迭代对象创建一个新的，<code>浅拷贝</code>的数组实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure>
<p><code>arrayLike</code>：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。<br><code>mapFn</code> 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。<br><code>thisArg</code> 可选：可选参数，执行回调函数 mapFn 时 this 对象。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someNumbers = &#123; <span class="string">&#x27;0&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">15</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(someNumbers, <span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>); <span class="comment">// =&gt; [20, 30] 这里利用了mapFn的能力</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">sum, num</span>) =&gt;</span> sum + num);</span><br><span class="line">&#125;</span><br><span class="line">sumArguments(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// =&gt; 6 //这里利用了转化伪数组成真数组的能力</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><code>Array.concat()</code> 不传参数的时候，是一种浅拷贝的行为</p>
</li>
<li><p><code>Array.filter(function()&#123;&#125;)</code>  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure>
<p><code>callback</code>: 用来测试数组元素的函数 return true时 保留元素 否则不保留。<br><code>index</code>: 当前处理索引<br><code>array</code>: 调用了filter的数组本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</span><br></pre></td></tr></table></figure>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">MDN - slice</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN - reduce</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">MDN - typeof</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from">MDN - Array.from</a><br><a href="https://juejin.im/post/5b4d35406fb9a04fd55ac064">掘金 reduce</a><br><a href="https://juejin.im/post/5d66b019f265da03a715e5d7">掘金 Array.from</a><br><a href="https://www.lagou.com/lgeduarticle/86449.html">拉钩博文</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/27">冴羽 Array去重 issue</a><br><a href="http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html">阮一峰 reduce transduce 关于 函数编程</a></p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>call &amp;&amp; apply &amp;&amp; bind</title>
    <url>/2020/04/09/call&amp;apply&amp;bind/</url>
    <content><![CDATA[<h4 id="1-apply"><a href="#1-apply" class="headerlink" title="1. apply"></a>1. apply</h4><p>调用一个具有<code>给定this值</code>的函数，以及<code>作为一个数组（或类似数组对象）</code>提供的参数。<br>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>

<div class="tip">
        如果这个函数处于非严格模式下，`thisArg`指定为 `null` 或 `undefined` 时会自动替换为`指向全局对象`，原始值会被包装！！！
</div>

<p> 基础用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"><span class="built_in">console</span>.log(max);<span class="comment">// expected output: 7</span></span><br></pre></td></tr></table></figure>

<p>将A数组里的元素都添加到B数组 （apply有种<code>循环参数数组</code>的能力）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.push.apply(BArray,AArray)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">BArray.push(...AArray)</span><br></pre></td></tr></table></figure>

<h4 id="2-call"><a href="#2-call" class="headerlink" title="2. call"></a>2. call</h4><p>调用一个具有<code>给定this值</code>的函数，以及一个或多个参数。<br>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.call(thisArg, arg1, arg2, ...) </span><br></pre></td></tr></table></figure>

<p>用来继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  Product.call(<span class="built_in">this</span>, name, price);</span><br><span class="line">  <span class="built_in">this</span>.category = <span class="string">&#x27;food&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Food(<span class="string">&#x27;cheese&#x27;</span>, <span class="number">5</span>).name);</span><br><span class="line"><span class="comment">// expected output: &quot;cheese&quot;</span></span><br></pre></td></tr></table></figure>

<p>绑定上下文</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reply = [<span class="built_in">this</span>.animal, <span class="string">&#x27;typically sleep between&#x27;</span>, <span class="built_in">this</span>.sleepDuration].join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">animal</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">sleepDuration</span>: <span class="string">&#x27;12 and 16 hours&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet.call(obj);  <span class="comment">// cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure>

<p>非严格模式下，不传值则默认上下文是全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sData = <span class="string">&#x27;Wisen&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sData value is %s &#x27;</span>, <span class="built_in">this</span>.sData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display.call();  <span class="comment">// sData value is Wisen   这里上下文是window</span></span><br></pre></td></tr></table></figure>

<h4 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind"></a>3.bind</h4><p>该方法创建一个新的函数，在 <code>bind() </code>被调用时，这个<code>新函数</code>的 <code>this 被指定为 bind() 的第一个参数</code>，而其余参数将作为新函数的参数，供调用时使用。<br>也就是说，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。<br>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<div class="tip">
1 使用`new`构造函数时，忽略`thisArg` 
---※---
2 在`setTimeout`中回调函数使用时，`thisArg`的任何值都将转化成`object`
---※---
3 如果`thisArg`为`null或undefined`，`执行作用域中的this`将作为新的`thisArg`
</div> 


<p>基础用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unboundGetX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(unboundGetX());</span><br><span class="line"><span class="comment">// expected output: window.x =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGetX = unboundGetX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundGetX());</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<p>偏函数<br>bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。<br>只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。<br>当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addArguments</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = addArguments(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设参数列表。</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">null</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> addThirtySeven = addArguments.bind(<span class="literal">null</span>, <span class="number">37</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); </span><br><span class="line"><span class="comment">// [37]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// [37, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = addThirtySeven(<span class="number">5</span>); </span><br><span class="line"><span class="comment">// 37 + 5 = 42 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = addThirtySeven(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 37 + 5 = 42 ，第二个参数被忽略</span></span><br></pre></td></tr></table></figure>

<p>有意思的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(unboundSlice);</span><br><span class="line"> <span class="comment">// 这里的Function.prototype.apply 其实就是apply函数 </span></span><br><span class="line">slice(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 等同于 apply.bind(unboundSlice); 也就是slice === Array.prototype.slice</span></span><br></pre></td></tr></table></figure>


<p>假如不支持<code>bind</code>的时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Does not work with `new (funcA.bind(thisArg, args))`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thatFunc = <span class="built_in">this</span>, thatArg = <span class="built_in">arguments</span>[<span class="number">0</span>]; <span class="comment">// 缓存调用函数，this指向，其它参数</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> thatFunc !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - &#x27;</span> +</span><br><span class="line">             <span class="string">&#x27;what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> funcArgs = args.concat(slice.call(<span class="built_in">arguments</span>)) <span class="comment">// 其它参数合并传入参数，并成统一的函参</span></span><br><span class="line">      <span class="keyword">return</span> thatFunc.apply(thatArg, funcArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="4-三者同否"><a href="#4-三者同否" class="headerlink" title="4. 三者同否"></a>4. 三者同否</h4><ul>
<li>apply是传参数数组(参数不确定)，call是传参数(参数确定)</li>
<li>apply、call、bind 三者都是为了<code>改变上下文</code>，改变函数<code>内部this</code>的指向</li>
<li>通过apply这种方式，您将面临超过JavaScript引擎的参数长度限制的风险</li>
<li>多次bind也只是bind第一次绑定的值</li>
</ul>
<p>参考链接：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN 关于 apply</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN 关于 bind</a><br><a href="https://www.cnblogs.com/coco1s/p/4833199.html">ChokCocoblog</a><br><a href="https://muyiy.cn/blog/3/3.3.html#call-%E5%92%8C-apply">模拟实现</a></p>
]]></content>
      <tags>
        <tag>面试 JS</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2018/06/17/nginx%E7%A7%91%E6%99%AE%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="nginx-是什么？"><a href="#nginx-是什么？" class="headerlink" title="nginx 是什么？"></a>nginx 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态资源HTTP 服务器。通过http协议将静态资源路径暴露给客户端。</span><br><span class="line">反向代理服务器。介乎客户端和服务器的中间层，可以做虚拟主机，和负载均衡</span><br></pre></td></tr></table></figure>

<h4 id="虚拟主机-是什么？（网站访问量小的情况）"><a href="#虚拟主机-是什么？（网站访问量小的情况）" class="headerlink" title="虚拟主机 是什么？（网站访问量小的情况）"></a>虚拟主机 是什么？（网站访问量小的情况）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多域名对应同一服务器，对应同一ip，却可以打开不同网站。仿佛就像两个服务器，所以称为虚拟主机，也可以称为多开。</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡-是什么-（网站访问量大的情况）"><a href="#负载均衡-是什么-（网站访问量大的情况）" class="headerlink" title="负载均衡 是什么? （网站访问量大的情况）"></a>负载均衡 是什么? （网站访问量大的情况）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过反向代理的身份，把自己写的应用部署在多个服务器上。其实说白了，就是一份nginx配置，上面很多ip地址，会自动轮询ip地址，并根据weight的值来判断分配给指定ip的服务器的权重。</span><br></pre></td></tr></table></figure>

<h4 id="nginx-怎么配置？"><a href="#nginx-怎么配置？" class="headerlink" title="nginx 怎么配置？"></a>nginx 怎么配置？</h4><p><a href="https://blog.csdn.net/lihang_1994/article/details/72598955">具体参考链接</a></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>proxy</title>
    <url>/2020/06/14/proxy/</url>
    <content><![CDATA[<p><code>vue</code>源码的render部分，曾用到<code>proxy</code>来代理vue的实例。</p>
<h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1 概念："></a>1 概念：</h3><p><code>proxy</code> 原意就有代理的意思。它是外界访问对象的一层<code>代理控制</code>，也是对访问的一种<code>改写和过滤</code>。属于一种<code>元编程</code>。</p>
<h3 id="2-作用："><a href="#2-作用：" class="headerlink" title="2 作用："></a>2 作用：</h3><p>可以从获取和设置两种时机去代理指定对象</p>
<h3 id="3-代码结构："><a href="#3-代码结构：" class="headerlink" title="3 代码结构："></a>3 代码结构：</h3><p>标准结构：</p>
<blockquote>
<p>var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// 默认是&#123;&#125;    </span></span><br><span class="line">obj.a = <span class="number">1</span> <span class="comment">// setting a</span></span><br><span class="line">obj.a = <span class="number">2</span> <span class="comment">// setting a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// getting a</span></span><br></pre></td></tr></table></figure>

<h3 id="4-要注意的点："><a href="#4-要注意的点：" class="headerlink" title="4. 要注意的点："></a>4. 要注意的点：</h3><ul>
<li><p>要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。</p>
</li>
<li><p>与原型的应用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> _obj = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line">_obj.time <span class="comment">// 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-proxy还支持get、set之外的api补充"><a href="#5-proxy还支持get、set之外的api补充" class="headerlink" title="5. proxy还支持get、set之外的api补充"></a>5. proxy还支持get、set之外的api补充</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123; <span class="comment">// proxy实例作为函数调用时触发</span></span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123; <span class="comment">// proxy作为构造函数时触发</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">&quot;Hello, foo&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 拦截 负数索引</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">     <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, receiver</span>) </span>&#123; </span><br><span class="line">         <span class="keyword">let</span> index = <span class="built_in">Number</span>(property) <span class="comment">// -1 会作为属性传进来</span></span><br><span class="line">         <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             property = <span class="built_in">String</span>(target.length + index) <span class="comment">// property\target 是可以修改的 奇怪...</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver) <span class="comment">// Reflect is what</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> target = []</span><br><span class="line"> target.push(...elements)</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">&#125;</span><br><span class="line">arr = createArray(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子"><a href="#6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子" class="headerlink" title="6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)"></a>6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, propKey</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;foo&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;123&#x27; but got &#x27;abc&#x27;)</span></span><br></pre></td></tr></table></figure>

<hr>
<p>引申了解：</p>
<ul>
<li>元编程的概念</li>
<li>proxy的get和set，与 Object.defineProperty 相比，有什么区别<ul>
<li>答：<a href="https://juejin.im/post/5be4f7cfe51d453339084530">jueim</a> proxy的应用场景更多，但是define的兼容性更好</li>
<li>答：<a href="https://github.com/YvetteLau/Blog/issues/25">issue</a></li>
<li>答：<a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf">两者实现双向绑定差异</a></li>
</ul>
</li>
</ul>
<hr>
<p>参考文章：<br><a href="https://es6.ruanyifeng.com/#docs/proxy">阮一峰es6 proxy章节</a><br><a href="https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect">深入浅出es6系列</a><br><a href="https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect">segmentFault</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming">元编程</a></p>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>sql</title>
    <url>/2018/05/02/sql/</url>
    <content><![CDATA[<h4 id="为了新项目的sql存储，我觉得还是很有必要学下sql"><a href="#为了新项目的sql存储，我觉得还是很有必要学下sql" class="headerlink" title="为了新项目的sql存储，我觉得还是很有必要学下sql"></a>为了新项目的sql存储，我觉得还是很有必要学下sql</h4><pre><code>so～～ 开始！

刚开始就报了错，Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO)
用这个命令(登录MYSQL的意思)，mysql -uroot -p
然后重新输一遍密码
</code></pre>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>(1) sql命令必须带;分号，否则提示sql语句错误。
(2) 退出mysql： exit;
(3) MYSQL删除表 语法：drop table &#39;table_name&#39;;
(4) 创建数据库： create database databaseNname;
(5) show databases;  是用来看登陆后的用户有多少关联的数据库
(6) use database&#39;s name; 进入该数据库
(7) show tables; 查看该数据库的表格
(8) desc table&#39;s name; 查看该表的结构
</code></pre>
<h4 id="调试方案（基于mac-os）"><a href="#调试方案（基于mac-os）" class="headerlink" title="调试方案（基于mac os）"></a>调试方案（基于mac os）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="keyword">create</span> database name;</span><br><span class="line">use name;</span><br></pre></td></tr></table></figure>
<pre><code>    之后，可以在命令行 source (将sql文件拖拽进来，去掉file://)
    所以你可以本地写好sql文件，在命令行执行并检验
</code></pre>
<p>(2) 用sequel pro工具来查看sql图形化表格，对照看在命令行写的sql是否起效</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><img src='./package.png' style="width:50%;height:60%;">
参考链接 http://www.runoob.com/mysql/mysql-data-types.html

<h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `movie` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>  AUTO_INCREMENT,</span><br><span class="line">    `movie_name` <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `high_image` <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `content` <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>下面是增删改查，最重要的部分：</p>
<h3 id="增加，批量"><a href="#增加，批量" class="headerlink" title="增加，批量"></a>增加，批量</h3><figure class="highlight sql"><figcaption><span>(结构：INSERT INTO 表名 （要增加的列名）VALUES （对应的值）)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> movie (movie_name,high_image,content) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;头号玩家&#x27;</span>,<span class="string">&#x27;www.baidu.com/a.jpg&#x27;</span>,<span class="string">&#x27;VR高级模拟现实游戏&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;斗破苍穹&#x27;</span>,<span class="string">&#x27;www.baidu.com/b.jpg&#x27;</span>,<span class="string">&#x27;热血国漫&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;仙剑奇侠传&#x27;</span>,<span class="string">&#x27;www.baidu.com/c.jpg&#x27;</span>,<span class="string">&#x27;良心国产仙侠&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件"><a href="#改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件" class="headerlink" title="改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )"></a>改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE movie <span class="keyword">SET</span> high_image<span class="operator">=</span><span class="string">&#x27;www.touhaowanjia.com/1.jpg&#x27;</span> <span class="keyword">WHERE</span> movie_name<span class="operator">=</span><span class="string">&#x27;头号玩家&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删-结构：DELETE-FROM-表名-WHERE-匹配条件"><a href="#删-结构：DELETE-FROM-表名-WHERE-匹配条件" class="headerlink" title="删 (结构：DELETE FROM 表名 WHERE 匹配条件  )"></a>删 (结构：DELETE FROM 表名 WHERE 匹配条件  )</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> movie <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">9</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查-结构：SELECT-列-FROM-表名-WHERE-匹配条件"><a href="#查-结构：SELECT-列-FROM-表名-WHERE-匹配条件" class="headerlink" title="查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )"></a>查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )</h3><p>（1）查询所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> movie;</span><br></pre></td></tr></table></figure>
<p>（2）查询指定列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> content <span class="keyword">FROM</span> movie;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="报错处理："><a href="#报错处理：" class="headerlink" title="报错处理："></a>报错处理：</h3><pre><code>具体就看报错语句，提示在哪里附近报错，第几行，near 什么
</code></pre>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>upload之初探</title>
    <url>/2018/01/04/upload/</url>
    <content><![CDATA[<h4 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h4><blockquote>
<p>产品有做能多选的上传这个功能，开始倒腾。事实也踩了不少坑。现就开始梳理今天的思路。</p>
</blockquote>
<h4 id="框架选取"><a href="#框架选取" class="headerlink" title="框架选取"></a>框架选取</h4><ul>
<li>微信上传接口:<br>先上图 : 我们可以看到的是，它的接口 chooseImage 确是有这番作用。直接把朋友圈发照片的流程给调出来。可以预览，可以原图，很全面了。然而，它需要传到微信服务器走一遭，这是最让人难受的</li>
</ul>
<blockquote>
<p>弃用原因：本身我项目的图片存储是放在阿里云oss里，如今还得再经过微信服务器上传下载，就把这事搞麻烦了…</p>
</blockquote>
<p><img src='/upload/1.png' style="width:50%;height:60%;"><img src='/upload/2.png' style="width:50%;height:60%;"></p>
<ul>
<li>eleme-UI<br>还是先上图：它也是极好的，从UI美观角度看，或是它的功能性，都很接近理想了。可惜，它的上传只有一次，就是它的请求服务器Url只有一个，而且是在vue的html里渲染，这就更不好改了<blockquote>
<p> 弃用原因: 还是因为oss里的判断，有引进了两次请求，第一次是请求 下次请求要用上的地址和id 第二次则是真正和oss请求上传图。</p>
<img src='/upload/3.png' style="width:50%;height:60%;"></blockquote>
</li>
<li>plupload<br>还在研究中…是后台同事推荐的一个插件，据说oss就是官方支持这个，大喜之余就看看它文档。<h4 id="嗯。加油，明天继续倒腾！"><a href="#嗯。加油，明天继续倒腾！" class="headerlink" title="嗯。加油，明天继续倒腾！^_^"></a>嗯。加油，明天继续倒腾！^_^</h4></li>
</ul>
]]></content>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码分析</title>
    <url>/2020/04/27/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>网址：<br><a href="https://jiongks.name/blog/vue-code-review/">勾三股四</a><br><a href="https://github.com/HcySunYang/vue-design">授之以渔</a><br><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93">vue大概讲解</a><br><a href="https://github.com/answershuto/learnVue">染陌电子书</a><br><a href="https://www.cnblogs.com/QH-Jimmy/p/7210363.html">patch原理</a><br><a href="https://github.com/aooy/blog/issues/2">victual dom diff</a><br><a href="https://www.bookstack.cn/books/5865c0921b69e6006b3145a1">书栈网</a><br><a href="http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html">vue中的AST</a></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的后花园</title>
    <url>/2019/12/11/webpack/</url>
    <content><![CDATA[<h3 id="1-webpack底层"><a href="#1-webpack底层" class="headerlink" title="1.webpack底层"></a>1.webpack底层</h3><pre><code>它是一个打包工具。
webpack本身，在不借助loader的情况下，只会打包js。

（引用）webpack处理应用程序时，会递归的构建一个依赖关系图，其中包括应用程序需要的每个模块，然后把所有模块打包成一个或多个bundle。
</code></pre>
<h3 id="2-几个核心概念"><a href="#2-几个核心概念" class="headerlink" title="2.几个核心概念"></a>2.几个核心概念</h3><ul>
<li>入口</li>
<li>出口<ul>
<li>入口和出口很好理解，入口就是打包谁，出口就是要输出的文件。<br>entry:<br>output:{ path, filename }</li>
</ul>
</li>
<li>loader<ul>
<li>帮助webpack识别非js文件，包括css，图片等。</li>
<li>示例：<br>  test: 作用等同于正则里面的匹配<br>  use: 使用loader<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">emitWarning</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">emitError</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">failOnError</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [<span class="string">&quot;style-loader&quot;</span>,<span class="string">&quot;css-loader&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">            loader: <span class="string">&#x27;url-loader?limit=8192&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">cssSourceMap</span>:<span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">transformToRequire</span>:&#123;&#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">emitWarning</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">emitError</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">failOnError</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>plugins<br>我还没认真弄懂plugins，它好像有很多好用的功能。比如压缩js或者生成好的静态资源增加版本号。待研究 <em><strong>@todo</strong></em></li>
</ul>
<hr>
<p>常见问题：<br>1、webpack打包原理？<br>2、loader，plugins分别是？<br>3、热更新原理是？<br>4、webpack性能优化的方法？</p>
<hr>
<ul>
<li><p>webpack的打包原理：(树状依赖)</p>
<ul>
<li>利用babel完成代码转换,并生成单个文件的依赖.</li>
<li>从入口开始递归分析，并生成依赖图谱</li>
<li>将各个引用模块打包为一个<code>立即执行</code>函数</li>
<li>将最终的bundle文件写入bundle.js中</li>
</ul>
</li>
<li><p>loader其实就是一个<code>Node.js</code> 模块，这个模块需要导出一个函数</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>工具 webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>事件</title>
    <url>/2018/07/27/%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>介绍下事件流：<br>三个阶段：捕获、目标、冒泡<br><img src="/%E4%BA%8B%E4%BB%B6/%E4%BA%8B%E4%BB%B6%E6%B5%81.jpg" alt="事件流"></p>
<p>冒泡，字面上理解，就是从下往上冒泡，咕噜咕噜～可以理解成从具体节点到不具体节点的事件流（<code>addEventListener</code>默认监听选项）</p>
<p>捕获，与冒泡相反，就是从大节点一直往下获取事件流，直到具体节点</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>外级元素被委托，当子级元素被触发事件时，由外级元素统一去处理事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jq</span></span><br><span class="line">$(<span class="string">&#x27;.top_wrapper a&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index,item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aLink = $(item).attr(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!aLink.includes(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">        aLink += <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coupon) &#123;</span><br><span class="line">        aLink +=<span class="string">`&amp;coupon=<span class="subst">$&#123;coupon&#125;</span>`</span>;</span><br><span class="line">        $(item).attr(<span class="string">&#x27;href&#x27;</span>,aLink );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qd) &#123;</span><br><span class="line">        aLink +=<span class="string">`&amp;qd=<span class="subst">$&#123;qd&#125;</span>`</span>;</span><br><span class="line">        $(item).attr(<span class="string">&#x27;href&#x27;</span>,aLink );</span><br><span class="line">    &#125;</span><br><span class="line">    $(item).attr(<span class="string">&#x27;href&#x27;</span>, aLink);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 原生</span></span><br><span class="line">    &lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#list&#x27;</span>)</span><br><span class="line">    list.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.target.tagName === <span class="string">&#x27;LI&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;当前元素事件触发成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p><code>addEventListener(eventName,function,bool)</code> // eventName事件名 function是触发的函数 bool为true时是捕获 默认是false冒泡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#list&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    list.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// elem.closest(selector) 方法返回与 selector 匹配的最近的祖先。&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 在我们的例子中，我们从源元素开始向上寻找 &lt;li&gt;。</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 限定不超出ul#list的范围</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> li = e.target.closest(<span class="string">&#x27;li&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (!li) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span>(!list.contains(li)) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(li)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>(1) 内联 (优先级最高)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(1);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2) 对象.事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="tip">以上两种方式只能绑定一个事件</div>

<p>(3) addEventListener</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">bt.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>event.stopPropagation: 阻止捕获和冒泡阶段中当前事件的进一步传播。<br>event.preventDefault: 阻止默认行为,调用了后就会取消事件的执行。</p>
<hr>
<p>参考：<br><a href="https://segmentfault.com/a/1190000013434835">segment</a><br><a href="https://zh.javascript.info/event-delegation">javascript.info</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation">event.stopPropogation</a></p>
]]></content>
      <tags>
        <tag>事件 JS</tag>
      </tags>
  </entry>
  <entry>
    <title>偏函数</title>
    <url>/2020/07/02/%E5%81%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>我的理解是，传入并缓存固定的参数，返回指定的函数。<br>而且是一种特别的柯里化。<br>柯里化是一参变多参。<br>偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。</p>
<p>参考：<br><a href="https://blog.csdn.net/qq_15241071/article/details/80036346">blog</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆对象&amp;&amp;数组（一）</title>
    <url>/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="1-从数据类型说起"><a href="#1-从数据类型说起" class="headerlink" title="1 从数据类型说起"></a>1 从数据类型说起</h4><p><code>JavaScript</code>的数据类型：</p>
<ul>
<li>基本类型： <code>Null，undefined，number，string，Boolean</code> 存放在<code>栈内存</code>的简单数据，可以直接访问</li>
<li>引用类型：<code>Array，Object，Function</code> 存放在<code>堆内存</code>，存放的是该对象的<code>地址指针</code></li>
</ul>
<h4 id="2-深浅拷贝由来"><a href="#2-深浅拷贝由来" class="headerlink" title="2 深浅拷贝由来"></a>2 深浅拷贝由来</h4><p>引用类型的数据，因为指向指针的问题，<code>浅拷贝</code>就会导致指向同一处，那么修改拷贝的任一者，都会<code>导致全部都改</code>了。<br>这时候，就需要<code>深拷贝</code>，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就<code>不会互相影响</code>了。</p>
<h4 id="3-浅拷贝CODE"><a href="#3-浅拷贝CODE" class="headerlink" title="3 浅拷贝CODE"></a>3 浅拷贝CODE</h4><p><code>浅拷贝</code>就是拷贝<code>第一层的基本类型值</code>，以及<code>第一层的引用类型地址</code>。<br>（1）for…in…遍历属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">copyObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> copyObj) &#123;</span><br><span class="line">    obj[i] = copyObj[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">c</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = shallowClone(x);</span><br><span class="line"><span class="built_in">console</span>.log(y.b.f === x.b.f);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>（2）Object.assign()<br>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层<br>基础用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<p>复制对象（浅）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>(3) <code>Array</code>的<code>slice&amp;concat</code>方法<br>它们虽然在demo里看起来像深，其实也是浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">var</span> array_shallow = array; </span><br><span class="line"><span class="keyword">var</span> array_concat = array.concat(); </span><br><span class="line"><span class="keyword">var</span> array_slice = array.slice(<span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(array === array_shallow); <span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(array === array_slice); <span class="comment">//false，“看起来”像深拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(array === array_concat); <span class="comment">//false，“看起来”像深拷贝</span></span><br></pre></td></tr></table></figure>

<p>(4) 展开语法<code>...</code><br>对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1 = [...arr2, ...arr1]; <span class="comment">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS 拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆对象&amp;&amp;数组（二）</title>
    <url>/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h4 id="4-深拷贝CODE"><a href="#4-深拷贝CODE" class="headerlink" title="4. 深拷贝CODE"></a>4. 深拷贝CODE</h4><p><code>深拷贝 = 浅拷贝 + 遇到对象时递归拷贝</code><br>（1）最简单莫过于字符序列化，再parse反序列化<br>语法：JSON.parse(JSON.stringify) </p>
<div class="tip">
后端传回的变量一般用它来拷贝足以应对。只是，
1、会忽略 undefined
                      
<p>2、会忽略 symbol</p>
<p>3、不能序列化函数</p>
<p>4、不能解决循环引用的对象</p>
<p>5、不能正确处理new Date()</p>
<p>6、不能处理正则</p>
<p>undefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// undefined symbol 函数示例</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;muyiy&#x27;</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">Symbol</span>(<span class="string">&#x27;muyiy&#x27;</span>),</span><br><span class="line">    <span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: &quot;muyiy&quot;, </span></span><br><span class="line"><span class="comment">// 	a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">   		<span class="attr">d</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = obj.b;</span><br><span class="line">obj.b.c = obj.a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new Date转化结果不正确 结果方案是转为时间戳</span></span><br><span class="line"><span class="keyword">let</span> date = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</span><br><span class="line"><span class="built_in">JSON</span>.stringify(date); </span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(date)); <span class="comment">// 和上面的输出是同一个值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="regexp">/&#x27;123&#x27;/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;, a: /&#x27;123&#x27;/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;name: &quot;muyiy&quot;, a: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>(2) 简易深拷贝</p>
<p>第一版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个虽然能简单实现 却有以下问题</span></span><br><span class="line"><span class="comment">// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 &#123;&#125;</span></span><br><span class="line"><span class="comment">// 2、对于对象的判断逻辑不严谨，因为 typeof null === &#x27;object&#x27;</span></span><br><span class="line"><span class="comment">// 3、没有考虑数组的兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里 如果是对象的时候递归调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二版 （非对象的返回自身以及数组的支持）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;<span class="comment">// 非对象返回自身</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep2</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; <span class="comment">// 非对象返回自身</span></span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;; <span class="comment">// 初始值为空数组或空对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep2(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>第三版 （支持对象循环引用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); <span class="comment">// 新增代码，查哈希表</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target); <span class="comment">// 新增代码，哈希表设值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep3(source[key], hash); <span class="comment">// 新增代码，传入哈希表</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">        <span class="attr">a1</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">a2</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">a3</span>: <span class="number">123</span>,</span><br><span class="line">        <span class="attr">book</span>: &#123;<span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;45&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    a.circleRef = a <span class="comment">// circleRef是个很奇特的属性，它能在自身存自己，并永久循环，</span></span><br><span class="line">    <span class="keyword">var</span> b = cloneDeep3(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>

<p>第四版 （保存引用关系）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组版</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, uniqueList</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source</span><br><span class="line">     <span class="keyword">if</span> (!uniqueList) uniqueList = []</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> uniqueData = find(uniqueList, source)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target</span></span><br><span class="line">     <span class="keyword">if</span>(uniqueData) &#123;</span><br><span class="line">         <span class="keyword">return</span> uniqueData.target</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 数据不存在，保存源数据，以及对应的引用</span></span><br><span class="line">     uniqueList.push(&#123; <span class="comment">// 用数组存储键值对</span></span><br><span class="line">         <span class="attr">source</span>: source,</span><br><span class="line">         <span class="attr">target</span>: target</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source,key)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                 target[key] = cloneDeep3(source[key], uniqueList)</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 target[key] = source[key]</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> target <span class="comment">// target很值得玩味，递归完了后的callStack让人惊奇</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> obj2 = &#123;<span class="attr">a</span>: obj1, <span class="attr">b</span>: obj1&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj2.a === obj2.b);</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj3 = cloneDeep3(obj2);</span><br><span class="line"> <span class="built_in">console</span>.log(obj3.a === obj3.b)</span><br><span class="line"> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第五版 （拷贝Symbol类型）<br>思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep4</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============= 新增代码</span></span><br><span class="line">    <span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找 </span></span><br><span class="line">    <span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功	</span></span><br><span class="line">        symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">                target[symKey] = cloneDeep4(source[symKey], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[symKey] = source[symKey];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep4(source[key], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 可以看到成功拷贝了Symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 创建新的symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;b&quot;</span>); <span class="comment">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class="line"></span><br><span class="line">a[sym1] = <span class="string">&quot;localSymbol&quot;</span>;</span><br><span class="line">a[sym2] = <span class="string">&quot;globalSymbol&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep4(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// 	a1: undefined,</span></span><br><span class="line"><span class="comment">//	a2: null,</span></span><br><span class="line"><span class="comment">// 	a3: 123,</span></span><br><span class="line"><span class="comment">// 	book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;,</span></span><br><span class="line"><span class="comment">// 	circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span></span><br><span class="line"><span class="comment">//  [Symbol(a)]: &#x27;localSymbol&#x27;,</span></span><br><span class="line"><span class="comment">//  [Symbol(b)]: &#x27;globalSymbol&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>


<p>第六版 破解递归爆栈 (待研究@todo)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep5</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">parent</span>: root,</span><br><span class="line">            <span class="attr">key</span>: <span class="literal">undefined</span>,</span><br><span class="line">            <span class="attr">data</span>: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="comment">// 广度优先</span></span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        <span class="attr">parent</span>: res,</span><br><span class="line">                        <span class="attr">key</span>: k,</span><br><span class="line">                        <span class="attr">data</span>: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="小语法："><a href="#小语法：" class="headerlink" title="小语法："></a>小语法：</h4><p>1 Object.keys(..) 返回一个数组，包含所有可枚举属性<br>2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举<br>3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述<br>4 in &amp;&amp; hasOwnProperty</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个关联到 anotherObject 的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">myObject.b = <span class="number">2</span>;</span><br><span class="line">(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;a&quot;</span> ); <span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;b&quot;</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。</span></span><br><span class="line"><span class="comment">// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。</span></span><br></pre></td></tr></table></figure>
<p>5 WeakMap<br>特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">      wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">      wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;,</span><br><span class="line">      o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">      o3 = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">wm1.set(o1, <span class="number">37</span>);</span><br><span class="line">wm1.set(o2, <span class="string">&quot;azerty&quot;</span>);</span><br><span class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象或一个函数</span></span><br><span class="line">wm2.set(o3, <span class="literal">undefined</span>);</span><br><span class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class="line"></span><br><span class="line">wm1.get(o2); <span class="comment">// &quot;azerty&quot;</span></span><br><span class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></span><br><span class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></span><br><span class="line"></span><br><span class="line">wm1.has(o2); <span class="comment">// true</span></span><br><span class="line">wm2.has(o2); <span class="comment">// false</span></span><br><span class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></span><br><span class="line"></span><br><span class="line">wm3.set(o1, <span class="number">37</span>);</span><br><span class="line">wm3.get(o1); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line">wm1.has(o1);   <span class="comment">// true</span></span><br><span class="line">wm1.delete(o1);</span><br><span class="line">wm1.has(o1);   <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN Object.assign</a><br><a href="https://github.com/wengjq/Blog/issues/3">wengjq issue</a><br><a href="https://github.com/yygmind/blog/issues/25">yygmind issue</a><br><a href="https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86">yygmind 深浅拷贝汇总</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">MDN Object.getOwnPropertyDescription</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">MDN WeakMap</a><br><a href="https://www.codenong.com/29413222/">神奇的weakmap科普贴</a><br><a href="https://segmentfault.com/a/1190000016672263">颜海镜</a></p>
]]></content>
      <tags>
        <tag>JS 拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2020/05/27/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h3><p>柯里化是一种将使用<code>多个参数</code>的一个函数<code>转换成</code>一系列使用<code>一个参数</code>的函数的编程技术。<br>简单示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个 curry 函数可以做到柯里化</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add);</span><br><span class="line"></span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 调用跟 add (1，2)是一样的</span></span><br></pre></td></tr></table></figure>

<h3 id="2-curry函数的编写"><a href="#2-curry函数的编写" class="headerlink" title="2. curry函数的编写"></a>2. curry函数的编写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@feature </span>普通curry函数的编写</span></span><br><span class="line"><span class="comment"> arguments 对象是内部函数的。</span></span><br><span class="line"><span class="comment"> 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。</span></span><br><span class="line"><span class="comment"> arguments会视为每次传的参数而定</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = fn.length;</span><br><span class="line">    args = args || []; <span class="comment">// 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = args.slice(<span class="number">0</span>),</span><br><span class="line">            arg, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">            _args.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; length) &#123; <span class="comment">// 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面四种都会得出这样的结果： [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前返回的例子</span></span><br><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn, capture</span>) </span>&#123; <span class="comment">// 提前返回</span></span><br><span class="line">            el.addEventListener(type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123; <span class="comment">// 提前返回</span></span><br><span class="line">            el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="3-curry函数写法的引申思考"><a href="#3-curry函数写法的引申思考" class="headerlink" title="3. curry函数写法的引申思考"></a>3. curry函数写法的引申思考</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简易版，理解 fn1 中 return fn2的执行</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> k = testFn()</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="comment">// k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue 识别html标签的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params">tagStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tagArr = tagStr.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> tagObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> tag <span class="keyword">of</span> tagArr) &#123;</span><br><span class="line">    tagObj[tag] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tagName</span>) </span>&#123; <span class="comment">// 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗</span></span><br><span class="line">    <span class="keyword">return</span> !!tagObj[tagName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isHTMLTag = makeMap(<span class="string">&#x27;div,p,span,h1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isHTMLTag(<span class="string">&#x27;div&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-curry函数的特点与作用"><a href="#4-curry函数的特点与作用" class="headerlink" title="4. curry函数的特点与作用"></a>4. curry函数的特点与作用</h3><ul>
<li>参数复用，提前固定参数</li>
<li>提前返回</li>
</ul>
<hr>
<p>参考文章：<br><a href="https://zh.javascript.info/currying-partials">javascript.Info</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/42">冴羽github文章</a><br><a href="https://my.oschina.net/u/4400687/blog/3660259"><code>arguments</code>和<code>function.length</code>的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length">Function.length</a><br><a href="https://github.com/YvetteLau/Step-By-Step/issues/24">github闭包论坛</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>判断对象是否是个空对象</title>
    <url>/2020/07/27/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</url>
    <content><![CDATA[<h4 id="1-遍历，根据是否有值"><a href="#1-遍历，根据是否有值" class="headerlink" title="1. 遍历，根据是否有值"></a>1. 遍历，根据是否有值</h4><p><code>for...in...</code></p>
<h4 id="2-整个对象转换为数组"><a href="#2-整个对象转换为数组" class="headerlink" title="2. 整个对象转换为数组"></a>2. 整个对象转换为数组</h4><p><code>Object.entries </code></p>
<h4 id="3-转为JSON字符串"><a href="#3-转为JSON字符串" class="headerlink" title="3. 转为JSON字符串"></a>3. 转为JSON字符串</h4><p><code>JSON.stringify()</code></p>
<h4 id="4-获取对象的属性名并以数组形式返回"><a href="#4-获取对象的属性名并以数组形式返回" class="headerlink" title="4. 获取对象的属性名并以数组形式返回"></a>4. 获取对象的属性名并以数组形式返回</h4><p><code>Object.getOwnPropertyNames()</code> / <code>Object.keys()</code></p>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...in...</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   isEmpty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key的遍历 ： Object.getOwnPropertyNames</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key的遍历： Object.keys 获取key的数组</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty = <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象转化为数组的遍历： Object.entries</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty;</span><br><span class="line">isEmpty = (<span class="built_in">Object</span>.entries(obj).length === <span class="number">0</span>) &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON字符串</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty;</span><br><span class="line">isEmpty = <span class="built_in">JSON</span>.stringify(obj) === <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>面试 JS 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>合并对象</title>
    <url>/2020/07/27/%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>1 <code>Object.assign</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:[<span class="number">1</span>], <span class="attr">b</span>:[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="attr">c</span>:<span class="number">5</span> , <span class="attr">d</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(obj1,obj2))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>…运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:[<span class="number">1</span>], <span class="attr">b</span>:[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="attr">c</span>:<span class="number">5</span> , <span class="attr">d</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(&#123;...obj1, ...obj2&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>对象 JS</tag>
      </tags>
  </entry>
  <entry>
    <title>合成图片</title>
    <url>/2019/02/15/%E5%90%88%E6%88%90%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><pre><code>H5的分享海报，需要从后台获取数据，绘制DOM，并且可以长按保存。也就是要求所有DOM都要转为image元素。
</code></pre>
<h6 id="需要引用的库"><a href="#需要引用的库" class="headerlink" title="需要引用的库"></a>需要引用的库</h6><pre><code>html2Canvas: Screenshots with JavaScript 等于是用js去转换指定的DOM成为image。
</code></pre>
<h6 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h6><pre><code>html2Canvas执行渲染时 ，需等待DOM本身获取后台数据的渲染完成。否则会出现黑背景
</code></pre>
<h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 关键在这里，延时进行html2Canvas操作</span></span><br><span class="line">        drawCanvas(<span class="string">&#x27;#sharePoster_bg_img&#x27;</span>).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">            img.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">            <span class="comment">// 将 canvas 导出成 base64</span></span><br><span class="line">            img.src = canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.92</span>);</span><br><span class="line">            img.crossOrigin = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">            <span class="comment">// 添加图片到预览</span></span><br><span class="line">            $(<span class="string">&#x27;#sharePoster_bg_img&#x27;</span>).html(img); <span class="comment">// 生成的base64图片填充到dom里</span></span><br><span class="line">            $(<span class="string">&#x27;.save_text&#x27;</span>).show();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="优化细节-以及-要用到的工具函数"><a href="#优化细节-以及-要用到的工具函数" class="headerlink" title="优化细节 以及 要用到的工具函数"></a>优化细节 以及 要用到的工具函数</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据像素比绘制canvas，使生成图片更加高清。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">DomSelector</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns <span class="variable">html2Canvas</span></span></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">drawCanvas</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取想要转换的 DOM 节点</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">    <span class="keyword">const</span> box = <span class="built_in">window</span>.getComputedStyle(dom);</span><br><span class="line">    <span class="comment">// DOM 节点计算后宽高</span></span><br><span class="line">    <span class="keyword">const</span> width = parseValue(box.width);</span><br><span class="line">    <span class="keyword">const</span> height = parseValue(box.height);</span><br><span class="line">    <span class="comment">// 获取像素比</span></span><br><span class="line">    <span class="keyword">const</span> scaleBy = DPR();</span><br><span class="line">    <span class="comment">// 创建自定义 canvas 元素</span></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比</span></span><br><span class="line">    canvas.width = width * scaleBy;</span><br><span class="line">    canvas.height = height * scaleBy;</span><br><span class="line">    <span class="comment">// 设定 canvas css宽高为 DOM 节点宽高</span></span><br><span class="line">    canvas.style.width = <span class="string">`<span class="subst">$&#123;width&#125;</span>px`</span>;</span><br><span class="line">    canvas.style.height = <span class="string">`<span class="subst">$&#123;height&#125;</span>px`</span>;</span><br><span class="line">    <span class="comment">// 获取画笔</span></span><br><span class="line">    <span class="keyword">const</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有绘制内容放大像素比倍 </span></span><br><span class="line">    context.scale(scaleBy, scaleBy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自定义 canvas 作为配置项传入，开始绘制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> html2canvas(dom, &#123;canvas,</span><br><span class="line">        <span class="attr">allowTaint</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">useCORS</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">async</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">width</span>: width,</span><br><span class="line">        <span class="attr">height</span>: height</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据window.devicePixelRatio获取像素比</span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns </span>像素比</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DPR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio &amp;&amp; <span class="built_in">window</span>.devicePixelRatio &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  将传入值转为整数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="注意细节："><a href="#注意细节：" class="headerlink" title="注意细节："></a>注意细节：</h6><pre><code>需绘制的DOM所用到的css属性值最好不用最新的属性，html2Canvas不支持最新的css属性解析，会造成生成的图片有黑色背景。
</code></pre>
<h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p>   <a href="https://html2canvas.hertzen.com/">html2Canvas官网</a><br>   <a href="http://cdn.huodongxing.com/Content/v2.0/plugin/html2canvas/html2canvas.min.js">js资源</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>复制内容</title>
    <url>/2019/03/02/%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h6 id="常用场景："><a href="#常用场景：" class="headerlink" title="常用场景："></a>常用场景：</h6><p>有时候需要复制内容，比如复制链接，需要用js实现，那么，可以这么解决</p>
<h6 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h6><p>利用input的<code>选择属性</code>，获取input的值，选择它，并且执行<code>document.execCommand(&quot;Copy&quot;)</code> 。而且因为往往值是隐藏的，所以这个input也是不外露的。</p>
<h6 id="上些代码："><a href="#上些代码：" class="headerlink" title="上些代码："></a>上些代码：</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inviteHideInput&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 1px;width: 1px;&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这是隐藏的input --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;复制邀请函链接&quot;</span> <span class="attr">class</span>=<span class="string">&quot;copyInviteUrl&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 这是触发的Dom --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.copyInviteUrl&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> eid = getQueryString(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> newUrl = location.host + <span class="string">&#x27;/invitation?eid=&#x27;</span> + eid;</span><br><span class="line">        $(<span class="string">&#x27;#inviteHideInput&#x27;</span>).attr(<span class="string">&#x27;value&#x27;</span>, newUrl);</span><br><span class="line">        $(<span class="string">&#x27;#inviteHideInput&#x27;</span>).select();</span><br><span class="line">        <span class="built_in">document</span>.execCommand(<span class="string">&quot;Copy&quot;</span>); <span class="comment">// 执行浏览器复制命令</span></span><br><span class="line">        PopupMessage(<span class="number">0</span>, <span class="string">&quot;已复制，您可以使用Ctrl+V粘贴。&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序入门</title>
    <url>/2019/08/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<ul>
<li>目录结构</li>
<li>页面结构</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>目录结构如图：<br> <img src="https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/a646ddf246beb349e404ba97e137473.png" alt="image"></p>
<hr>
<p>1.<code>components文件夹</code>：存放自定义的组件、封装的组件。</p>
<p>2.<code>custom-tab-bar</code>: 如名，它就是自定义的tab-bar。</p>
<p>3.<code>img</code>：如名, 它就是存放图片的。  </p>
<p>4.<code>pages</code>：最核心的，是存放我们的页面。</p>
<p><img src="https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/6237ce1f0d8810a3bcf79d5c3ff65eb.png" alt="image"></p>
<p>如图 ，index文件夹中，就包含四个这样名字的js,json,wxml,wxss 其中的json是定义页面的自定义信息，包含页面标题，引用组件，背景颜色等等</p>
<p>5.<code>service</code>: 存放了工具函数，如全局存储，登录封装，api相关地址以及请求封装，还有一些根据业务的处理字符串或者对象的方法（包括正则）。</p>
<p>6.<code>app.json</code>：全局的配置,标题，背景，底部tabBar，页面路由，定位允许，appid授权（简单理解，就是一个配置文件）</p>
<p>7.<code>app.js</code>: 每个小程序都需要在 app.js 中调用 App 方法注册小程序示例，绑定生命周期回调函数。</p>
<p>8.<code>project.config.json</code>: 小程序开发工具的顶上的编译入口文件，可以在里面定义好路径，刷新也只是刷新指定页面，减少调试步骤。</p>
<hr>
<p>页面结构</p>
<ul>
<li>1.<code>wxml</code>: <ul>
<li>常用标签略微有点不一样，web开发常用的div，换成它的<strong><strong>view</strong></strong>标签。span换成它的<strong>text</strong>标签。<br>图片标签换成<strong>image</strong>标签，属性一样，用法一样。</li>
<li>谈下<strong>cover-view</strong>这个标签，它是可以在<code>map</code>、<code>video</code>、<code>canvas</code>、<code>camera</code>、<code>live-player</code>、<code>live-pusher</code>等等之上的渲染的标签。这时候<strong>view</strong>标签表示无能为力的。</li>
</ul>
</li>
<li>2.<code>wxss</code>:<ul>
<li>单位：px单位换成rpx,适配设备的单位，这个是真香，不用再换算。</li>
<li>flex布局支持。</li>
</ul>
</li>
<li>3.<code>js</code>:<ul>
<li>页面组件的js结构：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// import utils</span></span><br><span class="line">  Page(&#123;</span><br><span class="line">   <span class="attr">data</span>: &#123; <span class="comment">// 页面所需变量</span></span><br><span class="line"> 	&#125;,</span><br><span class="line">   <span class="attr">onShow</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fetch data</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">customEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 自己定义的触发函数</span></span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line">&#125;)       </span><br></pre></td></tr></table></figure></li>
<li>– </li>
<li>自定义组件的js结构： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import utils</span></span><br><span class="line">Component(&#123;</span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">  	<span class="attr">something</span>: &#123; <span class="comment">// 父组件传过来的</span></span><br><span class="line">	    	<span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">  	</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">ready</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  	</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">attached</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  	</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">  	<span class="attr">methods1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	  </span><br><span class="line">	    &#125;,</span><br><span class="line">   <span class="attr">methods2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html">官方API</a><br><a href="https://juejin.im/entry/5a676b3ff265da3e4f0a5215">小程序组件化API介绍</a></li>
</ul>
</li>
<li>4.<code>json</code></li>
</ul>
]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重</title>
    <url>/2019/02/25/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<blockquote>
<p>我们时常遇见数组去重的需求，或是后台给的数据重了，或是前端生成数据的时候重了，这时候往往需要处理下，那下面我归纳下各种解决方案吧🧐：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先给出几组测试数组</span></span><br><span class="line"><span class="keyword">let</span> includeObjArr = [ <span class="comment">// 待检测数组（含对象）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wang&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wang&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zhong&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zhong&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> includeNumArr =  [<span class="number">3</span>, <span class="number">62</span>, <span class="number">3</span>, <span class="number">38</span>, <span class="number">20</span>, <span class="number">42</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">38</span>, <span class="number">29</span>, <span class="number">42</span>]; <span class="comment">// 只含数字的简单数组</span></span><br></pre></td></tr></table></figure>

<h3 id="1-利用ES6的API-Set和-Array"><a href="#1-利用ES6的API-Set和-Array" class="headerlink" title="1. 利用ES6的API Set和 Array"></a>1. 利用ES6的API Set和 Array</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* es6 api的解决方案</span></span><br><span class="line"><span class="comment">* @param targetArr</span></span><br><span class="line"><span class="comment">* @returns &#123;any[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArray</span>(<span class="params">targetArr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(targetArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="结论：只能用于包含简单数字的数组去重"><a href="#结论：只能用于包含简单数字的数组去重" class="headerlink" title="结论：只能用于包含简单数字的数组去重"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id="2-利用array-splice"><a href="#2-利用array-splice" class="headerlink" title="2. 利用array.splice"></a>2. 利用array.splice</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* es6 api的解决方案</span></span><br><span class="line"><span class="comment">* @param arr</span></span><br><span class="line"><span class="comment">* @returns &#123;any[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArray</span>(<span class="params">arr</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(arr[j] === arr[i])&#123; </span><br><span class="line">                arr.splice(j--, <span class="number">1</span>); </span><br><span class="line">                &#125; </span><br><span class="line">              &#125; </span><br><span class="line">            &#125; </span><br><span class="line">          <span class="keyword">return</span> arr;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<h6 id="结论：只能用于包含简单数字的数组去重-1"><a href="#结论：只能用于包含简单数字的数组去重-1" class="headerlink" title="结论：只能用于包含简单数字的数组去重"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id="3-利用哈希表"><a href="#3-利用哈希表" class="headerlink" title="3. 利用哈希表"></a>3. 利用哈希表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对象存储的是引用而原始变量存储的是值。</span></span><br><span class="line"><span class="comment">* 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和&#x27;1&#x27;。</span></span><br><span class="line"><span class="comment">* 然而，因为我们使用的JSON.stringify，String类型的key 将会被存储为一个字符串值，这样hashTable的key就唯一了。</span></span><br><span class="line"><span class="comment">* 这意味着相同的值，但不同类型的元素，将以原来的格式保留。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedup</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> hashTable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(el);</span><br><span class="line">		<span class="keyword">var</span> match = <span class="built_in">Boolean</span>(hashTable[key]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (match ? <span class="literal">false</span> : hashTable[key] = <span class="literal">true</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="结论：可用于包含复杂类型的数组去重"><a href="#结论：可用于包含复杂类型的数组去重" class="headerlink" title="结论：可用于包含复杂类型的数组去重"></a>结论：可用于包含复杂类型的数组去重</h6><hr>
<h3 id="4-利用对象中key的唯一"><a href="#4-利用对象中key的唯一" class="headerlink" title="4. 利用对象中key的唯一"></a>4. 利用对象中key的唯一</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> tmpKey;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        tmpKey = <span class="keyword">typeof</span> arr[i] + <span class="built_in">JSON</span>.stringify(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(!tmp[tmpKey])&#123;</span><br><span class="line">            tmp[tmpKey] = <span class="number">1</span>;</span><br><span class="line">            ret.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="结论：可用于包含复杂类型的数组去重-1"><a href="#结论：可用于包含复杂类型的数组去重-1" class="headerlink" title="结论：可用于包含复杂类型的数组去重"></a>结论：可用于包含复杂类型的数组去重</h6><h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p><a href="http://www.jstips.co/zh_cn/javascript/deduplicate-an-array/">jstips</a><br><a href="https://github.com/lifesinger/blog/issues/113">blog</a><br><a href="https://github.com/hanzichi/underscore-analysis/issues/9">blog</a></p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器-输入url系列</title>
    <url>/2020/03/13/%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%BE%93%E5%85%A5url%E6%93%8D%E4%BD%9C%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>共是五个步骤</p>
</blockquote>
<h3 id="1-浏览器的搜索框"><a href="#1-浏览器的搜索框" class="headerlink" title="1 浏览器的搜索框"></a>1 浏览器的搜索框</h3><p>浏览器会根据输入的内容，去匹配是用对应的引擎搜索内容，还是直接跳转url。<br>详细的讲，就是</p>
<ul>
<li>搜索内容+默认搜索引擎，形成新的URL</li>
<li>符合URL规则的话，在输入内容基础上加上协议，形成新的URL</li>
</ul>
<h3 id="2-dns解析"><a href="#2-dns解析" class="headerlink" title="2 dns解析"></a>2 dns解析</h3><ul>
<li>自己的理解：路由解析，找到背后的ip地址，路由缓存，域名缓存，为什么第二次加载会更快，跟这个有关。</li>
<li>dns：一个域名与ip地址相互映射的分布式数据库</li>
<li>我们无法记住的ip，那一个个长相平凡但是堆积在一起就是记不住的几个数字，是的，dns帮我们记住了。他以电话簿的形式，记住了许许多多的ip地址，映射到了所有网站上。</li>
<li>在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</li>
<li>本地dns服务器找不到的时候，去查询其他根dns服务器，顶级域服务器，权威dns服务器</li>
<li>查找的过程是有优化的地方：<ul>
<li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 </li>
<li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li>
<li>补充：域名与ip之间有映射关系，但是大多数情况下却不是一一对应的，我们可以将多个ip映射到同一个域名，因为用户是通过域名去进行访问的，具体访问哪个地址，则有DNS服务器的映射记录和一定的负载均衡算法来决定，用户拿到具体ip后再去访问，而这个过程对用户来说完全是透明的，通过DNS分流完成了第一步的负载均衡：</li>
</ul>
</li>
</ul>
<h3 id="3-Https，ssl协议，Tcp建立连接"><a href="#3-Https，ssl协议，Tcp建立连接" class="headerlink" title="3 Https，ssl协议，Tcp建立连接"></a>3 Https，ssl协议，Tcp建立连接</h3><p>浏览器通过http/https协议，建立tcp连接，三次握手建立请求，传输连接建立完毕。</p>
<h3 id="4-服务器处理请求，返回结果"><a href="#4-服务器处理请求，返回结果" class="headerlink" title="4 服务器处理请求，返回结果"></a>4 服务器处理请求，返回结果</h3><p>服务器，解析请求头，对比是否过期字段，缓存字段，返回对应的状态码和内容。返回所有内容后，可以关闭连接了亲。</p>
<h3 id="5-浏览器解析-渲染"><a href="#5-浏览器解析-渲染" class="headerlink" title="5 浏览器解析/渲染"></a>5 浏览器解析/渲染</h3><p>dom树解析，转换css单位成通用单位，cssdom解析，绘制。优先视口。</p>
<ul>
<li>构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示<ul>
<li>构建DOM树：html内容解析成DOM树（这里面用到HTML的parser）</li>
<li>css样式表，转为浏览器可以读懂的CSS规则树</li>
<li>由DOM树和CSS规则树，创建render树，计算布局信息，包括所有元素的尺寸、位置、还有position、z-index、overflow</li>
<li>绘制render树，绘制页面像素</li>
<li>GPU绘制，显示到显示屏</li>
</ul>
</li>
</ul>
<p>小知识点：</p>
<ul>
<li>HTML的parser：<ul>
<li>转换：HTML编码成字符</li>
<li>分词：给字符们打上标记Tokens</li>
<li>词法：tokens转换成包含属性和规则的对象</li>
<li>DOM树创建</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A">文章</a></li>
<li><a href="https://segmentfault.com/a/1190000012196642">https</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26682342">https</a></li>
<li><a href="https://blog.csdn.net/weixin_34050389/article/details/93027673">负载均衡</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since">If-Unmodified-Since</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires">Expires</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649825731&idx=1&sn=2c0835cebfee3a44e82d9efeb54f6e43&chksm=f175eb00c602621649fd46d7c9de87f7f08a4cdaa9e08808b938948584ca6977e24a5f5336ce&scene=21#wechat_redirect">浏览器相关</a></li>
<li><a href="https://segmentfault.com/a/1190000013662126">全面</a></li>
<li><a href="https://segmentfault.com/a/1190000012925872">浏览器进程/线程</a></li>
</ul>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器异步（一）</title>
    <url>/2020/07/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>注： 转载瓶子君文章 <a href="https://github.com/sisterAn/blog/issues/11">详细连接</a></p>
</blockquote>
<p>已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。</p>
<h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-浏览器是多进程的"><a href="#1-浏览器是多进程的" class="headerlink" title="1. 浏览器是多进程的"></a>1. 浏览器是多进程的</h4><p>它主要包括以下进程：</p>
<ul>
<li>Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li>
<li>GPU 进程：用于 3D 绘制等，最多一个。</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li>
<li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li>
</ul>
<h4 id="2-渲染进程（浏览器内核）"><a href="#2-渲染进程（浏览器内核）" class="headerlink" title="2. 渲染进程（浏览器内核）"></a>2. 渲染进程（浏览器内核）</h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：</p>
<ul>
<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li>
<li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li>
<li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li>
<li>定时触发器线程：传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms 。</li>
<li>异步 http 请求线程：在 <code>XMLHttpRequest</code> 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>
</ul>
<p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时</strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h3 id="二、单线程的-JavaScript"><a href="#二、单线程的-JavaScript" class="headerlink" title="二、单线程的 JavaScript"></a>二、单线程的 JavaScript</h3><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p>
<p><strong>问题：首先为什么要引入单线程？</strong></p>
<p>我们知道：</p>
<ul>
<li>浏览器需要渲染 DOM</li>
<li>JavaScript 可以修改 DOM 结构</li>
<li>JavaScript 执行时，浏览器 DOM 渲染停止</li>
</ul>
<p>如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p>
<p>你可能会说，<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">web worker</a> 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p>
<p><strong>原因：避免 DOM 渲染的冲突</strong></p>
<p>当然，我们可以为浏览器引入<strong>锁</strong> 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。</p>
<p>引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例1</span></span><br><span class="line"><span class="keyword">let</span> i, sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i ++) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>

<p>在实例1中，<code>sum</code> 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 <code>console.log(sum)</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">alert(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在实例2中，浏览器先打印 <code>1</code> ，然后弹出弹框，点击确定后才执行 <code>console.log(2)</code> 。</p>
<p><strong>总结：</strong></p>
<ul>
<li>优点：实现比较简单，执行环境相对单纯</li>
<li>缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>
</ul>
<p>为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步</p>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func(args...)</span><br></pre></td></tr></table></figure>

<p>如果在函数 <code>func</code> 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">Math</span>.floor(a)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-异步"><a href="#2-异步" class="headerlink" title="2. 异步"></a>2. 异步</h4><p>如果在函数 <code>func</code> 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>JavaScript 采用异步编程原因有两点，</p>
<ul>
<li>一是 JavaScript 是单线程；</li>
<li>二是为了提高 CPU 的利用率。</li>
</ul>
<h3 id="四、异步过程"><a href="#四、异步过程" class="headerlink" title="四、异步过程"></a>四、异步过程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在执行这段代码时，<code>fs.readFile</code> 函数返回时，并不会立刻打印 <code>data</code> ，只有 <code>data.json</code> 读取完成时才打印。也就是异步函数 <code>fs.readFile</code> 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。</p>
<p>主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。</p>
<p>工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。</p>
<h3 id="五、消息队列与事件循环"><a href="#五、消息队列与事件循环" class="headerlink" title="五、消息队列与事件循环"></a>五、消息队列与事件循环</h3><p>工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。</p>
<ul>
<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>
<li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>
</ul>
<h4 id="1-事件循环（eventloop）"><a href="#1-事件循环（eventloop）" class="headerlink" title="1. 事件循环（eventloop）"></a>1. 事件循环（eventloop）</h4><p>主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。</p>
<p>大致实现过程如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = queue.get()</span><br><span class="line">    execute(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// output：4321 或 4312</span></span><br></pre></td></tr></table></figure>

<p>其中，主线程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>异步队列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 100ms后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ajax加载完成之后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。</strong></p>
<h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h4><p>其中，消息就是注册异步任务时添加的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(<span class="string">&#x27;XXX&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 <code>XXX</code>，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息队列里的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>callback</code> 是 AJAX 网络请求成功响应时的回调函数。</p>
<p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 <code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code>通知</code> ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p>
<p><img src="https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67"></p>
<p>异步过程中的回调函数，<strong>一定不在当前这一轮事件循环中执行</strong>。</p>
<h3 id="六、异步与事件"><a href="#六、异步与事件" class="headerlink" title="六、异步与事件"></a>六、异步与事件</h3><p>消息队列中的每条消息实际上都对应着一个事件。</p>
<p>其中一个重要的异步过程就是： <strong>DOM事件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">button.addEventLister(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;事件&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从异步的角度看，<code>addEventLister</code> 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。</p>
<p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</p>
<p>另外，所有的异步过程也都可以用事件来描述。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(func, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 可以看成：</span></span><br><span class="line">timer.addEventLister(<span class="string">&#x27;timeout&#x27;</span>, <span class="number">1000</span>, func)</span><br></pre></td></tr></table></figure>

<p>其中关于事件的详细描述，可以看这篇文章： <a href="http://blog.xieliqun.com/2016/08/12/event-delegate/">事件绑定、事件监听、事件委托</a>，这里不再深入介绍。</p>
<h3 id="七、生产者与消费者"><a href="#七、生产者与消费者" class="headerlink" title="七、生产者与消费者"></a>七、生产者与消费者</h3><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p>
<p><img src="https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966"></p>
<p>从生产者与消费者的角度看，异步过程是这样的：</p>
<p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p>
<p>那么异步的实现方式有哪些？</p>
<ul>
<li>ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅</li>
<li>ES6：Generator</li>
<li>ES7: Async/Await</li>
</ul>
<hr>
<p>参考：<br><a href="https://github.com/sisterAn/blog/issues/11">瓶子君 blog</a></p>
<p><a href="https://github.com/sisterAn/blog/issues/23">瓶子君 Generator</a></p>
<p><a href="https://github.com/sisterAn/blog/issues/27">瓶子君 co函数</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器异步（三）</title>
    <url>/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BPromise%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>此篇博文转载自瓶子君的blog <a href="https://github.com/sisterAn/blog/issues/13">链接</a>，并加以自己的理解和注释。</p>
</blockquote>
<h3 id="Promise本质"><a href="#Promise本质" class="headerlink" title="Promise本质"></a>Promise本质</h3><p><strong>Promise就是为了解决callback的问题而产生的。</strong></p>
<p>Promise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。</p>
<p><strong>开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转</strong>。</p>
<p>我们把上面那个多层回调嵌套的例子用Promise的方式重构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getPromise1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;XXX1&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">let</span> key = data;</span><br><span class="line">               resolve(key);         </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getPromise2 = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;XXX2&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                <span class="attr">key</span>: key</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getPromise3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;XXX3&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getPromise1()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPromise2(key);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPromise3(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;业务数据：&#x27;</span>, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure>

<p>Promise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。</p>
<p>所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。</p>
<h3 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h3><p>Promise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，<strong>它是一种规范，是一套处理JavaScript异步的机制</strong>。</p>
<p>Promise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：</p>
<ul>
<li>英文版：<a href="https://promisesaplus.com/">Promise/A+</a></li>
<li>翻译版：<a href="http://www.ituring.com.cn/article/66566">【翻译】Promises/A+规范</a></li>
</ul>
<p>这里只简要介绍下几点与接下来内容相关的规范：</p>
<ul>
<li>Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。</li>
<li>then 方法可以被同一个 promise 调用多次。</li>
<li>then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise</li>
<li>值穿透</li>
</ul>
<h3 id="Promise-实现及源码解读"><a href="#Promise-实现及源码解读" class="headerlink" title="Promise 实现及源码解读"></a>Promise 实现及源码解读</h3><p>首先，我们看一下Promise的简单使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do an async task async task and then...</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* good condition */</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Failure!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* do something with the result */</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* error :( */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们通过这种使用构建Promise实现的第一个版本</p>
<p><strong>自己的写法也是结合调用实例的逆推过程</strong>。</p>
<p>为什么要将callback单独传入呢？因为啊，new Promise(… ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。</p>
<h4 id="Promise构建版本一"><a href="#Promise构建版本一" class="headerlink" title="Promise构建版本一"></a>Promise构建版本一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="keyword">var</span> onResolvedCallback  <span class="comment">// Promise resolve回调函数</span></span><br><span class="line">    <span class="keyword">var</span> onRejectedCallback  <span class="comment">// Promise reject回调函数</span></span><br><span class="line">    <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        onResolvedCallback()</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// reject 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        onRejectedCallback()</span><br><span class="line">    &#125; </span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。</p>
<h4 id="Promise构建之二：链式存储"><a href="#Promise构建之二：链式存储" class="headerlink" title="Promise构建之二：链式存储"></a>Promise构建之二：链式存储</h4><p>链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。</p>
<p>首先，举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b=<span class="number">2</span>;</span><br><span class="line">            resolve(b);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c=<span class="number">3</span></span><br><span class="line">            resolve(c);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上例结果是每间隔1s打印一个数字，顺序为1、2、3。</p>
<p>这里保证了：</p>
<ul>
<li>让a,b,c的值能在then里面的回调接收到</li>
<li>在连续调用异步，如何确保异步函数的执行顺序</li>
</ul>
<p>Promise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用<code>setTimeout</code>来处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行</span></span><br><span class="line">            _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行</span></span><br><span class="line">            _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之三：状态机制、顺序执行"><a href="#Promise构建之三：状态机制、顺序执行" class="headerlink" title="Promise构建之三：状态机制、顺序执行"></a>Promise构建之三：状态机制、顺序执行</h4><p>为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            	_this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            	_this.value = value</span><br><span class="line">            	_this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之四：递归执行"><a href="#Promise构建之四：递归执行" class="headerlink" title="Promise构建之四：递归执行"></a>Promise构建之四：递归执行</h4><p>每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.</p>
<p>当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            	_this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            	_this.value = value</span><br><span class="line">            	_this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之五：异常处理"><a href="#Promise构建之五：异常处理" class="headerlink" title="Promise构建之五：异常处理"></a>Promise构建之五：异常处理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            	_this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            	_this.value = value</span><br><span class="line">            	_this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="comment">// new Promise(() =throw Error(&#x27;error&#x27;))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之六：then的实现"><a href="#Promise构建之六：then的实现" class="headerlink" title="Promise构建之六：then的实现"></a>Promise构建之六：then的实现</h4><p>then 方法是 Promise 的核心，这里做一下详细介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）</p>
<ul>
<li>onFulfilled 特性：<ul>
<li>当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值</li>
<li>在 Promise 执行结束前不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
<li>onRejected 特性<ul>
<li>当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值</li>
<li>在 Promise 执行结束前不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
<li>调用时机<br><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）</li>
<li>调用要求<br><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值，在 <strong>严格模式（strict）</strong> 中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。）</li>
<li>多次调用<br><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次<ul>
<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>
<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>
</ul>
</li>
<li>返回<br><code>then</code>方法会返回一个<code>Promise</code>，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise(<a href="https://promisesaplus.com/differences-from-promises-a#point-5">详情</a>)对象，所以在我们的实现中，也让then返回一个新的Promise对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>



<ul>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li>
<li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li>
<li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的拒因</li>
</ul>
<strong>不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected</strong>。<br>每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。</li>
</ul>
<p>下面代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附：值穿透解读</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到值穿透，值穿透即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> MyPromise((resolve, reject) =&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(() =&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="string">&#x27;2&#x27;</span>).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>

<p>最终打结果是<code>1</code>而不是<code>2</code></p>
<p>再例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(resolve =resolve(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">    .then()</span><br><span class="line">    .then()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        alert(value)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// output: alert 出 1</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>return this</code> 只实现了值穿透的一种情况，其实值穿透有两种情况：</p>
<ol>
<li>promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(() =&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&#123;</span><br><span class="line">    promise.then().then((res) =&#123; <span class="comment">// 状况A</span></span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    promise.catch().then((res) =&#123; <span class="comment">// 状况B</span></span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(promise.then() === promise.catch()) <span class="comment">// output: true</span></span><br><span class="line">    <span class="built_in">console</span>.log(promise.then(<span class="number">1</span>) === promise.catch(&#123;<span class="attr">name</span>: <span class="string">&#x27;anran&#x27;</span>&#125;)) <span class="comment">// output: true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 <code>return this</code>。<br>注意：原生的Promise实现里并不是这样实现的，会打印出两个false</li>
<li>promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve) =&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(() =&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = promise.then()</span><br><span class="line">a.then((res) =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> b = promise.catch()</span><br><span class="line">b.then((res) =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>Promise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。</p>
<p>根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果promise1被resolve了，promise2的被<code>1</code>resolve，如果promise1 被reject了，promise2将被<code>new Error(&#39;error&#39;)</code>reject。</p>
<p>所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为<code>x</code>）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class="line">        <span class="comment">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line">      		<span class="comment">// 所以用了 setTimeout 包裹下</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                	<span class="comment">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class="line">                	<span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    	x.then(resolve, reject)</span><br><span class="line">                	&#125;</span><br><span class="line">                	resolve(x) <span class="comment">// 否则，以它的返回值为 promise2 的结果</span></span><br><span class="line">            	&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                	reject(err) <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                	<span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                    	x.then(resolve, reject)</span><br><span class="line">                	&#125;</span><br><span class="line">            	&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                	reject(err)</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class="line">        <span class="comment">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class="line">        <span class="comment">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内</span></span><br><span class="line">        <span class="comment">// 处理逻辑和以上相似</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            _this.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            _this.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise构建之七：catch的实现"><a href="#Promise构建之七：catch的实现" class="headerlink" title="Promise构建之七：catch的实现"></a>Promise构建之七：catch的实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch 的实现</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们大致实现了Promise标准中所涉及到的内容。</p>
<h4 id="Promise构建之八：问题补充：无缝调用"><a href="#Promise构建之八：问题补充：无缝调用" class="headerlink" title="Promise构建之八：问题补充：无缝调用"></a>Promise构建之八：问题补充：无缝调用</h4><p>不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// ES6 的 Promise</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.all([ <span class="comment">// Q 的 Promise</span></span><br><span class="line">        <span class="keyword">new</span> MyPromise(resolve =resolve(<span class="string">&#x27;3&#x27;</span>)) <span class="comment">// 我们实现的Promise</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>.eresolve(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// ES6 的 Promise</span></span><br><span class="line">        Q.resolve(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// Q 的 Promise</span></span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。</p>
<p>接下来，我们解决这个问题</p>
<p>关于不同Promise之间的交互，其实<a href="https://promisesaplus.com/#point-46">Promise/A+标准</a>中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。</p>
<p>即我们要<strong>把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象</strong>，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。</p>
<p>而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。</p>
<p>关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规范 2.3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class="line"><span class="comment">也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class="line"><span class="comment">x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class="line"><span class="comment">resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class="line"><span class="comment">相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规范 2.3.2</span></span><br><span class="line">    <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class="line">        <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">                <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">                <span class="comment">// 把值传给下个 then</span></span><br><span class="line">                resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class="line">            <span class="comment">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then</span><br><span class="line">            <span class="comment">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">    			<span class="comment">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    y =&#123; <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                        called = <span class="literal">true</span></span><br><span class="line">                        <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                        <span class="keyword">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    r =&#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                        called = <span class="literal">true</span></span><br><span class="line">                         <span class="keyword">return</span> reject(r)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 规范 2.3.3.2</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们使用<code>resolutionProcedure</code>函数替换<code>MyPromise.prototype.then</code>里面几处判断x是否为MyPromise对象的位置即可。即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve(x) // 否则，以它的返回值为 promise2 的结果</span></span><br></pre></td></tr></table></figure>

<p>替换为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolutionProcedure(promise2, x, resolve, reject)</span><br></pre></td></tr></table></figure>

<p>总共四处，不要遗漏了</p>
<h4 id="Promise构建九：完整代码实现"><a href="#Promise构建九：完整代码实现" class="headerlink" title="Promise构建九：完整代码实现"></a>Promise构建九：完整代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 Promise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(() =&#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(() =&#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="comment">// new Promise(() =throw Error(&#x27;error&#x27;))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class="line">        <span class="comment">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                <span class="comment">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class="line">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                reject(err) <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class="line">        <span class="comment">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class="line">        <span class="comment">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内</span></span><br><span class="line">        <span class="comment">// 处理逻辑和以上相似</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            _this.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            _this.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范 2.3</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class="line"><span class="comment">    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class="line"><span class="comment">    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class="line"><span class="comment">    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class="line"><span class="comment">    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise!&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 规范 2.3.2</span></span><br><span class="line">        <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class="line">            <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">                x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">                    <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">                    <span class="comment">// 把值传给下个 then</span></span><br><span class="line">                    resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">                &#125;, reject)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class="line">                x.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class="line">                <span class="comment">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class="line">                <span class="keyword">let</span> then = x.then</span><br><span class="line">                <span class="comment">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">                    <span class="comment">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class="line">                    then.call(</span><br><span class="line">                        x,</span><br><span class="line">                        y =&#123; <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                            called = <span class="literal">true</span></span><br><span class="line">                            <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                            <span class="keyword">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        r =&#123;</span><br><span class="line">                            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                            called = <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">return</span> reject(r)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 规范 2.3.3.2</span></span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                called = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">            resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch 的实现</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// finally 的实现</span></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(callback()).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(callback()).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>额外，附加 <code>Promise.race</code> 与 <code>Promise.all</code> 的实现，有兴趣的可以了解一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// race</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            MyPromise.resolve(value).then(resolve, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// all</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">        <span class="keyword">var</span> remaining = args.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            res(i, args[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">res</span>(<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise &amp;&amp; val.then === MyPromise.prototype.then) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val.currentState === RESOLVED) <span class="keyword">return</span> res(i, val.value)</span><br><span class="line">                    <span class="keyword">if</span> (val.currentState === REJECTED) reject(val.value)</span><br><span class="line">                    val.then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                        res(i, val)</span><br><span class="line">                    &#125;, reject)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> then = val.then</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(then.bind(val))</span><br><span class="line">                        p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">                            res(i, val)</span><br><span class="line">                        &#125;, reject)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args[i] = val</span><br><span class="line">            <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">                resolve(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。</p>
<p>void是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。</p>
<p>setTimeout 如果不传时间，默认取0。</p>
<p>“参考”</p>
<p><a href="https://segmentfault.com/q/1010000009781257">promise取消的一些讨论</a></p>
]]></content>
      <tags>
        <tag>Promise 工具</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器异步（二）</title>
    <url>/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载自瓶子君的blog <a href="https://github.com/sisterAn/blog/issues/12">链接</a></p>
</blockquote>
<h3 id="step1：回调函数callback"><a href="#step1：回调函数callback" class="headerlink" title="step1：回调函数callback"></a>step1：回调函数callback</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">asyncFunction(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Time out&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>其中，我们称<code>setTimeout</code>为发起函数，<code>fn</code>为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行<code>setTimeout</code>1s后，执行function函数。</p>
<p>下面，我们再看一种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;XXX1&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&#x27;XXX2&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    <span class="attr">url</span>: <span class="string">&#x27;XXX3&#x27;</span>,</span><br><span class="line">                    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// todo</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。</p>
<p><strong>问题1: 回调地狱</strong></p>
<p>回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。</p>
<p>主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。</p>
<p>再例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p>A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。</p>
<p>但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。</p>
<p>这种情况称为<strong>控制反转</strong>，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。</p>
<p>既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：</p>
<ol>
<li>调用回调过早</li>
<li>调用回调过晚</li>
<li>调用回调次数太多或者太少</li>
<li>未能把所需的参数成功传给你的回调函数</li>
<li>吞掉可能出现的错误或异常</li>
<li>……</li>
</ol>
<p>这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。</p>
<p>这里，我们引出了回调函数处理异步的第二个问题：<strong>控制反转</strong>。</p>
<h3 id="step2：控制反转"><a href="#step2：控制反转" class="headerlink" title="step2：控制反转"></a><strong>step2：控制反转</strong></h3><p>综上，回调函数处理异步流程存在2个问题：</p>
<p><strong>1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</strong></p>
<p><strong>2. 缺乏可信任性： 控制反转导致的一系列信任问题</strong></p>
<p>那么如何来解决这两个问题，先驱者们开始了探索之路……</p>
<hr>
<p>参考：<br><a href="https://github.com/sisterAn/blog/issues/12">瓶子君 blog</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端</title>
    <url>/2018/11/03/%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    <content><![CDATA[<h4 id="如何编写移动端😎-？话不多说，即刻带大家进入今天主题"><a href="#如何编写移动端😎-？话不多说，即刻带大家进入今天主题" class="headerlink" title="如何编写移动端😎 ？话不多说，即刻带大家进入今天主题"></a>如何编写移动端😎 ？话不多说，即刻带大家进入今天主题</h4><ul>
<li>如我们常规所见，移动端和PC端的最大差异就是：设备的分辨率。</li>
<li>移动端：下面是一段默认加载在头部的设置<code>html标签的fontSize</code>的js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">pageWidth= <span class="number">750</span></span>) </span>&#123; <span class="comment">// 设计稿可以传参，普遍是750</span></span><br><span class="line">    !(<span class="function"><span class="keyword">function</span>(<span class="params">win, doc</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 获取设备 宽度</span></span><br><span class="line">            <span class="keyword">var</span> winWidth =  <span class="built_in">window</span>.innerWidth;</span><br><span class="line">            <span class="keyword">var</span> size = (winWidth / pageWidth) * <span class="number">100</span>;</span><br><span class="line">            doc.documentElement.style.fontSize = size + <span class="string">&#x27;px&#x27;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> evt = <span class="string">&#x27;onorientationchange&#x27;</span> <span class="keyword">in</span> win ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        win.addEventListener(evt, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(setFontSize, <span class="number">300</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        win.addEventListener(<span class="string">&quot;pageshow&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(setFontSize, <span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        setFontSize();</span><br><span class="line"></span><br><span class="line">    &#125;(<span class="built_in">window</span>, <span class="built_in">document</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态的获取设备独立像素，然后除以设计稿的宽度(常规UI是输出750宽度)，要乘100，然后赋给根字体的<code>fontsize</code>，以致做到自适应，来动态改变根字体大小。这里拿到是百分比 。</li>
<li>为什么要乘100，首先假设说设备分辨率是375，375 / 750是0.5，0.5我们称为<code>比例R</code>.而浏览器默认最小字体为12px。 这时我们的0.5就会被12重置了。所以我们需要放大一些，而100又很好算。在此，就把浏览器默认字号设置为100px，刚才获取的0.5是比例。那么相乘后获得的50px，就是自适应后的html根字体大小。</li>
<li>为了适配移动端，把单位转换成rem。  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    font-size: 16px; <span class="comment">// 会使rem不跟随错误的12px或者10px （比如设置62.5%时，就会`bodysize`是10px，那样em和rem都会算错。）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>那么1rem 等于（2）步骤返回的html 根字体大小。但这时候问题来了，设计稿输出的是750宽的图纸，而且是px，那么中间该怎么转化？？？比如说1rem 等于50px 那我现在的banner图是690px高，我应该是输出一个690/50 = result(rem)<br>借助<code>sass函数</code>，输入值为690px，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="function"><span class="keyword">function</span> <span class="title">pxTorem</span>(<span class="params">$px</span>)</span>&#123;<span class="comment">//$px为需要转换的字号</span></span><br><span class="line">    @<span class="keyword">return</span> $px / $browser-<span class="keyword">default</span>-font-size * 1rem; <span class="comment">// 其实这里可以理解为 $px * （1rem/ 100）,也就是banner图的高度 * （比例R），从而获得它在这个该设备应该有的大小。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
所以在我们平时写css的时候，可以这么写样式了<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.city-li&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  height: pxTorem(56px);</span><br><span class="line">  line-height: pxTorem(56px);</span><br><span class="line">  padding-left: pxTorem(10px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在可以书写移动端样式后。继续探讨：第二差异是网络环境。网络加载速度不一致是移动端的瓶颈，所以代码量的大小和质量是移动端性能优化的关键。</li>
</ul>
]]></content>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端拖拽</title>
    <url>/2019/02/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<blockquote>
<p>今天聊一下移动端的拖拽，上周一个拖动的需求，正好整理下</p>
</blockquote>
<h6 id="场景是这样的"><a href="#场景是这样的" class="headerlink" title="场景是这样的"></a>场景是这样的</h6><pre><code>需要在H5邀请函里做名字栏位的拖拽，并且要能记住它的位置以便于图片合成。
</code></pre>
<h6 id="用到的技术"><a href="#用到的技术" class="headerlink" title="用到的技术"></a>用到的技术</h6><pre><code>它们都属于原生JS - 移动端监听拖拽的API。
</code></pre>
<ul>
<li><code>touchStart</code> ：<strong>开始触摸</strong>屏幕时就触发</li>
<li><code>touchmove</code>：在屏幕上<strong>滑动</strong>时触发</li>
<li><code>touchend</code>:  <strong>屏幕上离开</strong>的时触发　　 </li>
</ul>
<ul>
<li>其中<em>touchStart</em>和<em>touchmove</em>会提供<em>touch</em>对象,包含</li>
</ul>
<ul>
<li>pageX：触摸目标在页面中的x坐标。</li>
<li>pageY：触摸目标在页面中的y坐标。<br>这次只用了这两个参数<h6 id="还是上点代码吧"><a href="#还是上点代码吧" class="headerlink" title="还是上点代码吧"></a>还是上点代码吧</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragStart</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    isdrag = <span class="literal">true</span>;</span><br><span class="line">    tempX = <span class="built_in">parseInt</span>($(<span class="string">&#x27;.guest_name&#x27;</span>).css(<span class="string">&#x27;left&#x27;</span>) + <span class="number">0</span>);</span><br><span class="line">    tempY = <span class="built_in">parseInt</span>($(<span class="string">&#x27;.guest_name&#x27;</span>).css(<span class="string">&#x27;top&#x27;</span>) + <span class="number">0</span>);</span><br><span class="line">    x = e.touches[<span class="number">0</span>].pageX;</span><br><span class="line">    y = e.touches[<span class="number">0</span>].pageY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isdrag) &#123; <span class="comment">// 这里 e.touches[0].pageY中的pageY</span></span><br><span class="line">        <span class="keyword">let</span> curX = tempX + e.touches[<span class="number">0</span>].pageX - x;</span><br><span class="line">        <span class="keyword">let</span> curY = tempY + e.touches[<span class="number">0</span>].pageY - y;</span><br><span class="line">        <span class="comment">// 边界判断</span></span><br><span class="line">        <span class="comment">// curX = curX &lt; 0 ? 0 : curX;</span></span><br><span class="line">        curY = curY &lt; <span class="number">0</span> ? <span class="number">0</span> : curY;</span><br><span class="line">        curX = curX &lt; <span class="built_in">document</span>.documentElement.clientWidth - <span class="number">80</span> ? curX : <span class="built_in">document</span>.documentElement.clientWidth - <span class="number">80</span>;</span><br><span class="line">        curY = curY &lt; $(<span class="string">&#x27;.firstPageBackground&#x27;</span>).height() - <span class="number">25</span> ? curY : $(<span class="string">&#x27;.firstPageBackground&#x27;</span>).height() - <span class="number">25</span>; <span class="comment">// 这里的高度限制 $(&#x27;.firstPageBackground&#x27;).height() - 25 是来源于业务上，邀请函画布的高度，控制名字不能超出限制。25是名字本身的高度。都以px为单位。</span></span><br><span class="line">        $(<span class="string">&#x27;.guest_name&#x27;</span>).css(&#123;</span><br><span class="line">            <span class="string">&#x27;left&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;top&#x27;</span>: curY</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 禁止浏览器默认事件</span></span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    isdrag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6>好啦，还是别卖关子了，其实原理就是，利用了两次监听移动提供的pageX和pageY 之差。将差值加到原来的绝对定位，left和top里。让dom的位置发生变化。从而达到拖拽的效果。</li>
</ul>
<h6 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h6><p><a href="https://blog.csdn.net/lee_magnum/article/details/17753807">blog</a><br><a href="https://blog.csdn.net/qq_35800306/article/details/59502392">blog</a></p>
]]></content>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/07/15/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-深度优先搜索-amp-amp-广度优先搜索"><a href="#1-深度优先搜索-amp-amp-广度优先搜索" class="headerlink" title="1. 深度优先搜索 &amp;&amp; 广度优先搜索"></a>1. 深度优先搜索 &amp;&amp; 广度优先搜索</h4><p>深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止<br>广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。</p>
<p>参考：<br><a href="https://github.com/sisterAn/JavaScript-Algorithms">瓶子君 算法</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的几种继承方式</title>
    <url>/2020/04/07/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>唠嗑唠嗑JS的继承啦~~~<span id="more"></span></p>
<h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>方式 <code>son.prototype = new father()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grandFather</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.gF_paroperty = <span class="string">&#x27;gF_paroperty&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">grandFather.prototype.getGFPropery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 祖父原型的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.gF_paroperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherPropery = <span class="string">&#x27;fatherPropery&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 grandFather 和 father 的 连接 让父亲继承祖父（核心）</span></span><br><span class="line">father.prototype = <span class="keyword">new</span> grandFather(); </span><br><span class="line"></span><br><span class="line">father.prototype.getFatherVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 父亲原型的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.fatherPropery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sonInstance = <span class="keyword">new</span> father() <span class="comment">// 儿子继承父亲</span></span><br><span class="line"><span class="built_in">console</span>.log(sonInstance.getGFPropery()); <span class="comment">// expect output : &#x27;gF_paroperty&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(sonInstance.getFatherVal()); <span class="comment">// expect output : fatherPropery</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法缺陷: 多个子实例会改变引用类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance2.__proto__.colors) <span class="comment">// array[4]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-构造函数-结合call继承"><a href="#2-构造函数-结合call继承" class="headerlink" title="2. 构造函数 结合call继承"></a>2. 构造函数 结合<code>call</code>继承</h4><p>描述：核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用SuperType构造函数，于是SubType的<code>每个实例都会</code>将SuperType中的属性<code>复制一份</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.specialWay = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="comment">// alert(instance1.color);//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// alert(instance2.color);//&quot;red,green,blue&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.specialWay); <span class="comment">// output：undefined 原型上的属性、方法继承不了</span></span><br></pre></td></tr></table></figure>
<div class="tip">
(1) 只能继承父类的实例属性和方法，不能继承原型属性/方法
(2) 无法实现复用，`每个子类都有父类实例函数的副本`，影响性能
</div>

<h4 id="3-Object-create"><a href="#3-Object-create" class="headerlink" title="3. Object.create"></a>3. <code>Object.create</code></h4><p>也就是提供一个返回一个新对象，并且该对象的__proto__指向传入的对象<br>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较好的用法👍</span></span><br><span class="line">son.prototype = <span class="built_in">Object</span>.create(father.prototype)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip">
(1) 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
(2) 无法传递参数
</div>

<h4 id="4-ES6-extends-super"><a href="#4-ES6-extends-super" class="headerlink" title="4. ES6 extends super"></a>4. ES6 <code>extends</code> <code>super</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-ES5继承和ES6继承的区别"><a href="#5-ES5继承和ES6继承的区别" class="headerlink" title="5. ES5继承和ES6继承的区别"></a>5. ES5继承和ES6继承的区别</h4><ul>
<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.  </li>
<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。<br>因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>
</ul>
<p>参考链接：<br><a href="https://juejin.im/post/5bcb2e295188255c55472db0">掘金</a></p>
]]></content>
      <tags>
        <tag>面试 JS</tag>
      </tags>
  </entry>
  <entry>
    <title>发布订阅模式</title>
    <url>/2021/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<blockquote>
<p>本文摘自《Javascript设计模式与开发实践》</p>
</blockquote>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li>对象之间的依赖关系。当一个对象的状态发生改变时，所有依赖它的对象都会得到通知</li>
<li>Javascript一般用事件模型来替代传统的发布-订阅模式</li>
<li>可能会有中介这个身份，中转所有依赖关系。让发布者和订阅者不需要了解彼此。</li>
</ul>
<h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ul>
<li>提供数据方，和接受数据方，不是强耦合的关系</li>
</ul>
<h3 id="3-模拟"><a href="#3-模拟" class="headerlink" title="3. 模拟"></a>3. 模拟</h3><pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间者统一处理</span></span><br><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clientList = &#123;&#125;,</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove;</span><br><span class="line">    </span><br><span class="line">    listen = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123; <span class="comment">// 添加</span></span><br><span class="line">        <span class="keyword">if</span> (!clientList[key]) &#123;</span><br><span class="line">            clientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        clientList[key] = fn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trigger = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 通知、发布</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">            fns = clientList[key];</span><br><span class="line">        <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++]) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123; <span class="comment">// 删除</span></span><br><span class="line">        <span class="keyword">var</span> fns = clientList[key]</span><br><span class="line">        <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123; <span class="comment">// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></span><br><span class="line">            fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = fns.length -<span class="number">1</span>; i&gt;=<span class="number">0</span>; i-- ) &#123;</span><br><span class="line">                <span class="keyword">var</span> _fn = fns[i]</span><br><span class="line">                <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                    fns.splice(i, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">listen</span>: listen,</span><br><span class="line">        <span class="attr">trigger</span>: trigger,</span><br><span class="line">        <span class="attr">remove</span>: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小红订阅消息 // 输出：&#x27;价格=2000000&#x27; </span></span><br><span class="line">Event.listen( <span class="string">&#x27;squareMeter88&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;价格= &#x27;</span> + price )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Event.trigger( <span class="string">&#x27;squareMeter88&#x27;</span>, <span class="number">2000000</span> );<span class="comment">// 售楼处发布消息</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="4-思考🤔"><a href="#4-思考🤔" class="headerlink" title="4. 思考🤔"></a>4. 思考🤔</h3><pre><code>订阅发布的顺序：
原本是先订阅，再发布，因为先发布没订阅的情况下，消息会丢失
增加先发布后订阅的能力：离线事件的堆栈，用来存储尚未被订阅的离线事件。等到有订阅的时候，再遍历堆栈执行。
需要注意的是，离线事件的触发只有一次。(具体代码实现结合书本参考 )
</code></pre>
<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h3><pre><code>+ 优点：时间和对象上的解耦，常用于异步编程。
+ 缺点：订阅了消息，订阅者会始终存在内存中。对象之间的必要联系会难以跟踪。
</code></pre>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="">设计模式篇观察订阅模式第10节</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2021/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文摘自《Javascript设计模式与开发实践》</p>
</blockquote>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p> 给对象动态添加职责</p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><ul>
<li>解除耦合关系，如提交前的表单检验，函数参数封装等</li>
</ul>
<h3 id="3-模拟"><a href="#3-模拟" class="headerlink" title="3. 模拟"></a>3. 模拟</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href=""></a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>听到请回答1988</title>
    <url>/2019/04/06/%E8%AF%B7%E5%9B%9E%E7%AD%941988/</url>
    <content><![CDATA[<p>啊   感动啊感动<br><img src="https://pic2.zhimg.com/v2-73eb983ad340c514bd4c33f08032000f_r.jpg" alt="合照"><br>很温暖，很简单，很友好的情感</p>
<p>我现在听着1988的网易云歌单，写下这篇日志，希望看到的人也和我一样喜欢这部片子呢</p>
<p>一部小小的电视机里，放着的是我们的润发哥和国荣哥的《英雄本色》，哇好有品位呀，我们故事里的主人公们坐在电视机前，善宇，娃娃鱼，正焕，德善，阿泽。</p>
<p>哈哈，豹纹女士大喊一声:”正焕啊，回家吃饭啦！”，接着他们都回家吃饭，留下我们呆萌的阿泽，阿泽爸爸也进来房间，微笑着说，阿泽，我们也吃饭吧😊</p>
<p>故事DuangDuangDuang开始咯~~~</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器-重排&amp;&amp;重绘</title>
    <url>/2020/07/20/%E9%87%8D%E7%BB%98&amp;&amp;%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<p><img src="/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%921.png" alt="重绘重排1"><br><img src="/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%922.png" alt="重绘重排2"><br><img src="/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%923.png" alt="重绘重排3"><br><img src="/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%924.png" alt="重绘重排4"></p>
<p>参考：<br><a href="https://segmentfault.com/a/1190000016990089">segment</a></p>
]]></content>
      <tags>
        <tag>浏览器 CSS渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2019/12/03/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1.防抖"></a>1.防抖</h3><p>✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。<br>如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，<br>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.<br>简单的说法是，取决于上次没操作后，delay时间后执行。</p>
<p>👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）</p>
<p>介绍三个版本：</p>
<h4 id="1指定this"><a href="#1指定this" class="headerlink" title="1指定this"></a>1指定this</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(func,wait)  <span class="comment">// 保持只是一个定时器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-this指向-amp-amp-指定传参（比如event）"><a href="#2-this指向-amp-amp-指定传参（比如event）" class="headerlink" title="2 this指向 &amp;&amp; 指定传参（比如event）"></a>2 this指向 &amp;&amp; 指定传参（比如<code>event</code>）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="comment">// console.log(this) // 这里的时候指向window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span> <span class="comment">// 这里的时候指向btn 关键是缓存这时候的this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//没绑定context时，这里this指向window</span></span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-this指向-amp-amp-指定传参-amp-amp-立即执行"><a href="#3-this指向-amp-amp-指定传参-amp-amp-立即执行" class="headerlink" title="3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行"></a>3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123; <span class="built_in">clearTimeout</span>(timeout) &#125;</span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123; <span class="comment">// 立即执行</span></span><br><span class="line">                <span class="comment">// timeout有值的情况下，改为延时</span></span><br><span class="line">                <span class="keyword">var</span> callNow = !timeout</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span></span><br><span class="line">                &#125;,wait)</span><br><span class="line">                <span class="keyword">if</span> (callNow) &#123; func.apply(context,args) &#125;</span><br><span class="line">                <span class="comment">// 跑完立即执行，永远都会执行上面的timeout = null，</span></span><br><span class="line">                <span class="comment">// 然后下一次进入判断callNow时，又会是立即执行。 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;,wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-节流"><a href="#2-节流" class="headerlink" title="2.节流"></a>2.节流</h3><p>按指定的delay执行<br> 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景</p>
<p>下面介绍两个版本：</p>
<h4 id="✨-使用时间戳"><a href="#✨-使用时间戳" class="headerlink" title="✨ 使用时间戳"></a>✨ 使用时间戳</h4><p>  使用时间戳，当触发事件的时候，我们取出当前的时间戳，<br>  然后减去之前的时间戳(最一开始值设为 0 )，<br>  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，<br>  如果小于，就不执行。</p>
<div class="tip">
    第一下会立刻执行
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，</span></span><br><span class="line"><span class="comment">// Date.prototype.value方法等同于Date.prototype.getTime()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>() </span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">if</span> ((now - previous) &gt; wait) &#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">            previous = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✨-使用定时器"><a href="#✨-使用定时器" class="headerlink" title="✨ 使用定时器"></a>✨ 使用定时器</h4><p>当触发事件的时候，我们设置一个定时器，<br>再触发事件的时候，如果定时器存在，就不执行，<br>直到定时器执行，然后执行函数，<br>清空定时器，<br>这样就可以设置下个定时器。</p>
<div class="tip">
    第一下会延时执行
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span></span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-两者的关联与区别"><a href="#3-两者的关联与区别" class="headerlink" title="3.两者的关联与区别"></a>3.两者的关联与区别</h3><p>两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率<br>假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。</p>
<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/38313717">专栏</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/26">mqyqingfeng  issue</a></p>
]]></content>
      <tags>
        <tag>JS优化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试要求</title>
    <url>/2020/04/12/%E9%9D%A2%E8%AF%95%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<p>知己知彼，百战百胜<br>实力推荐<br><a href="https://muyiy.cn/">木易杨</a></p>
<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/69705235">阿里p7要求</a><br><a href="https://github.com/jawil/blog/issues/22">阿里P6+要求</a><br><a href="https://juejin.im/post/5e5522b36fb9a07ce152c51c">掘金1</a><br><a href="https://juejin.im/post/587dab348d6d810058d87a0a">掘金2</a><br><a href="https://github.com/axuebin/articles/issues/39">axuebin issue</a><br><a href="https://github.com/coffe1891/frontend-hard-mode-interview">前端内参github</a></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
